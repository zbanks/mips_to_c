CRASHED

struct _mips2c_stack_Actor_ProcessInitChain {
    /* 0x00 */ char pad0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_Color_RGBA8_Copy {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_Vec3f {};         /* size 0x0 */

struct _mips2c_stack_IChain_Apply_Vec3fdiv1000 {};  /* size 0x0 */

struct _mips2c_stack_IChain_Apply_Vec3s {};         /* size 0x0 */

struct _mips2c_stack_IChain_Apply_f32 {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_f32div1000 {};    /* size 0x0 */

struct _mips2c_stack_IChain_Apply_s16 {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_s32 {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_s8 {};            /* size 0x0 */

struct _mips2c_stack_IChain_Apply_u16 {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_u32 {};           /* size 0x0 */

struct _mips2c_stack_IChain_Apply_u8 {};            /* size 0x0 */

struct _mips2c_stack_Lib_LerpRGB {};                /* size 0x0 */

struct _mips2c_stack_Lib_MemCpy {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Lib_Nop801004FC {};            /* size 0x0 */

struct _mips2c_stack_Lib_PhysicalToVirtual {};      /* size 0x0 */

struct _mips2c_stack_Lib_PhysicalToVirtualNull {};  /* size 0x0 */

struct _mips2c_stack_Lib_SegmentedToVirtual {};     /* size 0x0 */

struct _mips2c_stack_Lib_SegmentedToVirtualNull {}; /* size 0x0 */

struct _mips2c_stack_Lib_Vec3f_TranslateAndRotateY {
    /* 0x00 */ char pad0[0x1C];
    /* 0x1C */ f32 sp1C;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_Math_ApproachF {};             /* size 0x0 */

struct _mips2c_stack_Math_ApproachS {};             /* size 0x0 */

struct _mips2c_stack_Math_ApproachZeroF {};         /* size 0x0 */

struct _mips2c_stack_Math_AsymStepToF {};           /* size 0x0 */

struct _mips2c_stack_Math_AsymStepToS {};           /* size 0x0 */

struct _mips2c_stack_Math_CosS {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_ScaledStepToS {};         /* size 0x0 */

struct _mips2c_stack_Math_SinS {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_SmoothStepToF {};         /* size 0x0 */

struct _mips2c_stack_Math_SmoothStepToS {};         /* size 0x0 */

struct _mips2c_stack_Math_StepToAngleS {};          /* size 0x0 */

struct _mips2c_stack_Math_StepToC {};               /* size 0x0 */

struct _mips2c_stack_Math_StepToF {};               /* size 0x0 */

struct _mips2c_stack_Math_StepToI {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_StepToIGet {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_StepToIImpl {};           /* size 0x0 */

struct _mips2c_stack_Math_StepToS {};               /* size 0x0 */

struct _mips2c_stack_Math_StepUntilAngleS {};       /* size 0x0 */

struct _mips2c_stack_Math_StepUntilF {};            /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_AddRand {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_Vec3f_Copy {};            /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_Diff {};            /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_DiffY {};           /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_DistXYZ {
    /* 0x00 */ char pad0[0x1C];
    /* 0x1C */ f32 sp1C;                            /* inferred */
    /* 0x20 */ f32 sp20;                            /* inferred */
    /* 0x24 */ f32 sp24;                            /* inferred */
};                                                  /* size = 0x28 */

struct _mips2c_stack_Math_Vec3f_DistXYZAndStoreDiff {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_Vec3f_DistXYZAndStoreNormDiff {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_Vec3f_DistXZ {};          /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_DistXZAndStore {};  /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_Lerp {};            /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_Pitch {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_Vec3f_Scale {};           /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_ScaleAndStore {};   /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_StepTo {
    /* 0x00 */ char pad0[0x24];
    /* 0x24 */ f32 sp24;                            /* inferred */
    /* 0x28 */ f32 sp28;                            /* inferred */
    /* 0x2C */ f32 sp2C;                            /* inferred */
};                                                  /* size = 0x30 */

struct _mips2c_stack_Math_Vec3f_StepToXZ {
    /* 0x00 */ char pad0[0x20];
    /* 0x20 */ f32 sp20;                            /* inferred */
    /* 0x24 */ f32 sp24;                            /* inferred */
};                                                  /* size = 0x28 */

struct _mips2c_stack_Math_Vec3f_Sum {};             /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_SumScaled {};       /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_ToVec3s {};         /* size 0x0 */

struct _mips2c_stack_Math_Vec3f_Yaw {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Math_Vec3s_Copy {};            /* size 0x0 */

struct _mips2c_stack_Math_Vec3s_DiffToVec3f {};     /* size 0x0 */

struct _mips2c_stack_Math_Vec3s_ToVec3f {};         /* size 0x0 */

struct _mips2c_stack_Rand_S16Offset {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_Rand_S16OffsetStride {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_800FF3A0 {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801000A4 {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801000CC {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801000F4 {
    /* 0x00 */ char pad0[0x18];
};                                                  /* size = 0x18 */

static ? sInitChainHandlers;                        /* unable to generate initializer */
f32 gFramerateDivisorHalf = 0.5f;
u32 gSegments[16];

void *Lib_MemCpy(void *dest, void *src, u32 size) {
    bcopy(src, dest, size);
    return dest;
}

/*
Failed to decompile function Lib_MemSet:

Label L800FED14 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/

f32 Math_CosS(s16 angle) {
    return (f32) coss(angle & 0xFFFF) * 0.00003051851f;
}

f32 Math_SinS(s16 angle) {
    return (f32) sins(angle & 0xFFFF) * 0.00003051851f;
}

s32 Math_StepToIImpl(s32 start, s32 target, s32 step) {
    s32 temp_v1;
    s32 temp_v1_2;

    temp_v1 = start - step;
    if (target >= start) {
        temp_v1_2 = start + step;
        if (target >= temp_v1_2) {
            return temp_v1_2;
        }
        /* Duplicate return node #5. Try simplifying control flow for better match */
        return target;
    }
    if (temp_v1 >= target) {
        return temp_v1;
    }
    return target;
}

void Math_StepToIGet(s32 *pValue, s32 target, s32 step) {
    *pValue = Math_StepToIImpl(*pValue, target, step);
}

s32 Math_StepToI(s32 *pValue, s32 target, s32 step) {
    Math_StepToIGet(pValue, target, step);
    return target == *pValue;
}

s32 Math_ScaledStepToS(s16 *pValue, s16 target, s16 step) {
    s16 temp_v0;
    s16 phi_a2;

    phi_a2 = step;
    if (step != 0) {
        temp_v0 = *pValue;
        if ((s32) (s16) (temp_v0 - target) > 0) {
            phi_a2 = (s16) ((s32) step * -1);
        }
        *pValue = temp_v0 + (s32) ((f32) phi_a2 * gFramerateDivisorHalf);
        if (((s16) (*pValue - target) * phi_a2) >= 0) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #7. Try simplifying control flow for better match */
        return 0;
    }
    if (target == *pValue) {
        return 1;
    }
    return 0;
}

s32 Math_StepToS(s16 *pValue, s16 target, s16 step) {
    s16 temp_v0;
    s16 phi_a2;

    phi_a2 = step;
    if (step != 0) {
        temp_v0 = *pValue;
        if ((s32) target < (s32) temp_v0) {
            phi_a2 = (s16) ((s32) step * -1);
        }
        *pValue = temp_v0 + phi_a2;
        if (((*pValue - target) * phi_a2) >= 0) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #7. Try simplifying control flow for better match */
        return 0;
    }
    if (target == *pValue) {
        return 1;
    }
    return 0;
}

s32 Math_StepToC(s8 *pValue, s8 target, s8 step) {
    s8 temp_v0;
    s8 phi_a2;

    phi_a2 = step;
    if (step != 0) {
        temp_v0 = *pValue;
        if ((s32) target < (s32) temp_v0) {
            phi_a2 = (s8) ((s32) step * -1);
        }
        *pValue = temp_v0 + phi_a2;
        if (((*pValue - target) * phi_a2) >= 0) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #7. Try simplifying control flow for better match */
        return 0;
    }
    if (target == *pValue) {
        return 1;
    }
    return 0;
}

s32 Math_StepToF(f32 *pValue, f32 target, f32 step) {
    f32 temp_f0;
    f32 phi_f12;

    phi_f12 = step;
    if (step != 0.0f) {
        temp_f0 = *pValue;
        if (target < temp_f0) {
            phi_f12 = -step;
        }
        *pValue = temp_f0 + phi_f12;
        if (((*pValue - target) * phi_f12) >= 0.0f) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #7. Try simplifying control flow for better match */
        return 0;
    }
    if (target == *pValue) {
        return 1;
    }
    return 0;
}

s32 Math_StepUntilAngleS(s16 *pValue, s16 target, s16 step) {
    s16 temp_v0;

    temp_v0 = *pValue;
    *pValue = temp_v0 + step;
    if (((s16) (*pValue - target) * (s16) (temp_v0 - target)) <= 0) {
        *pValue = target;
        return 1;
    }
    return 0;
}

s32 Math_StepToAngleS(s16 *pValue, s16 target, s16 step) {
    s16 temp_v1;
    s32 temp_v0;
    s16 phi_a2;
    s32 phi_v0;
    s32 phi_a2_2;

    temp_v1 = *pValue;
    temp_v0 = target - temp_v1;
    phi_v0 = temp_v0;
    phi_a2_2 = (s32) step;
    if (temp_v0 < 0) {
        phi_a2_2 = (s32) (s16) ((s32) step * -1);
    }
    phi_a2 = (s16) phi_a2_2;
    if (temp_v0 >= 0x8000) {
        phi_a2 = (s16) (phi_a2_2 * -1);
        phi_v0 = 0xFFFF0001 - -temp_v0;
    } else if (temp_v0 < -0x7FFF) {
        phi_a2 = (s16) (phi_a2_2 * -1);
        phi_v0 = temp_v0 + 0xFFFF;
    }
    if (phi_a2 != 0) {
        *pValue = temp_v1 + phi_a2;
        if ((phi_a2 * phi_v0) <= 0) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return 0;
    }
    if (target == temp_v1) {
        return 1;
    }
    return 0;
}

s32 Math_AsymStepToS(s16 *pValue, s16 target, s16 incrStep, s16 decrStep) {
    s16 temp_v0;
    s32 phi_v1;
    s32 phi_v1_2;

    temp_v0 = *pValue;
    phi_v1 = (s32) decrStep;
    if ((target - temp_v0) >= 0) {
        phi_v1 = (s32) incrStep;
    }
    phi_v1_2 = phi_v1;
    if (phi_v1 != 0) {
        if ((s32) target < (s32) temp_v0) {
            phi_v1_2 = (s32) (s16) (phi_v1 * -1);
        }
        *pValue = temp_v0 + phi_v1_2;
        if (((*pValue - target) * phi_v1_2) >= 0) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return 0;
    }
    if (target == temp_v0) {
        return 1;
    }
    return 0;
}

s32 Math_StepUntilF(f32 *pValue, f32 limit, f32 step) {
    f32 temp_f16;
    f32 temp_f2;

    temp_f2 = *pValue;
    temp_f16 = temp_f2 - limit;
    *pValue = temp_f2 + step;
    if (((*pValue - limit) * temp_f16) <= 0.0f) {
        *pValue = limit;
        return 1;
    }
    return 0;
}

s32 Math_AsymStepToF(f32 *pValue, f32 target, f32 incrStep, f32 decrStep) {
    f32 temp_f0;
    f32 phi_f2;
    f32 phi_f2_2;

    temp_f0 = *pValue;
    phi_f2 = decrStep;
    if (temp_f0 <= target) {
        phi_f2 = incrStep;
    }
    phi_f2_2 = phi_f2;
    if (phi_f2 != 0.0f) {
        if (target < temp_f0) {
            phi_f2_2 = -phi_f2;
        }
        *pValue = temp_f0 + phi_f2_2;
        if (((*pValue - target) * phi_f2_2) >= 0.0f) {
            *pValue = target;
            return 1;
        }
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return 0;
    }
    if (target == temp_f0) {
        return 1;
    }
    return 0;
}

void func_800FF3A0(f32 *distOut, s16 *angleOut, Input *input) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;

    temp_f2 = (f32) input->rel.stick_x;
    temp_f12 = (f32) input->rel.stick_y;
    temp_f0 = sqrtf((temp_f2 * temp_f2) + (temp_f12 * temp_f12));
    if (temp_f0 > 60.0f) {
        *distOut = 60.0f;
    } else {
        *distOut = temp_f0;
    }
    if (temp_f0 > 0.0f) {
        *angleOut = Math_FAtan2F((f32) input->cur.stick_y, -(f32) input->cur.stick_x);
        return;
    }
    *angleOut = 0;
}

s16 Rand_S16Offset(s16 base, s16 range) {
    return (s16) ((s32) (Rand_ZeroOne() * (f32) range) + base);
}

s16 Rand_S16OffsetStride(s16 base, s16 stride, s16 range) {
    return (s16) (((s16) (s32) (Rand_ZeroOne() * (f32) range) * stride) + base);
}

void Math_Vec3f_Copy(Vec3f *dest, Vec3f *src) {
    dest->x = src->x;
    dest->y = src->y;
    dest->z = src->z;
}

void Math_Vec3s_Copy(Vec3s *dest, Vec3s *src) {
    dest->x = src->x;
    dest->y = src->y;
    dest->z = src->z;
}

void Math_Vec3s_ToVec3f(Vec3f *dest, Vec3s *src) {
    dest->x = (f32) src->x;
    dest->y = (f32) src->y;
    dest->z = (f32) src->z;
}

void Math_Vec3f_ToVec3s(Vec3s *dest, Vec3f *src) {
    dest->x = (s16) (s32) src->x;
    dest->y = (s16) (s32) src->y;
    dest->z = (s16) (s32) src->z;
}

void Math_Vec3f_Sum(Vec3f *l, Vec3f *r, Vec3f *dest) {
    dest->x = l->x + r->x;
    dest->y = l->y + r->y;
    dest->z = l->z + r->z;
}

void Math_Vec3f_Diff(Vec3f *l, Vec3f *r, Vec3f *dest) {
    dest->x = l->x - r->x;
    dest->y = l->y - r->y;
    dest->z = l->z - r->z;
}

void Math_Vec3s_DiffToVec3f(Vec3f *dest, Vec3s *l, Vec3s *r) {
    dest->x = (f32) (l->x - r->x);
    dest->y = (f32) (l->y - r->y);
    dest->z = (f32) (l->z - r->z);
}

void Math_Vec3f_Scale(Vec3f *vec, f32 scale) {
    vec->x *= scale;
    vec->y *= scale;
    vec->z *= scale;
}

void Math_Vec3f_ScaleAndStore(Vec3f *vec, f32 scale, Vec3f *dest) {
    dest->x = vec->x * scale;
    dest->y = vec->y * scale;
    dest->z = vec->z * scale;
}

void Math_Vec3f_Lerp(Vec3f *a, Vec3f *b, f32 t, Vec3f *dest) {
    f32 temp_f0;
    f32 temp_f14;
    f32 temp_f2;

    temp_f0 = a->x;
    dest->x = ((b->x - temp_f0) * t) + temp_f0;
    temp_f2 = a->y;
    dest->y = ((b->y - temp_f2) * t) + temp_f2;
    temp_f14 = a->z;
    dest->z = ((b->z - temp_f14) * t) + temp_f14;
}

void Math_Vec3f_SumScaled(Vec3f *a, Vec3f *b, f32 scale, Vec3f *dest) {
    dest->x = (b->x * scale) + a->x;
    dest->y = (b->y * scale) + a->y;
    dest->z = (b->z * scale) + a->z;
}

void Math_Vec3f_AddRand(Vec3f *orig, f32 scale, Vec3f *dest) {
    dest->x = randPlusMinusPoint5Scaled(scale) + orig->x;
    dest->y = randPlusMinusPoint5Scaled(scale) + orig->y;
    dest->z = randPlusMinusPoint5Scaled(scale) + orig->z;
}

void Math_Vec3f_DistXYZAndStoreNormDiff(Vec3f *a, Vec3f *b, f32 scale, Vec3f *dest) {
    f32 temp_f0;
    f32 temp_f2;

    temp_f0 = Math_Vec3f_DistXYZAndStoreDiff(a, b, dest);
    if (temp_f0 != 0.0f) {
        temp_f2 = scale / temp_f0;
        dest->x *= temp_f2;
        dest->y *= temp_f2;
        dest->z *= temp_f2;
    }
}

f32 Math_Vec3f_DistXYZ(Vec3f *a, Vec3f *b) {
    f32 sp1C;

    Math_Vec3f_Diff(b, a, (Vec3f *) &sp1C);
    return sqrtf((sp1C * sp1C) + (sp20 * sp20) + (sp24 * sp24));
}

f32 Math_Vec3f_DistXYZAndStoreDiff(Vec3f *a, Vec3f *b, Vec3f *dest) {
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;

    Math_Vec3f_Diff(b, a, dest);
    temp_f2 = dest->x;
    temp_f12 = dest->y;
    temp_f14 = dest->z;
    return sqrtf((temp_f2 * temp_f2) + (temp_f12 * temp_f12) + (temp_f14 * temp_f14));
}

f32 Math_Vec3f_DistXZ(Vec3f *a, Vec3f *b) {
    f32 temp_f12;
    f32 temp_f2;

    temp_f2 = b->x - a->x;
    temp_f12 = b->z - a->z;
    return sqrtf((temp_f2 * temp_f2) + (temp_f12 * temp_f12));
}

f32 Math_Vec3f_DistXZAndStore(Vec3f *a, Vec3f *b, f32 *dx, f32 *dz) {
    f32 temp_f12;
    f32 temp_f2;

    *dx = b->x - a->x;
    *dz = b->z - a->z;
    temp_f2 = *dz;
    temp_f12 = *dx;
    return sqrtf((temp_f2 * temp_f2) + (temp_f12 * temp_f12));
}

f32 Math_Vec3f_StepToXZ(Vec3f *start, Vec3f *target, f32 speed) {
    f32 sp24;
    f32 sp20;
    Vec3f *temp_a1;
    f32 temp_f0;
    f32 phi_f12;
    f32 phi_f2;

    temp_a1 = start;
    start = temp_a1;
    temp_f0 = Math_Vec3f_DistXZAndStore(target, temp_a1, &sp24, &sp20);
    phi_f12 = temp_f0 - speed;
    if (temp_f0 < speed) {
        phi_f12 = 0.0f;
    }
    if (phi_f12 == 0.0f) {
        phi_f2 = 0.0f;
    } else {
        phi_f2 = phi_f12 / temp_f0;
    }
    start->x = target->x + (sp24 * phi_f2);
    start->z = target->z + (sp20 * phi_f2);
    return phi_f12;
}

f32 Math_Vec3f_DiffY(Vec3f *a, Vec3f *b) {
    return b->y - a->y;
}

s16 Math_Vec3f_Yaw(Vec3f *a, Vec3f *b) {
    return Math_FAtan2F(b->z - a->z, b->x - a->x);
}

s16 Math_Vec3f_Pitch(Vec3f *a, Vec3f *b) {
    return Math_FAtan2F(Math_Vec3f_DistXZ(a, b), a->y - b->y);
}

void Actor_ProcessInitChain(Actor *actor, InitChainEntry *ichain) {
    InitChainEntry *phi_s0;

    phi_s0 = ichain;
    do {
        *(&sInitChainHandlers + (((u32) (*phi_s0 * 2) >> 0x1C) * 4))(actor, phi_s0);
        phi_s0 += 4;
    } while (((u32) *phi_s0 >> 0x1F) != 0);
}

void IChain_Apply_u8(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (u8) ichain->unk2;
}

void IChain_Apply_s8(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (u8) ichain->unk2;
}

void IChain_Apply_u16(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (s16) ichain->unk2;
}

void IChain_Apply_s16(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (s16) ichain->unk2;
}

void IChain_Apply_u32(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (s32) ichain->unk2;
}

void IChain_Apply_s32(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (s32) ichain->unk2;
}

void IChain_Apply_f32(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (f32) ichain->unk2;
}

void IChain_Apply_f32div1000(u8 *ptr, InitChainEntry *ichain) {
    ptr[ichain->unk0 & 0x7FF] = (f32) ((f32) ichain->unk2 / 1000.0f);
}

void IChain_Apply_Vec3f(u8 *ptr, InitChainEntry *ichain) {
    f32 temp_f0;
    u8 *temp_v0;

    temp_v0 = &ptr[ichain->unk0 & 0x7FF];
    temp_f0 = (f32) ichain->unk2;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk0 = temp_f0;
}

void IChain_Apply_Vec3fdiv1000(u8 *ptr, InitChainEntry *ichain) {
    f32 temp_f0;
    u8 *temp_v0;

    temp_v0 = &ptr[ichain->unk0 & 0x7FF];
    temp_f0 = (f32) ichain->unk2 / 1000.0f;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk0 = temp_f0;
}

void IChain_Apply_Vec3s(u8 *ptr, InitChainEntry *ichain) {
    s16 temp_v1;
    u8 *temp_v0;

    temp_v1 = ichain->unk2;
    temp_v0 = &ptr[ichain->unk0 & 0x7FF];
    temp_v0->unk4 = temp_v1;
    temp_v0->unk2 = temp_v1;
    temp_v0->unk0 = temp_v1;
}

f32 Math_SmoothStepToF(f32 *pValue, f32 target, f32 fraction, f32 step, f32 minStep) {
    f32 temp_f0;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f2;
    f32 phi_f0;
    f32 phi_f0_2;

    temp_f2 = *pValue;
    if (target != temp_f2) {
        temp_f0 = (target - temp_f2) * fraction;
        phi_f0 = temp_f0;
        if ((minStep <= temp_f0) || (temp_f14 = -minStep, (temp_f0 <= temp_f14))) {
            temp_f14_2 = -step;
            if (step < temp_f0) {
                phi_f0 = step;
            }
            phi_f0_2 = phi_f0;
            if (phi_f0 < temp_f14_2) {
                phi_f0_2 = temp_f14_2;
            }
            *pValue = temp_f2 + phi_f0_2;
            goto block_15;
        }
        if (temp_f0 > 0.0f) {
            if (temp_f0 < minStep) {
                *pValue = temp_f2 + minStep;
                if (target < *pValue) {
                    *pValue = target;
                    goto block_15;
                }
            }
        } else if (temp_f14 < temp_f0) {
            *pValue = temp_f2 + temp_f14;
            if (*pValue < target) {
                *pValue = target;
block_15:
            }
        }
    }
    return fabsf(target - *pValue);
}

void Math_ApproachF(f32 *pValue, f32 target, f32 scale, f32 maxStep) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;
    f32 phi_f2;

    temp_f0 = *pValue;
    if (target != temp_f0) {
        temp_f2 = (target - temp_f0) * scale;
        phi_f2 = temp_f2;
        if (maxStep < temp_f2) {
            phi_f2 = maxStep;
        } else {
            temp_f12 = -maxStep;
            if (temp_f2 < temp_f12) {
                phi_f2 = temp_f12;
            }
        }
        *pValue = temp_f0 + phi_f2;
    }
}

void Math_ApproachZeroF(f32 *pValue, f32 scale, f32 maxStep) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;
    f32 phi_f0;

    temp_f2 = *pValue;
    temp_f0 = temp_f2 * scale;
    phi_f0 = temp_f0;
    if (maxStep < temp_f0) {
        phi_f0 = maxStep;
    } else {
        temp_f12 = -maxStep;
        if (temp_f0 < temp_f12) {
            phi_f0 = temp_f12;
        }
    }
    *pValue = temp_f2 - phi_f0;
}

s32 Math_SmoothStepToS(s16 *pValue, s16 target, s16 scale, s16 step, s16 minStep) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_lo;
    s32 phi_v0;
    s32 phi_v0_2;

    temp_t0 = *pValue;
    temp_v1 = target - temp_t0;
    if (target != temp_t0) {
        temp_lo = (s32) temp_v1 / (s32) scale;
        phi_v0 = (s32) (s16) temp_lo;
        if (((s32) minStep < (s32) (s16) temp_lo) || ((s32) (s16) temp_lo < -(s32) minStep)) {
            if ((s32) step < (s32) (s16) temp_lo) {
                phi_v0 = (s32) step;
            }
            phi_v0_2 = phi_v0;
            if (phi_v0 < -(s32) step) {
                phi_v0_2 = (s32) (s16) ((s32) step * -1);
            }
            *pValue = temp_t0 + phi_v0_2;
        } else if ((s32) temp_v1 >= 0) {
            *pValue = temp_t0 + minStep;
            if ((s32) (s16) (target - *pValue) <= 0) {
                goto block_12;
            }
        } else {
            *pValue = temp_t0 - minStep;
            if ((s32) (s16) (target - *pValue) >= 0) {
block_12:
                *pValue = target;
            }
        }
    }
    return (s32) temp_v1;
}

void Math_ApproachS(s16 *pValue, s16 target, s16 scale, s16 maxStep) {
    s16 temp_v1;
    s32 temp_lo;

    temp_v1 = *pValue;
    temp_lo = (s32) (s16) (target - temp_v1) / (s32) scale;
    if ((s32) maxStep < (s32) (s16) temp_lo) {
        *pValue = temp_v1 + maxStep;
        return;
    }
    if ((s32) (s16) temp_lo < -(s32) maxStep) {
        *pValue = temp_v1 - maxStep;
        return;
    }
    *pValue = temp_v1 + (s16) temp_lo;
}

void Color_RGBA8_Copy(Color_RGBA8 *dst, Color_RGBA8 *src) {
    dst->r = src->r;
    dst->g = src->g;
    dst->b = src->b;
    dst->a = src->a;
}

void func_801000A4(u16 sfxId) {
    play_sound(sfxId & 0xFFFF);
}

void func_801000CC(u16 sfxId) {
    func_8019F128(sfxId & 0xFFFF);
}

void func_801000F4(s32 a0, u16 a1) {
    func_8019F1C0((Vec3f *) a0, a1 & 0xFFFF);
}

void Lib_Vec3f_TranslateAndRotateY(Vec3f *translation, s16 a, Vec3f *src, Vec3f *dst) {
    f32 sp1C;
    f32 temp_f0;

    sp1C = Math_CosS(a);
    temp_f0 = Math_SinS(a);
    dst->x = translation->x + ((src->x * sp1C) + (src->z * temp_f0));
    dst->y = translation->y + src->y;
    dst->z = translation->z + ((src->z * sp1C) - (src->x * temp_f0));
}

void Lib_LerpRGB(Color_RGB8 *a, Color_RGB8 *b, f32 t, Color_RGB8 *dst) {
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f10;
    f32 temp_f16;
    f32 temp_f4;
    u8 temp_t0;
    u8 temp_t1;
    u8 temp_t4;
    u8 temp_t5;
    u8 temp_t6;
    u8 temp_t7;
    f32 phi_f10;
    f32 phi_f0;
    f32 phi_f4;
    f32 phi_f0_2;
    f32 phi_f16;
    f32 phi_f0_3;

    temp_t6 = a->r;
    temp_f0 = (f32) temp_t6;
    phi_f0 = temp_f0;
    if ((s32) temp_t6 < 0) {
        phi_f0 = temp_f0 + 4294967296.0f;
    }
    temp_t7 = b->r;
    temp_f10 = (f32) temp_t7;
    phi_f10 = temp_f10;
    if ((s32) temp_t7 < 0) {
        phi_f10 = temp_f10 + 4294967296.0f;
    }
    dst->r = (u8) (u32) (((phi_f10 - phi_f0) * t) + phi_f0);
    temp_t0 = a->g;
    temp_f0_2 = (f32) temp_t0;
    phi_f0_2 = temp_f0_2;
    if ((s32) temp_t0 < 0) {
        phi_f0_2 = temp_f0_2 + 4294967296.0f;
    }
    temp_t1 = b->g;
    temp_f4 = (f32) temp_t1;
    phi_f4 = temp_f4;
    if ((s32) temp_t1 < 0) {
        phi_f4 = temp_f4 + 4294967296.0f;
    }
    dst->g = (u8) (u32) (((phi_f4 - phi_f0_2) * t) + phi_f0_2);
    temp_t4 = a->b;
    temp_f0_3 = (f32) temp_t4;
    phi_f0_3 = temp_f0_3;
    if ((s32) temp_t4 < 0) {
        phi_f0_3 = temp_f0_3 + 4294967296.0f;
    }
    temp_t5 = b->b;
    temp_f16 = (f32) temp_t5;
    phi_f16 = temp_f16;
    if ((s32) temp_t5 < 0) {
        phi_f16 = temp_f16 + 4294967296.0f;
    }
    dst->b = (u8) (u32) (((phi_f16 - phi_f0_3) * t) + phi_f0_3);
}

f32 Math_Vec3f_StepTo(Vec3f *start, Vec3f *target, f32 speed) {
    f32 sp24;
    Vec3f *temp_a1;
    f32 temp_f0;
    f32 temp_f2;
    f32 phi_f12;

    temp_a1 = start;
    start = start;
    Math_Vec3f_Diff(target, temp_a1, (Vec3f *) &sp24);
    temp_f0 = Math3D_Vec3fMagnitude((Vec3f *) &sp24);
    if (speed < temp_f0) {
        temp_f2 = speed / temp_f0;
        start->x += temp_f2 * sp24;
        start->y += temp_f2 * sp28;
        start->z += temp_f2 * sp2C;
        phi_f12 = temp_f0 - speed;
    } else {
        Math_Vec3f_Copy(start, target);
        phi_f12 = 0.0f;
    }
    return phi_f12;
}

void Lib_Nop801004FC(void) {

}

void *Lib_SegmentedToVirtual(void *ptr) {
    return gSegments[(u32) ((s32) ptr * 0x10) >> 0x1C] + ((s32) ptr & 0xFFFFFF) + 0x80000000;
}

void *Lib_SegmentedToVirtualNull(void *ptr) {
    if (((u32) ptr >> 0x1C) == 0) {
        return ptr;
    }
    return gSegments[(u32) ((s32) ptr * 0x10) >> 0x1C] + ((s32) ptr & 0xFFFFFF) + 0x80000000;
}

void *Lib_PhysicalToVirtual(void *ptr) {
    if (ptr == 0) {
        return NULL;
    }
    return ptr + 0x80000000;
}

void *Lib_PhysicalToVirtualNull(void *ptr) {
    if (ptr == 0) {
        return NULL;
    }
    return ptr + 0x80000000;
}
