s32 func_80187BEC(s32, s32 *, s32, s16);            /* extern */
? func_8018B740(s32 *, s32, ?);                     /* extern */
? func_8018B7BC(? (*)(s32, s32, s32, s32));         /* extern */
? func_8018C994(f32, s32, s32, f32);                /* extern */
s32 func_8018CCA8();                                /* extern */
? func_8018E344(u8, u8, ? (*)(s32, s32, s32, s32), ?); /* extern */
? func_8018EB60();                                  /* extern */
? func_8018F588(u8, u8, ? (*)(s32, s32, s32, s32), OSMesgQueue *); /* extern */
? func_8018F6F0(u8, u8, u8);                        /* extern */
? func_8018F7F8(u8, u8, u8, OSMesgQueue *);         /* extern */
? func_8018F83C(u8, u8, u8, OSMesgQueue *);         /* extern */
? func_8018F880(u8, u8, u8, OSMesgQueue *);         /* extern */
? func_8018F8C4();                                  /* extern */
? func_8018F908(u8);                                /* extern */
? func_8018FA60(u8, u8, u8, ? (*)(s32, s32, s32, s32)); /* extern */
? func_8018FAD0(u8, u8, u8);                        /* extern */
? func_8018FB20(u8, u8, ? (*)(s32, s32, s32, s32)); /* extern */
? func_80190B08(u8);                                /* extern */
? func_80192B54();                                  /* extern */
? func_80194790(s32, s32, void *);                  /* extern */
s32 func_801957B4(s32, u8, u8, ? (*)(s32, s32, s32, s32)); /* extern */
? func_80197D24(void *, ? (*)(s32, s32, s32, s32), u8 *); /* extern */
? func_8019AAF0(void *, s32);                       /* extern */
AudioTask *func_80192C00();                         /* static */
void func_8019319C(u8 *arg0, u8 *);                 /* static */
void func_801936D8(u8 arg0, ? (*arg1)(s32, s32, s32, s32), u8 *); /* static */
void func_8019372C(u8 arg0, ? (*arg1)(s32, s32, s32, s32)); /* static */
void func_80193774();                               /* static */
void func_8019380C(s32 *arg0, s32 *arg1);           /* static */
void func_80193858(s32 arg1);                       /* static */
void func_8019387C(s32 arg1, s32, s32);             /* static */
void func_801938A0(s32 arg1);                       /* static */
void func_801938D0(s32 arg1);                       /* static */
s32 func_80193900();                                /* static */
void func_80193990();                               /* static */
void func_801939A8(u8 *arg0);                       /* static */
void func_80193AEC(void *arg0);                     /* static */
u32 func_80193BA0(s32 *arg0);                       /* static */
void func_80193C04();                               /* static */
void func_80193C24(s32 arg0, s32 *arg1, s32 *arg2); /* static */
? func_80193C5C();                                  /* static */
void func_80193CB4();                               /* static */
s32 func_80193D08(s32 arg0);                        /* static */
void func_80193DA4();                               /* static */
s8 func_80193DF0(s32 arg0, s32 arg1, s32 arg2);     /* static */
s8 func_80193E44(s32 arg0, s32 arg1);               /* static */
void func_80193E6C(s32 arg0, ? arg1);               /* static */
void func_80193E9C();                               /* static */
void func_80193EA8(void *arg0, u8 *arg1);           /* static */
void func_80194080(void *arg0, u8 *arg1);           /* static */
void func_801942BC(s32 arg0, s32 arg1, s32 arg2);   /* static */
void func_80194304();                               /* static */
void func_80194328(s32 arg0, s32 arg1);             /* static */
void func_8019435C();                               /* static */
s32 func_8019439C();                                /* static */
s32 func_801943D0();                                /* static */
s32 func_8019440C(s32 *arg0, s32 *arg1, s32 arg2, s32 *arg3, s32 *arg4); /* static */
void func_80194528();                               /* static */
void func_80194548();                               /* static */
s32 func_80194568(? (*arg0)(s32, s32, s32, s32), ? (*)(s32, s32, s32, s32)); /* static */
void *func_80194668();                              /* static */
void func_801946E4();                               /* static */
static u64 D_801AAAB0 = {
    0x340A0FC08D420018,
    0x8D43001C40803800,
    0xD0006C320010000,
    0x201802E020170FB0,
    0x8D5C0020AF1C000C,
    0x8D5C00308D5B0034,
    0x4005580030A40001,
    0x1080000630A40100,
    0x1080000400000000,
    0x4004580030840100,
    0x1C80FFFD00000000,
    0xD00043300000000,
    0x8FBA00008FB90004,
    0x1A0DC2302100FE,
    0x239C0008237BFFF8,
    0x23BD000823DEFFF8,
    0x1102084420010,
    0x40000800000000,
    0xD1FC0FFF2,
    0x1B600005,
    0xD000433,
    0x9000418,
    0x34014000,
    0x408120000000000D,
    0x1000FFFF,
    0x23E50000,
    0x1C102023630000,
    0x2064FFC018800002,
    0x200102F020030040,
    0x207E00000D0006C3,
    0x2063FFFF00A00008,
    0x201D02F040043800,
    0x1480FFFE00000000,
    0x400428001480FFFE,
    0x40810000,
    0x4082080040831000,
    0x3E0000800000000,
    0x400438001480FFFE,
    0x40042800,
    0x1480FFFE00000000,
    0x4081000040820800,
    0x4083180003E00008,
    0x3323FFFF,
    0x1060FFCE3342FFFF,
    0x4A00002C2063FFF0,
    0xE8401800E8401801,
    0x204200101C60FFFC,
    0x2063FFF009000425,
    0x191402A71A0000,
    0xA702000209000425,
    0xA71900043344FFFF,
    0x1A0B0230210FF0,
    0x3323FFFF00191402,
    0xC8411800C8621800,
    0x2021FFF820840010,
    0xE8810878E881097A,
    0x20420008E8810A7C,
    0xE8810B7EE8820879,
    0x20630008E882097B,
    0xE8820A7D1C20FFF2,
    0xE8820B7F09000425,
    0x3321FFFF3342FFFF,
    0x2024FFF00480000B,
    0x191C02C8411800,
    0xC84218012021FFF0,
    0x20420010E8611800,
    0x2024FFF0E8621801,
    0x481FFF820630010,
    0x10200006C8410800,
    0x2021FFFE20420002,
    0xE86108001C20FFFB,
    0x2063000209000425,
    0x190A0000010A02,
    0x9000425AF010008,
    0xC81F20004A1BDEEC,
    0x971500004A19CE6C,
    0x4A18C62C22B40001,
    0x971300024A0D6B6C,
    0x4A0E73AC97120004,
    0x4A0F7BEC4A10842C,
    0x198A004A118C6C,
    0x4A1294AC00118A02,
    0x4A139CECEA7B2000,
    0xEA7B200120100040,
    0x200F0330001A0C02,
    0x302800041100000A,
    0x200A0005,
    0x2009000ECA191802,
    0xCA1718032210FFFF,
    0xCA191C0222100002,
    0x90004BCCA171C03,
    0x200A00092009000C,
    0xCA191800CA181C00,
    0xCA171801CA171C01,
    0x1A0C0230210001,
    0x1C200008001A0C02,
    0x3021000210010002,
    0x222200008F020008,
    0x226100000D0006C3,
    0x2003001FCA7B2001,
    0x2273002012400077,
    0xCA81180092A10000,
    0x302B000F000B5940,
    0x4B01C8E8016F6820,
    0x4A04212C4A0631AC,
    0x150000044B21C968,
    0x4B21C1284B41C968,
    0x4B61C1A800017102,
    0x91020004E7022,
    0x21C2FFFF34038000,
    0x11C000022004FFFF,
    0x4320064884B000,
    0xC9B52000C9B42001,
    0x21ADFFFEC9B32802,
    0x21ADFFFEC9B22802,
    0x21ADFFFEC9B12802,
    0x21ADFFFEC9B02802,
    0x21ADFFFEC9AF2802,
    0x21ADFFFEC9AE2802,
    0x21ADFFFEC9AD2802,
    0x28AA0204A171F86,
    0x2AAA8204A17278E,
    0xCA8118004A172F46,
    0x92A100004A17374E,
    0x19C00003302B000F,
    0x4B16F7854B16EF45,
    0xB59404B01C8E8,
    0x16F682015000004,
    0x4B21C9684B21C128,
    0x4B41C9684B61C1A8,
    0x171024BDBA887,
    0x910204BFBA08F,
    0x4E70224B1E988F,
    0x21C2FFFF4B3E908F,
    0x200300014B5E888F,
    0x31BC04B7E808F,
    0x11C000022004FFFF,
    0x4320064B9E7F0F,
    0x4884B0004BBE708F,
    0x4BDE688F4BBFF08F,
    0x4B3C3E9D4B1C3F1D,
    0x4B9FD0864B9FE70F,
    0x4B1D988721ACFFFE,
    0x4B3D908FC9932802,
    0x4B5D888F218CFFFE,
    0x4B7D808FC9922802,
    0x4B9D788F218CFFFE,
    0x4BBD708FC9912802,
    0x4BDD688F218CFFFE,
    0x4BBFE88FC9902802,
    0x4BDCA88F218CFFFE,
    0x4BFCA08FC98F2802,
    0x4B3B3E9D218CFFFE,
    0x4B1B3EDDC98E2802,
    0x218CFFFEC98D2802,
    0xC9B520004B9FD086,
    0xC9B420014B9FDECF,
    0x2252FFE0EA7C1800,
    0xEA7C1C01EA7B1802,
    0xEA7B1C031E40FFB0,
    0x227300202261FFE0,
    0x22220000090006BF,
    0x20030020840300E0,
    0x2063F3C710600004,
    0x8F02000C200100E0,
    0xD0006C3200301FF,
    0x8708000087130002,
    0x8712000400191200,
    0x2120222E10000,
    0x2B0202003001F,
    0x1A3C0230EA0001,
    0x1D40000500000000,
    0xD0006C300000000,
    0x900055F00000000,
    0xA6E000084A10842C,
    0xEAF0180030EA0002,
    0x11400006CAF01800,
    0x2108FFFCE9100800,
    0xE9100A0109000577,
    0x30EA0004,
    0x1140000C00000000,
    0x2108FFF0E9100800,
    0xE9100801E9100902,
    0xE9100903E9100A04,
    0xE9100A05E9100B06,
    0xE9100B0709000577,
    0x2108FFF8,
    0xE9101800CAF70F04,
    0xC910180048889200,
    0x200A00E0488A9300,
    0x489A9400200A0040,
    0x488A950020090060,
    0xC93F2001C9392000,
    0x4A1FCE51C93E2002,
    0xC93D2003C93C2004,
    0xC93B2005C93A2006,
    0x4A1FCE51C9382007,
    0x22F5002022F40030,
    0x4A16B5AC4BF7FDC5,
    0x4B92CD8D4B1EFDCE,
    0x4B52FD464B5EB54E,
    0x4BB2BC444B9E8C46,
    0x4B72FC4EC9392000,
    0xEAB52000EA912000,
    0xEAF70B8486B10000,
    0x8689000086AD0008,
    0x8685000886B00002,
    0x8688000286AC000A,
    0x8684000A86AF0004,
    0x8687000486AB000C,
    0x8683000C86AE0006,
    0x8686000686AA000E,
    0x8682000ECA301800,
    0x4BF7FDC5C92F1800,
    0x4BF6FDCFC9B01C00,
    0x4B92CD8DC8AF1C00,
    0x4B1EFDCECA0E1800,
    0x4B52FD46C90D1800,
    0x4B5EB54EC98E1C00,
    0x4BB2BC44C88D1C00,
    0xC9EC1800C8EB1800,
    0xC96C1C004B9E8C46,
    0xC86B1C00C9CA1800,
    0xC8C918004B72FC4E,
    0xC94A1C004A0F8200,
    0xC8491C004A0D71C0,
    0xEAB520004A0B6180,
    0xEA91200086B10000,
    0x4A09514086890000,
    0x4A68421086AD0008,
    0x4A6739D086850008,
    0x4A66319086B00002,
    0x4A65295086880002,
    0x4AC8421086AC000A,
    0x4AC739D08684000A,
    0x4AC6319086AF0004,
    0x4AC5295086870004,
    0x4A88E90686AB000C,
    0x4A87E10E8683000C,
    0x4A86D90E86AE0006,
    0x4A85D10E86860006,
    0x86AA000E2252FFF0,
    0xEA6420001A400003,
    0x8682000E090005A9,
    0x22730010EAF70804,
    0xCA301800EAF01800,
    0x16102022E10000,
    0x90006BF20030020,
    0x1A7C0231EF00FF,
    0x334DFFFF00197402,
    0x21EFFFFF332CFFFF,
    0xC9A12000C9A22001,
    0x218CFFE021AD0020,
    0xE9C12000E9C22001,
    0x1D80FFF921CE0020,
    0x1DE0FFF500000000,
    0x900042500000000,
    0x1A7C0231EF00FF,
    0x334DFFFF00197402,
    0xC9A12000C9A22001,
    0xC9A32002C9A42003,
    0xC9A52004C9A62005,
    0xC9A72006C9A82007,
    0x21EFFFFFE9C12000,
    0xE9C22001E9C32002,
    0xE9C42003E9C52004,
    0xE9C62005E9C72006,
    0xE9C820071DE0FFF6,
    0x21CE008009000425,
    0x334CFFFF,
    0x332EFFFF00196C02,
    0xC9A10800C9A20804,
    0xC9A30808C9A4080C,
    0xC9A10902C9A20906,
    0xC9A3090AC9A4090E,
    0x21AD0020218CFFF8,
    0xE9C11000E9C21001,
    0xE9C31002E9C41003,
    0x1D80FFF121CE0010,
    0x90004254A04212C,
    0x4A00002CC8032000,
    0x2B5A82048952000,
    0x48952100001A6302,
    0x31930FF002D6B020,
    0x4896220048962300,
    0x196502318E0FF0,
    0x16B5820488B2400,
    0x488B250000196302,
    0x318F0FF000196102,
    0x31900FF000196100,
    0x31910FF0334C0002,
    0xC6042000C6022,
    0x488C1000334C0001,
    0xC6022488C1100,
    0x334C0008000C6042,
    0xC6022488C1200,
    0x334C0004000C6042,
    0xC6022488C1300,
    0x1A6202319400FF,
    0x4A000010334A0010,
    0xCA682000CA6F2001,
    0x227300204B014245,
    0x4B4142852294FFF0,
    0xC9CB2000C9EC2000,
    0x4B217C054B617C45,
    0xC9D22001C9F32001,
    0x4B024A6C4B2252AC,
    0xCA0D2000CA2E2000,
    0x4A095AD04A0A6310,
    0x4B814A454B815285,
    0x4B02842C4B228C6C,
    0xCA142001CA352001,
    0x4A1094904A119CD0,
    0x4BA184054BA18C45,
    0x4B424A6C4B6252AC,
    0xE9CB20004B42842C,
    0x4B628C6C15400015,
    0xE9EC20004A096B50,
    0x4A0A7390E9D22001,
    0xE9F320014A10A510,
    0x4A11AD5021CE0020,
    0xEA0D2000EA2E2000,
    0x21EF0020CA682000,
    0xEA14200122100020,
    0x4A040854EA352001,
    0x223100201E80FFCD,
    0x4A00001009000425,
    0x4A00002C4A0A6B50,
    0x4A097390E9D22001,
    0xE9F320014A11A510,
    0x90006814A10AD50,
    0x4A01086C334BFFFF,
    0x1A6202318CFF00,
    0x488C0C00018B6020,
    0x488C0D000019AC02,
    0x90004253336FFFF,
    0x196402488C0800,
    0x1956020488C0900,
    0x332CFFFF488C0A00,
    0x196602009000425,
    0x488C0B00001A1B02,
    0x30630FF03341FFFF,
    0x19120003E00008,
    0x212020D0006A9,
    0x90006BB,
    0xD0006A9,
    0x90006BF,
    0xD0006AC,
    0x20010330090006BB,
    0x3343FFFF0D0006C3,
    0x2063FFFF09000425,
    0xD0006CD,
    0x2063FFFF09000425,
    0x40043800,
    0x1480FD7A00000000,
    0x400428001480FFFE,
    0x40810000,
    0x40820800090006D6,
    0x4083100040043800,
    0x1480FD7B00000000,
    0x400428001480FFFE,
    0x40810000,
    0x4082080040831800,
    0x200400011480FFFF,
    0x4004300003E00008,
    0x40803800C81F2000,
    0x1A930232520FF0,
    0x3333FFFF0019A402,
    0x3351FFFF4891F000,
    0xCA7B2000CA9D2000,
    0xCA7A2001CA9C2001,
    0x4BDFDEC02252FFE0,
    0x4B1EEEC822940020,
    0x4BDFD6804B1EE688,
    0xCA9D2000EA7B2000,
    0xCA7B2002EA7A2001,
    0xCA9C200122730020,
    0x1E40FFF3CA7A2001,
    0x9000425970D0000,
    0x4A0210AC970E0002,
    0x4A0318EC970C0004,
    0x198A0000118A02,
    0xE9C22000E9C32001,
    0x1A0C0230210001,
    0x1C200008001A0C02,
    0x3021000210010002,
    0x222200008F020008,
    0x21C100000D0006C3,
    0x2003001F21CE0020,
    0x1180000B00000000,
    0xC9A23000C9A33001,
    0x21AD0010218CFFE0,
    0xC9A43000E9C22000,
    0xC9A53001E9C32001,
    0x1D80000521CE0020,
    0x21C1FFE022220000,
    0x90006BF20030020,
    0x218CFFE0C9A23002,
    0xE9C42000C9A33003,
    0xE9C5200121AD0020,
    0x1D80FFEE21CE0020,
    0x900071600000000,
    0x22ED00004A00002C,
    0x22EE0020E9A02000,
    0x191200E9A02001,
    0x21202001A6402,
    0x318C00FF1180000B,
    0x218CFFFF,
    0x1180000A00000000,
    0x334FFFFF4A00002C,
    0xE9C02000E9C02002,
    0x21C10010090006BB,
    0x2003001001A00820,
    0xD0006C32003001F,
    0xC9D82001C9B92001,
    0x4A0E73AC4A000000,
    0x200C4000488C7800,
    0x4B0FC3884B0FCB88,
    0xE9CE2001E9AE2001,
    0x1A00820334BFFFF,
    0xC9D82001C9DC1801,
    0xC9DC1C02C9D41803,
    0xC9D41C0421CE0002,
    0xC9DF1800C9DF1C01,
    0xC9D11802C9D11C03,
    0xC9DB1801C9DB1C02,
    0xC9D51803C9D51C04,
    0x21CE0002C9DE1800,
    0xC9DE1C01C9DA1801,
    0xC9DA1C02C9D21802,
    0xC9D21C03C9D61803,
    0xC9D61C0421CE0002,
    0xC9DD1800C9DD1C01,
    0xC9D91801C9D91C02,
    0xC9D31802C9D31C03,
    0xC9D71803C9D71C04,
    0xC9AF2000C9702000,
    0x4A0E73AC4A000000,
    0x4B2FBB884B4FB388,
    0x4B6FAB884B8FA388,
    0x4BAF9B884BCF9388,
    0x4BEF8B884B10C388,
    0x4B30CB884B50D388,
    0x4B70DB884B90E388,
    0x4BB0EB884BD0F388,
    0x4BF0FB8821EFFFF0,
    0xE96E2000216B0010,
    0x1DE0FFEA4A1003D4,
    0xE9B02000090006BF,
    0x2003001F4A1FFFD4,
    0x1A930232520FF0,
    0x3333FFFF0019A402,
    0xCA7B2000CA9D2000,
    0xCA7A2001CA9C2001,
    0xCA792002CA972002,
    0xCA782003CA962003,
    0x229400404A1DDED0,
    0x4A1CD6904A17CE50,
    0x4A16C6102252FFC0,
    0xEA7B2000EA7A2001,
    0xEA792002EA782003,
    0x227300401E40FFED,
    0xCA7B200009000425,
    0x870E0000,
    0x870F0002870D0004,
    0x334CFFFF000C6080,
    0x332AFFFF000E7400,
    0x14E5025000A5C02,
    0x316BFFFEC9610800,
    0x14C5020000A5C02,
    0x316BFFFEC9610900,
    0x14C5020000A5C02,
    0x316BFFFEC9610A00,
    0x14C5020000A5C02,
    0x316BFFFEC9610B00,
    0x14C502021ADFFF8,
    0xE9E1180021EF0008,
    0x1DA0FFEC00000000,
    0xD00042500000000,
    0x334CFFFF00196C02,
    0x1A790231EFF000,
    0x488F1900001A7D02,
    0x31EF000F488F1800,
    0xC9A12000C9A22001,
    0x4B2309054B03090F,
    0x4B2311454B03114F,
    0xE9A42000E9A52001,
    0x218CFFE01D80FFF6,
    0x21AD002009000425,
    0x4A00002C334CFFFF,
    0x332FFFFF00196C02,
    0x91B00000020F7020,
    0x91D0000000108200,
    0xA5B00000218CFFFF,
    0x1D80FFF921AD0002,
    0x900042500000000,
    0x334CFFFF00196C02,
    0x21AE0000332FFFFF,
    0x1A5C02316B00FF,
    0x1EB7820C9EB1800,
    0xC9EC1802C9ED1804,
    0xC9EE1806C9EB1C01,
    0xC9EC1C03C9ED1C05,
    0xC9EE1C07C9A32000,
    0xC9A42001C9A52002,
    0xC9A620034A0B18C7,
    0x4A0C21074A0D2947,
    0x4A0E3187E9A32000,
    0xE9A42001E9A52002,
    0xE9A62003218CFFC0,
    0x1D80FFF221AD0040,
    0x900042500000000,
};
static void D_801D4B90;                             /* unable to generate initializer */
static s32 D_801D5FE8 = 0;
static AudioTask *D_801D5FF0 = NULL;
static s32 D_801D5FF4 = 0;
static u8 D_801D5FF8 = 0;
static void *D_801D5FFC = (void *)0x12345678;
static u64 D_801D6200 = {
    0xC3966AD0D46FFDF,
    0xB3966960E5FFFD8,
    0xA4466690F83FFD0,
    0x95A662610B4FFC8,
    0x87D65CD11F0FFBF,
    0x7AB655E1338FFB6,
    0x6E464D9148CFFAC,
    0x628643F15EBFFA1,
    0x577638F1756FF96,
    0x4D162CB18CBFF8A,
    0x43561F31A4CFF7E,
    0x3A461061BD7FF71,
    0x31C60071D6CFF64,
    0x29F5EF51F0BFF56,
    0x22A5DD020B3FF48,
    0x1BE5C9A2264FF3A,
    0x15B5B53241EFF2C,
    0x10159FC25E0FF1E,
    0xAE589627A9FF10,
    0x635720297AFF02,
    0x1F559D2B50FEF4,
    0xFFE2540D2D2CFEE8,
    0xFFAC52702F0DFEDB,
    0xFF7C50C730F3FED0,
    0xFF534F1432DCFEC6,
    0xFF2E4D5734C8FEBD,
    0xFF0F4B9136B6FEB6,
    0xFEF549C238A5FEB0,
    0xFEDF47ED3A95FEAC,
    0xFECE46113C85FEAB,
    0xFEC044303E74FEAC,
    0xFEB6424A4060FEAF,
    0xFEAF4060424AFEB6,
    0xFEAC3E744430FEC0,
    0xFEAB3C854611FECE,
    0xFEAC3A9547EDFEDF,
    0xFEB038A549C2FEF5,
    0xFEB636B64B91FF0F,
    0xFEBD34C84D57FF2E,
    0xFEC632DC4F14FF53,
    0xFED030F350C7FF7C,
    0xFEDB2F0D5270FFAC,
    0xFEE82D2C540DFFE2,
    0xFEF42B50559D001F,
    0xFF02297A57200063,
    0xFF1027A9589600AE,
    0xFF1E25E059FC0101,
    0xFF2C241E5B53015B,
    0xFF3A22645C9A01BE,
    0xFF4820B35DD0022A,
    0xFF561F0B5EF5029F,
    0xFF641D6C6007031C,
    0xFF711BD7610603A4,
    0xFF7E1A4C61F30435,
    0xFF8A18CB62CB04D1,
    0xFF961756638F0577,
    0xFFA115EB643F0628,
    0xFFAC148C64D906E4,
    0xFFB61338655E07AB,
    0xFFBF11F065CD087D,
    0xFFC810B46626095A,
    0xFFD00F8366690A44,
    0xFFD80E5F66960B39,
    0xFFDF0D4666AD0C39,
    0x30006000D,
    0x130019001E001F,
    0x1F001A00110002,
    0xFFF0FFDBFFC1FFA9,
    0xFF90FF79FF66FF5C,
    0xFF58FF5FFF71FF8E,
    0xFFB6FFE800250068,
    0xAE00F6013A0176,
    0x1A801CC01DD01D7,
    0x1BC0188013B00D8,
    0x62FFDAFF47FEAF,
    0xFE18FD8AFD0AFCA3,
    0xFC58FC2FFC30FC5A,
    0xFCB0FD34FDDEFEAE,
    0xFF9B009D01AB02B9,
    0x3BD04A905710C7C,
    0xF990137BF98A11E8,
    0xFA9E0D14FCBE0577,
    0xFFABFC0A02FDF235,
    0x62DE99B08ADE3D1,
    0x9FFE21A09CCE52C,
    0x7F4ECFC049DF8B0,
    0x3206B5FB5414ED,
    0xF6C82100F35728C1,
    0xF1A92A89F22D258D,
    0xF4FA1A0CF9CE0962,
    0x6F5DF06BAE279,
    0xCDDD2591165C85E,
    0x1376C69A128CCDEF,
    0xE96DDD50801F451,
    0xFFAF0E3AF6D8279C,
    0xEEE13C5BE91F7AB1,
    0xDBB4D911DA4EDF2A,
    0xE712F125FC52077C,
    0x118619831EB920C1,
    0x1F841B4214810C05,
    0x2B3F97FF151EAEA,
    0xE6DAE56DE6AAEA51,
    0xEFECF6D2FE480586,
    0xBD810AA13931464,
    0x1328101C0BA70656,
    0xBEFB75F6FFF3C3,
    0xF200F1CAF306F578,
    0xF8C5FC81003D0391,
    0x62907D0086D0808,
    0x6CC04F502CE00A8,
    0xFEC8FD6AFCAEFC9C,
    0xFD27FE26FF620A06,
    0xF698218D1D111C06,
    0xFA35F6EEDF02ABEE,
    0x2949B973F5211D12,
    0xEAD12E7A13BF004C,
    0x704E71CEAB3EC22,
    0x3D6075A18193C0C,
    0xE2BA31A50732EB16,
    0xEFBDF7EF287FFB3,
    0xFB60103C0D880BB6,
    0xFE1EFA60F0CCDBF9,
    0x1143E342FC7B0CC2,
    0xF739128B0734004C,
    0x23DF86DFA3BFC72,
    0xFFEE03E8064F0C02,
    0xFABF07D6FFD8FB66,
    0x294FB6D00000000,
};
static u8 D_80200C70;
static s16 D_802034DC;
static s16 D_802034F0;
static s32 D_80203530;
static s32 D_80203640;
static u8 D_802050B9;
static ? D_80205228;
static OSMesgQueue *D_802085F8;
static OSMesgQueue *D_802085FC;
static OSMesgQueue D_80208604;
static OSMesgQueue D_8020861C;
static OSMesgQueue D_80208634;
static void *D_8020864C;
static void *D_80208650;
static void *D_80208654;
static ? (*D_80208E68)(s32, s32, s32, s32);
static ? (*D_80208E70)(s32, s32, s32, s32);
static ? (*D_80208E74)(s32, s32, s32, s32);
static u64 D_801E1E80 = {
    0x10002FFFF,
    0x2008007FFF4000,
    0x1F80125011541094,
    0x1E0C15141E7C1C90,
    0x1180180811E81ADC,
    0x1B6C11941EF81240,
    0x17C0186C1A5818BC,
    0x1ABC1ACC1A801BD4,
    0xF0000F0000F0000F,
    0x1001001001000,
    0xC00030000C000300,
    0x1000400100040,
    0x2000400060008,
    0xA000C000E0010,
    0x1000100010001,
    0x1000100010001,
    0x100020004,
    0x8001001000200,
    0x1000000000000,
    0x1000000000000,
    0x100000000,
    0x100000000,
    0x10000,
    0x10000,
    1,
    1,
    0x2000400060008000,
    0xA000C000E000FFFF,
    0xC3966AD0D46FFDF,
    0xB3966960E5FFFD8,
    0xA4466690F83FFD0,
    0x95A662610B4FFC8,
    0x87D65CD11F0FFBF,
    0x7AB655E1338FFB6,
    0x6E464D9148CFFAC,
    0x628643F15EBFFA1,
    0x577638F1756FF96,
    0x4D162CB18CBFF8A,
    0x43561F31A4CFF7E,
    0x3A461061BD7FF71,
    0x31C60071D6CFF64,
    0x29F5EF51F0BFF56,
    0x22A5DD020B3FF48,
    0x1BE5C9A2264FF3A,
    0x15B5B53241EFF2C,
    0x10159FC25E0FF1E,
    0xAE589627A9FF10,
    0x635720297AFF02,
    0x1F559D2B50FEF4,
    0xFFE2540D2D2CFEE8,
    0xFFAC52702F0DFEDB,
}; /* extra bytes: 4; const */
static ? D_801E2160;                                /* unable to generate initializer; const */
void *D_801D4DB0 = &D_801D4B90;
void *D_801D6000 = (void *)0x11111111;
OSMesgQueue D_80202AB0;
OSMesgQueue D_80202B60;
u64 *gAudioSPDataPtr;



AudioTask *func_80192BE0(void) {
    return func_80192C00();
}

AudioTask *func_80192C00(void) {
    u32 sp6C;
    s32 sp68;
    s32 sp5C;
    s32 sp58;
    void *sp4C;
    s32 sp48;
    void *sp3C;
    void *sp34;
    ? (*temp_v0)(s32, s32, s32, s32);
    ? (*temp_v0_3)(s32, s32, s32, s32);
    AudioTask *temp_v1_8;
    s16 temp_a0_2;
    s16 temp_v0_2;
    s16 temp_v1;
    s16 temp_v1_2;
    s16 temp_v1_7;
    s32 temp_a0;
    s32 temp_a0_3;
    s32 temp_a3;
    s32 temp_a3_2;
    s32 temp_hi;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s0_3;
    s32 temp_s0_4;
    s32 temp_s0_5;
    s32 temp_t4;
    s32 temp_t4_2;
    s32 temp_t5;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    void *temp_a2;
    void *temp_t0;
    void *temp_t8;
    void *temp_v1_3;
    s16 phi_v1;
    s32 phi_a0;
    s32 phi_v1_2;
    s32 phi_s0;
    s32 phi_v1_3;
    s32 phi_v1_4;
    s32 phi_s0_2;
    s32 phi_v1_5;
    s32 phi_s0_3;
    s32 phi_s0_4;
    s32 phi_v1_6;
    s32 phi_s0_5;

    temp_v1 = D_80200C70.unk286C;
    temp_t7 = D_80200C70.unk28C0 + 1;
    temp_a3 = temp_t7;
    temp_a0 = temp_t7 % (s32) temp_v1;
    D_80200C70.unk28C0 = temp_t7;
    phi_v1 = temp_v1;
    if (temp_a0 != 0) {
        temp_v0 = D_80208E68;
        phi_a0 = temp_a0;
        if (temp_v0 != 0) {
            temp_v0(temp_a0, temp_a3, 0, temp_a3);
            temp_v1_2 = D_802034DC;
            phi_v1 = temp_v1_2;
            phi_a0 = (s32) D_80203530 % (s32) temp_v1_2;
        }
        if (phi_v1 == (phi_a0 + 1)) {
            return D_801D5FF0;
        }
        return NULL;
    }
    osSendMesg(D_80200C70.unk798C, (void *) temp_a3, 0);
    temp_t4 = D_80200C70.unk28CC + 1;
    temp_t6 = temp_t4 % 3;
    temp_hi = (s32) (temp_t6 + 1) % 3;
    D_80200C70.unk28CC = temp_t4;
    D_80200C70.unk28C8 = (s32) (D_80200C70.unk28C8 ^ 1);
    D_80200C70.unk28CC = temp_t6;
    sp6C = osAiGetLength() >> 2;
    if ((u32) D_80200C70.unk29A4 < 0x10U) {
        temp_a2 = &D_80200C70 + (temp_hi * 2);
        temp_v0_2 = temp_a2->unk2994;
        temp_v1_3 = &D_80200C70 + (temp_hi * 4);
        if (temp_v0_2 != 0) {
            sp34 = temp_v1_3;
            sp3C = temp_a2;
            func_80194790(temp_v1_3->unk2988, temp_v0_2 * 4, temp_a2);
        }
    }
    temp_v0_3 = D_80208E68;
    if (temp_v0_3 != 0) {
        temp_v0_3();
    }
    temp_v1_4 = D_80200C70.unk28C4;
    phi_v1_2 = temp_v1_4;
    phi_s0 = 0;
    phi_v1_3 = temp_v1_4;
    phi_s0_2 = 0;
    phi_s0_3 = 0;
    phi_s0_4 = 0;
    phi_s0_5 = 0;
    if (temp_v1_4 > 0) {
        do {
            sp5C = phi_v1_2;
            phi_v1_6 = phi_v1_2;
            if (osRecvMesg(&D_80202B60, NULL, 0) == 0) {
                phi_v1_6 = phi_v1_2 - 1;
            }
            temp_s0 = phi_s0 + 1;
            phi_v1_2 = phi_v1_6;
            phi_s0 = temp_s0;
            phi_v1_3 = phi_v1_6;
        } while (temp_s0 < D_80200C70.unk28C4);
    }
    phi_v1_4 = phi_v1_3;
    if ((phi_v1_3 != 0) && (phi_v1_3 > 0)) {
        do {
            sp5C = phi_v1_4;
            osRecvMesg(&D_80202B60, NULL, 1);
            temp_s0_2 = phi_s0_2 + 1;
            phi_s0_2 = temp_s0_2;
        } while (temp_s0_2 != phi_v1_4);
    }
    temp_v1_5 = D_80200C70.unk1EF8;
    phi_v1_5 = temp_v1_5;
    if ((temp_v1_5 != 0) && (temp_v1_5 > 0)) {
        do {
            sp48 = phi_v1_5;
            osRecvMesg(&D_80202B60, NULL, 0);
            temp_s0_3 = phi_s0_3 + 1;
            phi_s0_3 = temp_s0_3;
        } while (temp_s0_3 != phi_v1_5);
    }
    D_80200C70.unk28C4 = 0;
    func_8018EB60();
    func_80190B08(D_80200C70.unk4448);
    func_80192B54();
    if ((D_80200C70.unk4448 != 0) && (func_8018CCA8() == 0)) {
        if (D_80200C70.unk4448 == 0) {
            osSendMesg(D_80200C70.unk7988, (void *) D_80200C70.unk4449, 0);
        }
        D_801D5FF0 = NULL;
        return NULL;
    }
    if ((u32) D_80200C70.unk29A4 >= 0x11U) {
        return NULL;
    }
    if (D_80200C70.unk29A4 != 0) {
        D_80200C70.unk29A4 = (u32) (D_80200C70.unk29A4 + 1);
    }
    temp_v1_6 = D_80200C70.unk28C8;
    temp_s0_4 = D_80200C70.unk28CC;
    D_80200C70.unk28DC = (AudioTask *) (&D_80200C70 + (temp_v1_6 * 0x50) + 0x28E0);
    temp_t8 = &D_80200C70 + (temp_s0_4 * 4);
    D_80200C70.unk28D8 = (s32) (&D_80200C70 + (temp_v1_6 * 4))->unk28D0;
    sp34 = temp_t8;
    temp_t0 = &D_80200C70 + (temp_s0_4 * 2);
    temp_t0->unk2994 = (s16) ((((D_80200C70.unk2872 - sp6C) + 0x80) & 0xFFF0) + 0x10);
    temp_a0_2 = D_80200C70.unk2876;
    sp58 = temp_t8->unk2988;
    if ((s32) temp_t0->unk2994 < (s32) temp_a0_2) {
        temp_t0->unk2994 = temp_a0_2;
    }
    temp_v1_7 = D_80200C70.unk2874;
    if ((s32) temp_v1_7 < (s32) temp_t0->unk2994) {
        temp_t0->unk2994 = temp_v1_7;
    }
    sp3C = temp_t0;
    if (D_80200C70.unk4448 == 0) {
        sp3C = temp_t0;
        if (osRecvMesg(D_80200C70.unk7990, &sp4C, 0) != -1) {
            do {
                func_80193AEC(sp4C);
                temp_s0_5 = phi_s0_5 + 1;
                phi_s0_4 = temp_s0_5;
                phi_s0_5 = temp_s0_5;
            } while (osRecvMesg(D_80200C70.unk7990, &sp4C, 0) != -1);
        }
        if ((phi_s0_4 == 0) && (D_80200C70.unk797A != 0)) {
            func_80193900();
        }
    }
    temp_a0_3 = D_80200C70.unk28D8;
    if (gAudioSPDataPtr == temp_a0_3) {
        return (AudioTask *)-1;
    }
    D_80200C70.unk28D8 = func_80187BEC(temp_a0_3, &sp68, sp58, sp3C->unk2994);
    temp_a3_2 = D_80200C70.unk28C0;
    temp_t5 = osGetCount() * (D_80200C70.unk299C + temp_a3_2);
    D_80200C70.unk299C = temp_t5;
    temp_t4_2 = *(sp34->unk2988 + ((temp_a3_2 & 0xFF) * 2)) + temp_t5;
    D_80200C70.unk299C = temp_t4_2;
    D_801D4DB0 = (temp_t4_2 & 0xFFF0) + func_80192BE0;
    D_80200C70.unk28DC->taskQueue = NULL;
    D_80200C70.unk28DC->unk44 = 0;
    temp_v1_8 = D_80200C70.unk28DC;
    temp_v1_8->task.t.type = 2;
    temp_v1_8->task.t.flags = 0;
    temp_v1_8->task.t.ucode_boot = &D_801AAAB0;
    temp_v1_8->task.t.ucode_boot_size = 0x1000;
    temp_v1_8->task.t.ucode_data_size = (((s32) (&D_801E2160 - &D_801E1E80) >> 3) * 8) - 1;
    temp_v1_8->task.t.ucode = &D_801AAAB0;
    temp_v1_8->task.t.ucode_data = &D_801E1E80;
    temp_v1_8->task.t.ucode_size = 0x1000;
    temp_v1_8->task.t.dram_stack = &D_801D6200;
    temp_v1_8->task.t.dram_stack_size = 0;
    temp_v1_8->task.t.output_buff = NULL;
    temp_v1_8->task.t.output_buff_size = NULL;
    temp_v1_8->task.t.data_ptr = (&D_80200C70 + (D_80200C70.unk28C8 * 4))->unk28D0;
    temp_v1_8->task.t.yield_data_ptr = NULL;
    temp_v1_8->task.t.yield_data_size = 0;
    temp_v1_8->task.t.data_size = sp68 * 8;
    if (D_80200C70.unk29BC < sp68) {
        D_80200C70.unk29BC = sp68;
    }
    if (D_80200C70.unk286C == 1) {
        return D_80200C70.unk28DC;
    }
    D_801D5FF0 = D_80200C70.unk28DC;
    return NULL;
}

void func_8019319C(s8 *arg0, ? (*arg1)(s32, s32, s32, s32)) {
    ? (*sp3C)(s32, s32, s32, s32);
    ? (*sp2C)(s32, s32, s32, s32);
    s8 *sp20;
    ? (*temp_a1_5)(s32, s32, s32, s32);
    ? (*temp_t8)(s32, s32, s32, s32);
    s16 temp_v1_5;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a2;
    s8 *temp_v0;
    s8 *temp_v0_5;
    s8 temp_t7;
    s8 temp_t9;
    u8 *temp_v0_4;
    u8 temp_v0_8;
    u8 temp_v1;
    u8 temp_v1_2;
    u8 temp_v1_4;
    u8 temp_v1_6;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_9;
    void *temp_v1_3;
    s8 *phi_v0;
    s32 phi_a1;
    s32 phi_a0;
    s32 phi_a1_2;
    s32 phi_a2;
    s8 *phi_v0_2;
    s32 phi_a1_3;
    s8 *phi_v0_3;
    ? (*phi_a1_4)(s32, s32, s32, s32);
    s32 phi_v1;
    ? (*phi_a1_5)(s32, s32, s32, s32);

    temp_v1 = arg0->unk0;
    phi_a1_5 = arg1;
    if ((s32) temp_v1 >= 0x91) {
        switch (temp_v1) { // switch 1
        case 240: // switch 1
            D_80200C70.unk28BE = (s8) arg0->unk4;
            return;
        case 241: // switch 1
            temp_v1_2 = arg0->unk1;
            if (temp_v1_2 == 0xFF) {
                phi_v0 = &D_80200C70;
                phi_a1 = 0;
                if ((s32) D_80200C70.unk2880 > 0) {
                    do {
                        temp_a1 = phi_a1 + 1;
                        temp_v0 = phi_v0 + 0x160;
                        temp_t9 = phi_v0->unk4460 | 0x20;
                        temp_v0->unk4300 = temp_t9;
                        temp_v0->unk4300 = (s8) (temp_t9 | 4);
                        phi_v0 = temp_v0;
                        phi_a1 = temp_a1;
                    } while (temp_a1 < (s32) D_80200C70.unk2880);
                    return;
                }
                // Duplicate return node #54. Try simplifying control flow for better match
                return;
            }
            temp_v0_2 = &D_80200C70 + (temp_v1_2 * 0x160);
            temp_v0_2->unk4460 = (u8) (temp_v0_2->unk4460 | 0x20);
            temp_v0_3 = &D_80200C70 + (arg0->unk1 * 0x160);
            temp_v0_3->unk4460 = (u8) (temp_v0_3->unk4460 | 4);
            return;
        case 242: // switch 1
            if (arg0->unk4 == 1) {
                temp_a2 = D_80200C70.unk28B8;
                phi_a0 = 0;
                phi_a1_2 = 0;
                phi_a2 = temp_a2;
                if (temp_a2 > 0) {
                    do {
                        temp_a1_2 = phi_a1_2 + 1;
                        temp_v1_3 = phi_a0 + D_80200C70.unk445C;
                        phi_a1_2 = temp_a1_2;
                        if ((((u32) temp_v1_3->unkD8 >> 0x1F) != 0) && (temp_v1_3->unk38 == 0)) {
                            temp_v0_4 = temp_v1_3 + 0xD8;
                            if ((temp_v1_3->unk48->unk60->unk3 & 8) != 0) {
                                *temp_v0_4 |= 0x20;
                                phi_a2 = D_80200C70.unk28B8;
                            }
                        }
                        phi_a0 += 0xF8;
                    } while (temp_a1_2 < phi_a2);
                }
            }
            temp_v1_4 = arg0->unk1;
            if (temp_v1_4 == 0xFF) {
                phi_v0_2 = &D_80200C70;
                phi_a1_3 = 0;
                if ((s32) D_80200C70.unk2880 > 0) {
                    do {
                        temp_a1_3 = phi_a1_3 + 1;
                        temp_v0_5 = phi_v0_2 + 0x160;
                        temp_t7 = phi_v0_2->unk4460 & 0xFFDF;
                        temp_v0_5->unk4300 = temp_t7;
                        temp_v0_5->unk4300 = (s8) (temp_t7 | 4);
                        phi_v0_2 = temp_v0_5;
                        phi_a1_3 = temp_a1_3;
                    } while (temp_a1_3 < (s32) D_80200C70.unk2880);
                    return;
                }
                // Duplicate return node #54. Try simplifying control flow for better match
                return;
            }
            temp_v0_6 = &D_80200C70 + (temp_v1_4 * 0x160);
            temp_v0_6->unk4460 = (u8) (temp_v0_6->unk4460 & 0xFFDF);
            temp_v0_7 = &D_80200C70 + (arg0->unk1 * 0x160);
            temp_v0_7->unk4460 = (u8) (temp_v0_7->unk4460 | 4);
            return;
        case 243: // switch 1
            func_8018F6F0(arg0->unk1, arg0->unk2, arg0->unk3);
            return;
        case 244: // switch 1
            func_8018F83C(arg0->unk1, arg0->unk2, arg0->unk3, &D_80202AB0);
            return;
        case 245: // switch 1
            func_8018F880(arg0->unk1, arg0->unk2, arg0->unk3, &D_80202AB0);
            return;
        case 252: // switch 1
            func_8018F7F8(arg0->unk1, arg0->unk2, arg0->unk3, &D_80202AB0);
            return;
        case 246: // switch 1
            func_8018F908(arg0->unk2);
            return;
        case 249: // switch 1
            D_80200C70.unk4448 = 5;
            D_80200C70.unk4449 = (s8) arg0->unk4;
            return;
        case 251: // switch 1
            D_80208E68 = arg0->unk4;
            return;
        case 228: // switch 1
            temp_v0_8 = arg0->unk3;
            if (temp_v0_8 == 0xFF) {
                D_80208E70 = arg0->unk4;
                return;
            }
            if (temp_v0_8 == 0xFE) {
                D_80208E74 = arg0->unk4;
                return;
            }
            (&D_80200C70 + (temp_v0_8 * 4))->unk29A8 = arg0->unk4;
            return;
        case 224: // switch 1
        case 225: // switch 1
        case 226: // switch 1
            if (func_801957B4(temp_v1 - 0xE0, arg0->unk2, arg0->unk3, arg0->unk4) != 0) {
                return;
            }
            // Duplicate return node #54. Try simplifying control flow for better match
            return;
        case 254: // switch 1
            temp_t8 = arg0->unk4;
            sp2C = temp_t8;
            if (temp_t8 == 1) {
                temp_v1_5 = D_80200C70.unk2880;
                phi_v0_3 = &D_80200C70;
                phi_a1_4 = NULL;
                phi_a1_5 = NULL;
                phi_v1 = (s32) temp_v1_5;
                if ((s32) temp_v1_5 > 0) {
                    do {
                        if (((u32) phi_v0_3->unk4460 >> 0x1F) != 0) {
                            sp20 = phi_v0_3;
                            sp3C = phi_a1_4;
                            func_80197D24(phi_v0_3 + 0x4460, phi_a1_4);
                            phi_v1 = (s32) D_802034F0;
                        }
                        temp_a1_4 = phi_a1_4 + 1;
                        phi_v0_3 += 0x160;
                        phi_a1_4 = (? (*)(s32, s32, s32, s32)) temp_a1_4;
                        phi_a1_5 = (? (*)(s32, s32, s32, s32)) temp_a1_4;
                    } while (temp_a1_4 < phi_v1);
                }
            }
            func_80194568(sp2C, phi_a1_5);
            return;
        case 227: // switch 1
            func_8018B7BC(arg0->unk4);
            return;
        case 229: // switch 1
            func_8018FA60(arg0->unk1, arg0->unk2, arg0->unk3, arg0->unk4);
            return;
        case 230: // switch 1
            func_8018E344(arg0->unk2, arg0->unk1, arg0->unk4, 0);
            // Duplicate return node #54. Try simplifying control flow for better match
            return;
        }
    } else {
        switch (temp_v1) { // switch 2
        case 129: // switch 2
            func_8018F588(arg0->unk2, arg0->unk3, arg0->unk4, &D_80202AB0);
            return;
        case 130: // switch 2
            func_8018FAD0(arg0->unk1, arg0->unk2, arg0->unk3);
            func_8019372C(arg0->unk1, arg0->unk4);
            return;
        case 133: // switch 2
            func_8018FB20(arg0->unk1, arg0->unk2, arg0->unk4);
            func_8019372C(arg0->unk1, (? (*)(s32, s32, s32, s32))0x1F4);
            func_8019AAF0(&D_80200C70 + (arg0->unk1 * 0x160) + 0x4460, 0x160);
            return;
        case 131: // switch 2
            temp_v1_6 = arg0->unk1;
            temp_v0_9 = &D_80200C70 + (temp_v1_6 * 0x160);
            if (((u32) temp_v0_9->unk4460 >> 0x1F) != 0) {
                temp_a1_5 = arg0->unk4;
                if (temp_a1_5 == 0) {
                    func_80197D24(temp_v0_9 + 0x4460, temp_a1_5, &D_80200C70);
                    return;
                }
                func_801936D8(temp_v1_6, temp_a1_5, &D_80200C70);
                return;
            }
        default: // switch 2
        default: // switch 1
            return;
        case 144: // switch 2
            (&D_80200C70 + (arg0->unk1 * 2))->unk797C = (u16) arg0->unk4;
            return;
        }
    }
}

void func_801936D8(u8 arg0, ? (*arg1)(s32, s32, s32, s32)) {
    void *temp_v0;
    s16 phi_a1;

    phi_a1 = (s16) arg1;
    if (arg1 == 0) {
        phi_a1 = 1;
    }
    temp_v0 = (arg0 * 0x160) + 0x4460 + &D_80200C70;
    temp_v0->unk1 = 2;
    temp_v0->unk12 = phi_a1;
    temp_v0->unk20 = (f32) -(temp_v0->unk1C / (f32) phi_a1);
}

void func_8019372C(u8 arg0, s16 arg1) {
    void *temp_v0;

    if (arg1 != 0) {
        temp_v0 = (arg0 * 0x160) + &D_80200C70;
        temp_v0->unk4461 = 1;
        temp_v0->unk4474 = arg1;
        temp_v0->unk4472 = arg1;
        temp_v0->unk447C = 0.0f;
        temp_v0->unk4480 = 0.0f;
    }
}

void func_80193774(void) {
    D_80200C70.unk7978 = 0;
    D_80200C70.unk7979 = 0;
    D_80200C70.unk797A = 0;
    D_80200C70.unk798C = &D_80208604;
    D_80200C70.unk7990 = &D_8020861C;
    D_80200C70.unk7988 = &D_80208634;
    osCreateMesgQueue(&D_80208604, &D_8020864C, 1);
    osCreateMesgQueue(D_80200C70.unk7990, &D_80208654, 4);
    osCreateMesgQueue(D_80200C70.unk7988, &D_80208650, 1);
}

void func_8019380C(s32 *arg0, s32 *arg1) {
    s32 temp_v1;
    u8 temp_t1;
    void *temp_v0;

    temp_v0 = &D_80200C70 + (D_80200C70.unk7978 * 8);
    temp_v0->unk79F4 = arg0;
    (temp_v0 + 0x79F4)->unk4 = (s32) *arg1;
    temp_t1 = D_80200C70.unk7978 + 1;
    temp_v1 = temp_t1 & 0xFF;
    D_80200C70.unk7978 = temp_t1;
    if (D_80200C70.unk7979 == temp_v1) {
        D_80200C70.unk7978 = (u8) (temp_v1 - 1);
    }
}

void func_80193858(s32 arg1) {
    func_8019380C(&arg1);
}

void func_8019387C(s32 arg1) {
    func_8019380C(&arg1);
}

void func_801938A0(s32 arg1) {
    s32 sp1C;

    sp1C = arg1 << 0x18;
    func_8019380C(&sp1C, (s32 *) arg1);
}

void func_801938D0(s32 arg1) {
    s32 sp1C;

    sp1C = arg1 << 0x10;
    func_8019380C(&sp1C, (s32 *) arg1);
}

s32 func_80193900(void) {
    s32 temp_a0;
    u8 temp_a3;
    u8 temp_v0;

    temp_v0 = D_80200C70.unk7978;
    temp_a3 = D_80200C70.unk7979;
    temp_a0 = ((temp_v0 - temp_a3) + 0x100) & 0xFF;
    if (D_801D5FF4 < temp_a0) {
        D_801D5FF4 = temp_a0;
    }
    if (osSendMesg(D_80200C70.unk7990, (void *) (((temp_a3 & 0xFF) << 8) | (temp_v0 & 0xFF)), 0) != -1) {
        D_80200C70.unk7979 = (u8) D_80200C70.unk7978;
        return 0;
    }
    return -1;
}

void func_80193990(void) {
    D_80200C70.unk797A = 0;
    D_80200C70.unk7979 = (u8) D_80200C70.unk7978;
}

void func_801939A8(u8 *arg0) {
    s32 temp_s0;
    u8 temp_a0;
    u8 temp_v0;
    u8 temp_v0_2;
    void *temp_s4;
    s32 phi_v0;
    s32 phi_s0;

    temp_v0 = arg0->unk0;
    if ((temp_v0 & 0xF0) >= 0xE0) {
        func_8019319C(&D_80200C70);
        return;
    }
    temp_a0 = arg0->unk1;
    if ((s32) temp_a0 < (s32) D_80200C70.unk2880) {
        temp_s4 = &D_80200C70 + (temp_a0 * 0x160) + 0x4460;
        if ((temp_v0 & 0x80) != 0) {
            func_8019319C(arg0, &D_80200C70);
            return;
        }
        if ((temp_v0 & 0x40) != 0) {
            func_80193EA8(temp_s4, arg0);
            return;
        }
        temp_v0_2 = arg0->unk2;
        if ((s32) temp_v0_2 < 0x10) {
            func_80194080((temp_s4 + (temp_v0_2 * 4))->unk38, arg0);
            return;
        }
        if (temp_v0_2 == 0xFF) {
            phi_v0 = (s32) (&D_80200C70 + (temp_a0 * 2))->unk797C;
            phi_s0 = 0;
            do {
                if ((phi_v0 & 1) != 0) {
                    func_80194080((temp_s4 + (phi_s0 * 4))->unk38, arg0);
                }
                temp_s0 = phi_s0 + 1;
                phi_v0 = (phi_v0 >> 1) & 0xFFFF;
                phi_s0 = temp_s0;
            } while (temp_s0 != 0x10);
        }
        // Duplicate return node #14. Try simplifying control flow for better match
    }
}

void func_80193AEC(u32 arg0) {
    u8 *temp_s0_2;
    u8 temp_v1;
    void *temp_s0;

    if (D_80200C70.unk797A == 0) {
        D_801D5FF8 = (u8) (arg0 >> 8);
    }
loop_3:
    temp_v1 = D_801D5FF8;
    if ((arg0 & 0xFF) == temp_v1) {
        D_80200C70.unk797A = 0U;
        return;
    }
    temp_s0 = &D_80200C70 + ((temp_v1 & 0xFF) * 8);
    D_801D5FF8 = temp_v1 + 1;
    temp_s0_2 = temp_s0 + 0x79F4;
    if (temp_s0->unk79F4 == 0xF8) {
        D_80200C70.unk797A = 1U;
        return;
    }
    func_801939A8(temp_s0_2);
    *temp_s0_2 = 0;
    goto loop_3;
}

u32 func_80193BA0(s32 *arg0) {
    void *sp1C;

    if (osRecvMesg(&D_80202AB0, &sp1C, 0) == -1) {
        *arg0 = 0;
        return 0U;
    }
    *arg0 = (s32) sp1C & 0xFFFFFF;
    return (u32) sp1C >> 0x18;
}

void func_80193C04(void) {
    func_8018F8C4();
}

void func_80193C24(s32 arg0, s32 *arg1, s32 *arg2) {
    s32 temp_v0;

    temp_v0 = arg0 * 0x14;
    *arg1 = (s32) (D_80200C70.unk2868 + temp_v0)->unk2;
    *arg2 = (s32) (D_80200C70.unk2868 + temp_v0)->unk3;
}

? func_80193C5C(void) {
    void *sp18;
    ? phi_v0;

    if (osRecvMesg(D_802085F8, &sp18, 0) == -1) {
        return 0;
    }
    phi_v0 = 1;
    if (sp18 != D_802050B9) {
        phi_v0 = -1;
    }
    return phi_v0;
}

void func_80193CB4(void) {
    void *sp28;

    do {

    } while (osRecvMesg(D_80200C70.unk7988, &sp28, 0) != -1);
}

s32 func_80193D08(s32 arg0) {
    s32 sp24;
    void *sp20;
    u8 temp_v0;

    func_80193CB4();
    temp_v0 = D_80200C70.unk4448;
    if (temp_v0 != 0) {
        sp24 = (s32) temp_v0;
        func_80193990();
        if (arg0 == D_80200C70.unk4449) {
            return -2;
        }
        if ((s32) temp_v0 >= 3) {
            D_80200C70.unk4449 = (u8) arg0;
            return -3;
        }
        osRecvMesg(D_80200C70.unk7988, &sp20, 1);
        goto block_6;
    }
block_6:
    func_80193CB4();
    func_8019387C(0xF9000000, arg0);
    return func_80193900();
}

void func_80193DA4(void) {
    D_80200C70.unk29A4 = 1;
    if (D_801D5FE8 != 0) {
        func_80193D08(0);
        D_80200C70.unk4448 = 0;
    }
}

s8 func_80193DF0(s32 arg0, s32 arg1, s32 arg2) {
    void *temp_v1;

    temp_v1 = (arg0 * 0x160) + &D_80200C70;
    if (((u32) temp_v1->unk4460 >> 0x1F) != 0) {
        return ((temp_v1 + (arg1 * 4))->unk4498 + arg2)->unkC8;
    }
    return -1;
}

s8 func_80193E44(s32 arg0, s32 arg1) {
    return *(&D_80205228 + ((arg0 * 0x160) + arg1));
}

void func_80193E6C(s32 arg0, ? arg1) {
    func_8018B740(&D_80203640, arg0, arg1);
}

void func_80193E9C(void) {
    D_80203640 = 0;
}

void func_80193EA8(void *arg0, u8 *arg1) {
    f32 temp_f0;
    f32 temp_f2;
    f32 temp_t1;
    f32 temp_t3;
    f32 temp_v0;
    f32 temp_v0_2;
    u8 temp_t6;
    f32 phi_f0;

    temp_t6 = arg1->unk0;
    switch (temp_t6) {
    case 65:
        temp_f0 = arg1->unk4;
        if (temp_f0 != arg0->unk2C) {
            arg0->unk2C = temp_f0;
            arg0->unk0 = (u8) (arg0->unk0 | 4);
            return;
        }
    default:
        return;
    case 71:
        temp_t1 = arg1->unk4;
        arg0->unk8 = (s16) ((((bitwise s32) temp_t1 * 4) - (bitwise s32) temp_t1) * 0x10);
        return;
    case 73:
        temp_t3 = arg1->unk4;
        arg0->unkC = (s16) ((((bitwise s32) temp_t3 * 4) - (bitwise s32) temp_t3) * 0x10);
        return;
    case 78:
        arg0->unkC = (bitwise s16) arg1->unk4;
        return;
    case 72:
        arg0->unkE = (s16) (bitwise s8) arg1->unk4;
        return;
    case 70:
        (arg0 + arg1->unk3)->unk158 = (bitwise s8) arg1->unk4;
        return;
    case 74:
        phi_f0 = (f32) arg1->unk2 / 127.0f;
block_11:
        if (arg0->unk1 != 2) {
            temp_f2 = arg0->unk1C;
            arg0->unk24 = temp_f2;
            temp_v0 = arg1->unk4;
            if ((bitwise s32) temp_v0 == 0) {
                arg0->unk1C = phi_f0;
                return;
            }
            arg0->unk1 = 0U;
            arg0->unk12 = (bitwise s16) temp_v0;
            arg0->unk20 = (f32) ((phi_f0 - temp_f2) / (f32) temp_v0);
            return;
        }
        // Duplicate return node #22. Try simplifying control flow for better match
        return;
    case 75:
        phi_f0 = ((f32) arg1->unk2 / 100.0f) * arg0->unk1C;
        goto block_11;
    case 76:
        if (arg0->unk1 != 2) {
            temp_v0_2 = arg1->unk4;
            if ((bitwise s32) temp_v0_2 == 0) {
                arg0->unk1C = (f32) arg0->unk24;
                return;
            }
            arg0->unk1 = 0U;
            arg0->unk12 = (bitwise s16) temp_v0_2;
            arg0->unk20 = (f32) ((arg0->unk24 - arg0->unk1C) / (f32) temp_v0_2);
            return;
        }
        // Duplicate return node #22. Try simplifying control flow for better match
        return;
    case 77:
        arg0->unk34 = (f32) arg1->unk4;
        if (arg0->unk34 == 1.0f) {
            arg0->unk0 = (u8) (arg0->unk0 & 0xFFFE);
            return;
        }
        arg0->unk0 = (u8) (arg0->unk0 | 1);
        // Duplicate return node #22. Try simplifying control flow for better match
        return;
    }
}

void func_80194080(void *arg0, u8 *arg1) {
    f32 temp_a3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_v0_6;
    s8 temp_v0;
    s8 temp_v0_2;
    s8 temp_v0_3;
    s8 temp_v0_4;
    u8 temp_t6;
    u8 temp_v0_5;
    u8 temp_v1;

    temp_t6 = arg1->unk0;
    switch (temp_t6) {
    case 1:
        temp_f0 = arg1->unk4;
        if (temp_f0 != arg0->unk2C) {
            arg0->unk2C = temp_f0;
            arg0->unk1 = (u8) (arg0->unk1 | 0x40);
            return;
        }
    default:
        return;
    case 2:
        temp_f0_2 = arg1->unk4;
        if (temp_f0_2 != arg0->unk30) {
            arg0->unk30 = temp_f0_2;
            arg0->unk1 = (u8) (arg0->unk1 | 0x40);
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 3:
        temp_v0 = (bitwise s8) arg1->unk4;
        if (temp_v0 != arg0->unkA) {
            arg0->unkA = (u8) temp_v0;
            arg0->unk1 = (u8) (arg0->unk1 | 0x20);
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 7:
        temp_v0_2 = (bitwise s8) arg1->unk4;
        if (temp_v0_2 != arg0->unkA) {
            arg0->unkB = temp_v0_2;
            arg0->unk1 = (u8) (arg0->unk1 | 0x20);
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 4:
        temp_f0_3 = arg1->unk4;
        if (temp_f0_3 != arg0->unk3C) {
            arg0->unk3C = temp_f0_3;
            arg0->unk1 = (u8) (arg0->unk1 | 0x80);
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 5:
        temp_v0_3 = (bitwise s8) arg1->unk4;
        if (temp_v0_3 != arg0->unk4) {
            arg0->unk4 = (u8) temp_v0_3;
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 17:
        temp_v0_4 = (bitwise s8) arg1->unk4;
        if (temp_v0_4 != arg0->unk8) {
            arg0->unk8 = (u8) temp_v0_4;
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 18:
        arg0->unk10 = (bitwise s8) arg1->unk4;
        return;
    case 6:
        temp_v0_5 = arg1->unk3;
        if ((s32) temp_v0_5 < 8) {
            (arg0 + temp_v0_5)->unkC8 = (bitwise s8) arg1->unk4;
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 8:
        arg0->unk0 = (u8) ((((bitwise s8) arg1->unk4 * 0x10) & 0x10) | (arg0->unk0 & 0xFFEF));
        return;
    case 9:
        arg0->unk3 = (bitwise s8) arg1->unk4;
        return;
    case 10:
        arg0->unk1C = 1;
        arg0->unk18 = (s16) ((bitwise u8) arg1->unk4 * 8);
        return;
    case 11:
        arg0->unk1A = 1;
        arg0->unk16 = (s16) ((bitwise u8) arg1->unk4 << 5);
        return;
    case 12:
        arg0->unkF = (bitwise u8) arg1->unk4;
        return;
    case 13:
        arg0->unk22 = (bitwise u16) arg1->unk4;
        return;
    case 14:
        arg0->unkD8 = (bitwise u8) arg1->unk4;
        return;
    case 15:
        arg0->unkDC = (f32) arg1->unk4;
        return;
    case 16:
        arg0->unkD0 = (f32) arg1->unk4;
        return;
    case 19:
        temp_v0_6 = arg1->unk4;
        temp_v1 = arg1->unk3;
        if ((bitwise s32) temp_v0_6 != 0) {
            arg0->unkD4 = temp_v0_6;
        }
        temp_a3 = arg0->unkD4;
        if ((bitwise s32) temp_a3 != 0) {
            func_8018C994(temp_a3, (s32) temp_v1 >> 4, temp_v1 & 0xF, temp_a3);
            return;
        }
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    case 20:
        arg0->unkC = (bitwise u8) arg1->unk4;
        // Duplicate return node #33. Try simplifying control flow for better match
        return;
    }
}

void func_801942BC(s32 arg0, s32 arg1, s32 arg2) {
    func_8019387C(((arg0 & 0xFF) << 0x10) | 0xFA000000 | ((arg1 & 0xFF) << 8) | (arg2 & 0xFF), 1);
}

void func_80194304(void) {
    func_8019387C(0xFA000000, 0);
}

void func_80194328(s32 arg0, s32 arg1) {
    func_8019387C((arg1 & 0xFF) | 0xFD000000, arg0, arg1);
}

void func_8019435C(void) {
    osRecvMesg(D_802085FC, NULL, 0);
    osRecvMesg(D_802085FC, NULL, 1);
}

s32 func_8019439C(void) {
    s32 sp28;
    s32 sp24;

    if (func_8019440C(&sp28, &sp24) == 0) {
        return 0;
    }
    return sp24;
}

s32 func_801943D0(void) {
    s32 sp28;
    s32 sp24;

    if (func_8019440C(&sp28, &sp24) == 0) {
        return 0;
    }
    return sp28 - sp24;
}

s32 func_8019440C(s32 arg0, s32 arg1, s32 arg2, s32 *arg3, s32 *arg4) {
    u32 *temp_v1;
    u32 temp_v1_2;
    void **temp_a0_2;
    void *temp_a0;
    void *temp_v0;
    void *temp_v0_2;

    temp_v0 = (arg0 * 0x160) + &D_80200C70;
    if ((((u32) temp_v0->unk4460 >> 0x1F) != 0) && (temp_v1 = (temp_v0 + (arg1 * 4))->unk4498, (((u32) *temp_v1 >> 0x1F) != 0))) {
        temp_v0_2 = (temp_v1 + (arg2 * 4))->unk54;
        if (temp_v0_2 == 0) {
            return 0;
        }
        temp_v1_2 = temp_v0_2->unk0;
        if ((temp_v1_2 >> 0x1F) != 0) {
            temp_a0 = temp_v0_2->unk3C;
            if (temp_a0 == 0) {
                return 0;
            }
            if ((temp_v1_2 * 0x10) >= 0) {
                return 0;
            }
            if (temp_v0_2 == temp_a0->unk48) {
                if (((u32) (temp_a0->unkD8 << 0xD) >> 0x1F) == 1) {
                    return 0;
                }
                temp_a0_2 = temp_a0->unkE8;
                if (temp_a0_2 == 0) {
                    return 0;
                }
                *arg3 = (*temp_a0_2)->unk8->unk4;
                *arg4 = temp_a0->unk1C;
                return 1;
            }
            return 0;
        }
        // Duplicate return node #16. Try simplifying control flow for better match
        return 0;
    }
    return 0;
}

void func_80194528(void) {
    func_80194568(NULL);
}

void func_80194548(void) {
    func_80194568((? (*)(s32, s32, s32, s32))2);
}

s32 func_80194568(s32 arg0) {
    s32 **temp_t0;
    s32 temp_a0;
    s32 temp_a1;
    u8 temp_t1;
    void *temp_a2;
    void *temp_a3;
    void *temp_v0;
    s32 phi_a0;
    s32 phi_v0;
    s32 phi_v1;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_v1_2;
    s32 phi_v1_3;

    temp_a1 = D_80200C70.unk28B8;
    phi_v1 = 0;
    phi_a1 = temp_a1;
    phi_v1_3 = 0;
    if (temp_a1 > 0) {
        phi_a0 = 0;
        do {
            temp_v0 = phi_a0 + D_80200C70.unk445C;
            temp_a0 = phi_a0 + 0xF8;
            temp_a2 = temp_v0 + 0x34;
            phi_a0 = temp_a0;
            phi_a1_2 = phi_a1;
            phi_v1_2 = phi_v1_3;
            phi_v1_2 = phi_v1_3;
            if ((((u32) temp_v0->unkD8 >> 0x1F) != 0) && (temp_t1 = temp_a2->unk34, ((temp_t1 & 0xF) != 0))) {
                temp_a3 = temp_v0 + 0xD8;
                if (arg0 >= 2) {
                    temp_t0 = temp_a3->unk10;
                    phi_v0 = phi_a1 * 0x1F;
                    if ((temp_t0 == 0) || (temp_a3->unk0 & 0x40000)) {

                    } else {
                        phi_v0 = phi_a1 * 0x1F;
                        if (((u32) (**temp_t0 * 0x10) >> 0x1E) == 0) {

                        } else {
                            goto block_10;
                        }
                    }
                } else {
block_10:
                    phi_v1_2 = phi_v1_3 + 1;
                    if ((arg0 & 1) == 1) {
                        temp_a2->unk34 = (u8) (temp_t1 | 0x10);
                        temp_a2->unk40 = (f32) D_80200C70.unk2888;
                        phi_a1_2 = D_80200C70.unk28B8;
                    }
                    goto block_12;
                }
            } else {
block_12:
                phi_v0 = phi_a1_2 * 0x1F;
                phi_a1 = phi_a1_2;
            }
            phi_v1 = phi_v1_2;
            phi_v1_3 = phi_v1_2;
        } while (temp_a0 < (phi_v0 * 8));
    }
    return phi_v1;
}

void *func_80194668(void) {
    s32 temp_lo;
    void *temp_v0;
    void *temp_v1;

    temp_v0 = osGetCount();
    temp_lo = (D_80200C70.unk28C0 + D_801D5FFC + temp_v0) * (D_80200C70.unk299C + 0x1234567);
    D_801D6000 = temp_v0;
    temp_v1 = (temp_lo & 1) + (temp_lo * 2) + D_801D6000;
    D_801D5FFC = temp_v1;
    return temp_v1;
}

void func_801946E4(void) {
    func_80193774();
}

