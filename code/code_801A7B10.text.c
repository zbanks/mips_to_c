CRASHED

struct _mips2c_stack_func_801A7D04 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801A7D84 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ u8 *sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x4];
    /* 0x34 */ s32 sp34;                            /* inferred */
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ s32 sp3C;                            /* inferred */
    /* 0x40 */ void *sp40;                          /* inferred */
    /* 0x44 */ u32 sp44;                            /* inferred */
    /* 0x48 */ char pad_48[0x4];
    /* 0x4C */ ? sp4C;                              /* inferred */
    /* 0x4C */ char pad_4C[0x15];
    /* 0x61 */ u8 sp61;                             /* inferred */
    /* 0x62 */ char pad_62[0xE];
};                                                  /* size = 0x70 */

struct _mips2c_stack_func_801A89A8 {};              /* size 0x0 */

struct _mips2c_stack_func_801A89D0 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_801A8A50 {};              /* size 0x0 */

struct _mips2c_stack_func_801A8ABC {};              /* size 0x0 */

struct _mips2c_stack_func_801A8B14 {};              /* size 0x0 */

struct _mips2c_stack_func_801A8B2C {};              /* size 0x0 */

struct _mips2c_stack_func_801A8BD0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801A8D5C {
    /* 0x00 */ char pad_0[0x70];
    /* 0x70 */ ? sp70;                              /* inferred */
    /* 0x70 */ char pad_70[0x20];
};                                                  /* size = 0x90 */

struct _mips2c_stack_func_801A9768 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_801A982C {
    /* 0x00 */ char pad_0[0x37];
    /* 0x37 */ u8 sp37;                             /* inferred */
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_801A99B8 {};              /* size 0x0 */

struct _mips2c_stack_func_801A9A74 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_801A9B10 {};              /* size 0x0 */

struct _mips2c_stack_func_801A9B78 {
    /* 0x0 */ char pad_0[0x4];
    /* 0x4 */ s32 sp4;                              /* inferred */
};                                                  /* size = 0x8 */

struct _mips2c_stack_func_801A9C68 {
    /* 0x0 */ char pad_0[0x4];
    /* 0x4 */ s32 sp4;                              /* inferred */
};                                                  /* size = 0x8 */

struct _mips2c_stack_func_801A9D10 {
    /* 0x00 */ char pad_0[0x1E];
    /* 0x1E */ s16 sp1E;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_801A9DCC {
    /* 0x00 */ char pad_0[0x40];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_801A9EA4 {
    /* 0x00 */ char pad_0[0x8];
    /* 0x08 */ s32 sp8;                             /* inferred */
    /* 0x0C */ s32 spC;                             /* inferred */
};                                                  /* size = 0x10 */

struct _mips2c_stack_func_801A9F4C {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ s16 sp2C;                            /* inferred */
    /* 0x2E */ char pad_2E[0x1];
    /* 0x2F */ u8 sp2F;                             /* inferred */
};                                                  /* size = 0x30 */

? func_80193858(s32, f32, s32);                     /* extern */
? func_8019387C(s32, s32, s32);                     /* extern */
? func_801938A0(s32, s8, s32);                      /* extern */
? func_801938D0(s32, s32, s32);                     /* extern */
? func_80193900();                                  /* extern */
s32 func_80193BA0(? *);                             /* extern */
u8 *func_80193C04(u32, ? *, s32, u32);              /* extern */
s32 func_80193C5C();                                /* extern */
? func_80193D08(u8, s32);                           /* extern */
? func_801A4D50();                                  /* extern */
? func_801A4DA4();                                  /* extern */
? func_801A4DF4(u8);                                /* extern */
? func_801A7B10(u8, u8, s32, u32);                  /* static */
void func_801A7D04(u8 arg0, s32 arg1, void *, u32); /* static */
void func_801A7D84(u32 arg0, s32, s8);              /* static */
void func_801A89D0();                               /* static */
s32 func_801A8ABC(s32 arg0, s32 arg1);              /* static */
void func_801A8B14(s32 arg0);                       /* static */
void func_801A8B2C(s32 arg0, s32 arg1);             /* static */
void func_801A8BD0(u8 arg0, s32 arg1, s32 arg2, s32 arg3); /* static */
void func_801A8D5C();                               /* static */
u8 func_801A9768();                                 /* static */
u8 func_801A982C();                                 /* static */
void func_801A99B8(s8, void *, s32, ? *);           /* static */
void func_801A9A74();                               /* static */
void func_801A9B10(s32 arg1, s32 arg2);             /* static */
s16 func_801A9B78(void *arg0, void *arg1);          /* static */
s32 func_801A9BFC(void *, s32);                     /* static */
s8 func_801A9C68(void *arg0, s32 arg1, s32 arg2);   /* static */
s16 func_801A9D10(void *arg0, s32 arg1, void *arg2, s32 arg3, u8 arg4); /* static */
? func_801A9DCC(u8 *arg0, s32 arg1, void *arg2, s32 arg3, u8 arg4); /* static */
void func_801A9EA4(void *arg0, s32 arg1, void *arg2, s32 arg3, s16 arg4, u8 arg5); /* static */
? func_801A9F4C(u8 *arg0, s32 arg1, void *arg2, s32 arg3); /* static */
static s8 D_801DB49C = 0;
static u8 D_801DB4C0 = 0;
static u8 D_801DB4C4 = 0;
static u8 D_801DB4C8 = 0;
static ? D_801DB4CC;                                /* unable to generate initializer */
static u8 D_801DB4D4 = 0;
static u8 D_801DB4D8 = 0;
static u32 D_801DB4DC = 0;
static void D_801DB4E0;                             /* unable to generate initializer */
static ? D_801FFD00;
static ? D_801FFD34;
static ? D_801FFD40;
static ? D_80200140;
static ? D_8020034A;
static u8 D_80200BCC;
static u16 D_80200BCE;
static u16 D_80200BD0[80];
static ? D_80200C70;
static u16 D_802034E8;
static ? D_802050D0;
void *D_801DB930 = &D_801DB4E0;

/*
Failed to decompile function func_801A7B10:

Label L801A7B48 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/

void func_801A7D04(u8 arg0, s32 arg1) {
    s32 temp_a2;

    temp_a2 = arg1 & 0xFFFF;
    func_8019387C((arg0 << 0x10) | 0x83000000, (s32) (temp_a2 * D_802034E8) / 4, temp_a2);
    *(&D_8020034A + (arg0 * 0x21C)) = 0xFFFF;
}

void func_801A7D84(u32 arg0, void *arg2) {
    u8 sp61;
    ? sp4C;
    u32 sp44;
    void *sp40;
    s32 sp3C;
    s32 sp38;
    s32 sp34;
    u8 *sp2C;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f10;
    f32 temp_f2;
    f32 temp_f6;
    f32 temp_f8;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_a1_4;
    s32 temp_a2;
    s32 temp_a2_5;
    s32 temp_a3_2;
    s32 temp_a3_3;
    s32 temp_a3_5;
    s32 temp_a3_6;
    s32 temp_a3_7;
    s32 temp_lo;
    s32 temp_t1;
    s32 temp_t1_2;
    s32 temp_t1_3;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t8;
    s32 temp_v0_11;
    s32 temp_v0_12;
    s32 temp_v0_13;
    s32 temp_v0_15;
    s32 temp_v1_11;
    s32 temp_v1_12;
    s32 temp_v1_13;
    s32 temp_v1_15;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_7;
    s32 temp_v1_8;
    s32 temp_v1_9;
    u32 temp_a3;
    u32 temp_a3_4;
    u32 temp_t0;
    u32 temp_t0_2;
    u32 temp_t7;
    u32 temp_v0_3;
    u32 temp_v0_4;
    u32 temp_v0_6;
    u32 temp_v0_8;
    u8 *temp_s0;
    u8 *temp_t4;
    u8 *temp_t4_2;
    u8 temp_a0_4;
    u8 temp_t2;
    u8 temp_t2_2;
    u8 temp_t9;
    u8 temp_v0_14;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_a1_2;
    void *temp_a1_3;
    void *temp_a2_2;
    void *temp_a2_3;
    void *temp_a2_4;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_2;
    void *temp_v0_5;
    void *temp_v0_7;
    void *temp_v0_9;
    void *temp_v1;
    void *temp_v1_10;
    void *temp_v1_14;
    void *temp_v1_16;
    void *temp_v1_17;
    s32 phi_v1;
    s32 phi_v1_2;
    s32 phi_v1_3;
    s32 phi_t1;
    u8 phi_t3;
    s32 phi_v0;
    s32 phi_v1_4;
    s32 phi_v1_5;
    s32 phi_v1_6;
    s32 phi_t1_2;
    s32 phi_v0_2;
    s32 phi_v1_7;
    void *phi_a2;
    s32 phi_a1;
    f32 phi_f8;
    s32 phi_v1_8;
    u32 phi_a1_2;
    s32 phi_a1_3;
    f32 phi_f10;
    s32 phi_a1_4;
    f32 phi_f6;
    s32 phi_v1_9;
    s32 phi_t1_3;
    s32 phi_t1_4;
    void *phi_a2_2;

    temp_t0 = arg0 & 0x7000000;
    temp_t7 = (arg0 >> 0x1C) & 0xFF;
    temp_t0_2 = temp_t0 >> 0x18;
    temp_a1 = temp_t0_2 & 0xFF;
    phi_a2_2 = arg2;
    switch (temp_t7) {
    case 0:
        temp_t8 = temp_t0_2 & 0xFF;
        temp_v1 = &D_80200140 + (temp_t8 * 0x21C);
        sp34 = temp_t8;
        if ((temp_v1->unk_210 == 0) && (temp_a2 = ((u32) (arg0 & 0xFF00) >> 8) & 0xFF, (D_801DB4C8 == 0))) {
            if (temp_a2 < 0x80) {
                func_801A7B10(unksp37, arg0 & 0xFF, temp_a2, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
                return;
            }
            temp_a3 = arg0 & 0xFF;
            temp_v1->unk_1FC = (s32) ((arg0 & 0xF7FF7FFF) + 0x8000000);
            temp_v1->unk_210 = 1U;
            sp44 = temp_a3;
            sp40 = temp_v1;
            temp_v1->unk_211 = (u8) *func_80193C04(temp_a3, &sp4C, temp_a2, temp_a3);
            func_801A7D04(unksp37, 1);
            if (temp_v1->unk_20C != 0xFFFF) {
                sp40 = temp_v1;
                sp44 = temp_a3;
                temp_s0 = func_80193C04(temp_a3, &sp4C);
                if (*temp_s0 != *func_80193C04(temp_v1->unk_20C & 0xFF, &sp4C)) {
                    sp44 = temp_a3;
                    func_8019387C(((temp_a3 & 0xFF) << 8) | 0xF6000000, 0);
                }
            }
            func_801938A0((*func_80193C04(arg0 & 0xFF, &sp4C) << 0x10) | 0xF5000000 | 0x1400 | ((sp34 + 1) & 0xFF), 0);
            return;
        }
    default:
        return;
    case 1:
        func_801A7D04(temp_t0_2 & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
        return;
    case 2:
        temp_t6 = temp_t0_2 & 0xFF;
        temp_t4 = &D_801FFD34 + temp_t6;
        temp_t2 = *temp_t4;
        sp34 = temp_t6;
        phi_v1 = 0;
        phi_t3 = temp_t2;
        if ((s32) temp_t2 > 0) {
            temp_a3_2 = arg0 & 0xFF;
            sp38 = temp_a3_2;
loop_13:
            if (temp_a3_2 == *((temp_t6 * 0xA) + &D_801FFD00 + (phi_v1 * 2))) {
                if (phi_v1 == 0) {
                    func_801A7B10(unksp37, unksp3B, ((u32) (arg0 & 0xFF00) >> 8) & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
                    return;
                }
                /* Duplicate return node #88. Try simplifying control flow for better match */
                return;
            }
            temp_v1_2 = (phi_v1 + 1) & 0xFF;
            phi_v1 = temp_v1_2;
            if (temp_v1_2 >= (s32) *(&D_801FFD34 + temp_a1)) {
                goto block_18;
            }
            goto loop_13;
        }
block_18:
        temp_t1 = temp_t2 & 0xFF;
        sp38 = arg0 & 0xFF;
        temp_a2_2 = (sp34 * 0xA) + &D_801FFD00;
        phi_v1_2 = 0;
        phi_t1 = temp_t1;
        phi_t1_3 = temp_t1;
        if ((s32) temp_t2 > 0) {
            do {
                phi_v1_3 = phi_v1_2;
                if ((((u32) (arg0 & 0xFF00) >> 8) & 0xFF) >= (s32) (temp_a2_2 + (phi_v1_2 * 2))->unk_1) {
                    phi_v1_3 = temp_t2 & 0xFF;
                    phi_t1_3 = phi_v1_2 & 0xFF;
                }
                temp_v1_3 = (phi_v1_3 + 1) & 0xFF;
                phi_v1_2 = temp_v1_3;
                phi_t1 = phi_t1_3;
            } while (temp_v1_3 < (s32) *(&D_801FFD34 + temp_a1));
        }
        sp44 = ((u32) (arg0 & 0xFF00) >> 8) & 0xFF;
        if ((s32) temp_t2 < 5) {
            temp_t9 = temp_t2 + 1;
            *temp_t4 = temp_t9;
            phi_t3 = temp_t9 & 0xFF;
        }
        temp_v1_4 = (phi_t3 - 1) & 0xFF;
        phi_v0 = temp_v1_4;
        phi_v1_4 = temp_v1_4;
        if (phi_t1 != temp_v1_4) {
            do {
                temp_a1_2 = temp_a2_2 + (phi_v0 * 2);
                temp_a0 = temp_a2_2 + (phi_v1_4 * 2);
                temp_a0->unk_1 = (u8) temp_a1_2->unk_-1;
                temp_v1_5 = (phi_v1_4 - 1) & 0xFF;
                temp_a0->unk_0 = (u8) temp_a1_2->unk_-2;
                phi_v0 = temp_v1_5;
                phi_v1_4 = temp_v1_5;
            } while (phi_t1 != temp_v1_5);
        }
        temp_v0 = temp_a2_2 + (phi_t1 * 2);
        temp_v0->unk_1 = (s8) sp44;
        temp_v0->unk_0 = (s8) sp38;
        if (phi_t1 == 0) {
            func_801A7B10(unksp37, unksp3B, (s32) unksp47, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 3:
        temp_t6_2 = temp_t0_2 & 0xFF;
        temp_t4_2 = &D_801FFD34 + temp_t6_2;
        temp_t2_2 = *temp_t4_2;
        sp34 = temp_t6_2;
        phi_v1_5 = 0;
        phi_t1_2 = (s32) temp_t2_2;
        phi_t1_4 = (s32) temp_t2_2;
        if ((s32) temp_t2_2 > 0) {
            temp_a2_3 = (temp_t6_2 * 0xA) + &D_801FFD00;
            phi_a2_2 = temp_a2_3;
            do {
                phi_v1_6 = phi_v1_5;
                if ((arg0 & 0xFF) == *(temp_a2_3 + (phi_v1_5 * 2))) {
                    phi_v1_6 = temp_t2_2 & 0xFF;
                    phi_t1_4 = phi_v1_5 & 0xFF;
                }
                temp_v1_6 = (phi_v1_6 + 1) & 0xFF;
                phi_v1_5 = temp_v1_6;
                phi_t1_2 = phi_t1_4;
            } while (temp_v1_6 < (s32) *(&D_801FFD34 + temp_a1));
        }
        phi_a2 = phi_a2_2;
        phi_a2 = phi_a2_2;
        if (phi_t1_2 != temp_t2_2) {
            temp_a3_3 = temp_t2_2 - 1;
            temp_v1_7 = phi_t1_2 & 0xFF;
            phi_v1_7 = temp_v1_7;
            if (phi_t1_2 < temp_a3_3) {
                temp_a2_4 = (sp34 * 0xA) + &D_801FFD00;
                phi_v0_2 = temp_v1_7;
                phi_a2 = temp_a2_4;
                do {
                    temp_a1_3 = temp_a2_4 + (phi_v0_2 * 2);
                    temp_a0_2 = temp_a2_4 + (phi_v1_7 * 2);
                    temp_a0_2->unk_1 = (u8) temp_a1_3->unk_3;
                    temp_v1_8 = (phi_v1_7 + 1) & 0xFF;
                    temp_a0_2->unk_0 = (u8) temp_a1_3->unk_2;
                    phi_v0_2 = temp_v1_8;
                    phi_v1_7 = temp_v1_8;
                } while (temp_v1_8 < temp_a3_3);
            }
            *temp_t4_2 = temp_t2_2 - 1;
        }
        if ((phi_t1_2 == 0) && (temp_a3_4 = ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF, sp44 = temp_a3_4, sp2C = temp_t4_2, func_801A7D04(unksp37, temp_a3_4 & 0xFFFF, phi_a2, temp_a3_4), (*temp_t4_2 != 0))) {
            temp_v0_2 = (sp34 * 0xA) + &D_801FFD00;
            func_801A7B10((u8) sp34, temp_v0_2->unk_0, (s32) temp_v0_2->unk_1, temp_a3_4);
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 4:
        temp_v0_3 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_9 = temp_v0_3 & 0xFF;
        phi_a1 = temp_v0_3 & 0xFF;
        if (temp_v1_9 == 0) {
            phi_a1 = (temp_v1_9 + 1) & 0xFF;
        }
        temp_v1_10 = &D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C);
        temp_f2 = temp_v1_10->unk_1C0;
        temp_f0 = (f32) (arg0 & 0xFF) / 127.0f;
        temp_v1_10->unk_1C4 = temp_f0;
        if (temp_f2 != temp_f0) {
            temp_f8 = (f32) phi_a1;
            phi_f8 = temp_f8;
            if (phi_a1 < 0) {
                phi_f8 = temp_f8 + 4294967296.0f;
            }
            temp_v1_10->unk_200 = (s16) phi_a1;
            temp_v1_10->unk_1C8 = (f32) ((temp_f2 - temp_v1_10->unk_1C4) / phi_f8);
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 5:
        temp_v0_4 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_11 = temp_v0_4 & 0xFF;
        phi_a1_2 = temp_v0_4 & 0xFF;
        if (temp_v1_11 == 0) {
            phi_a1_2 = (temp_v1_11 + 1) & 0xFF;
        }
        temp_a3_5 = temp_t0_2 & 0xFF;
        temp_f0_2 = (f32) (arg0 & 0xFFFF) / 1000.0f;
        phi_v1_8 = 0;
        do {
            temp_v1_12 = (phi_v1_8 + 1) & 0xFF;
            temp_v0_5 = (temp_a3_5 * 0x21C) + &D_80200140 + (phi_v1_8 * 0x1C);
            temp_v0_5->unk_10 = temp_f0_2;
            temp_v0_5->unk_1A = (s16) phi_a1_2;
            temp_v0_5->unk_14 = (f32) ((temp_v0_5->unk_C - temp_f0_2) / (f32) phi_a1_2);
            phi_v1_8 = temp_v1_12;
        } while (temp_v1_12 < 0x10);
        (&D_80200140 + (temp_a3_5 * 0x21C))->unk_206 = 0xFFFF;
        return;
    case 13:
        temp_v0_6 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_13 = temp_v0_6 & 0xFF;
        phi_a1_3 = temp_v0_6 & 0xFF;
        if (temp_v1_13 == 0) {
            phi_a1_3 = (temp_v1_13 + 1) & 0xFF;
        }
        temp_a0_3 = ((u32) (arg0 & 0xF000) >> 0xC) & 0xFF;
        temp_v1_14 = &D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C);
        temp_v0_7 = temp_v1_14 + (temp_a0_3 * 0x1C);
        temp_f0_3 = (f32) (arg0 & 0xFFF) / 1000.0f;
        temp_f10 = (f32) phi_a1_3;
        temp_v0_7->unk_10 = temp_f0_3;
        phi_f10 = temp_f10;
        if (phi_a1_3 < 0) {
            phi_f10 = temp_f10 + 4294967296.0f;
        }
        temp_v0_7->unk_1A = (s16) phi_a1_3;
        temp_v0_7->unk_14 = (f32) ((temp_v0_7->unk_C - temp_f0_3) / phi_f10);
        temp_v1_14->unk_206 = (u16) (temp_v1_14->unk_206 | (1 << temp_a0_3));
        return;
    case 6:
        temp_v0_8 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_15 = temp_v0_8 & 0xFF;
        phi_a1_4 = temp_v0_8 & 0xFF;
        if (temp_v1_15 == 0) {
            phi_a1_4 = (temp_v1_15 + 1) & 0xFF;
        }
        temp_a3_6 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        temp_lo = temp_a3_6 * 0x1C;
        temp_t1_2 = temp_t0_2 & 0xFF;
        temp_v0_9 = &D_80200140 + (temp_t1_2 * 0x21C) + temp_lo;
        temp_f0_4 = (f32) (arg0 & 0xFF) / 127.0f;
        temp_v0_9->unk_4 = temp_f0_4;
        if (temp_v0_9->unk_0 != temp_f0_4) {
            temp_v1_16 = &D_80200140 + (temp_t1_2 * 0x21C);
            temp_v0_10 = temp_v1_16 + temp_lo;
            temp_f6 = (f32) phi_a1_4;
            phi_f6 = temp_f6;
            if (phi_a1_4 < 0) {
                phi_f6 = temp_f6 + 4294967296.0f;
            }
            temp_v0_10->unk_18 = (s16) phi_a1_4;
            temp_v0_10->unk_8 = (f32) ((temp_v0_10->unk_0 - temp_v0_10->unk_4) / phi_f6);
            temp_v1_16->unk_208 = (u16) (temp_v1_16->unk_208 | (1 << temp_a3_6));
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 7:
        func_801938A0(((temp_t0_2 & 0xFF) << 0x10) | 0x46000000 | (((u32) (arg0 & 0xFF0000) >> 0x10) & 0xFF), (s8) arg0);
        return;
    case 8:
        temp_v0_11 = temp_t0_2 & 0xFF;
        temp_a3_7 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        if (((&D_80200140 + (temp_v0_11 * 0x21C))->unk_20E & (1 << temp_a3_7)) == 0) {
            func_801938A0(((temp_v0_11 & 0xFF) << 0x10) | 0x6000000 | ((temp_a3_7 & 0xFF) << 8) | (((u32) (arg0 & 0xFF0000) >> 0x10) & 0xFF), (s8) arg0, temp_a3_7);
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 9:
        (&D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C))->unk_20E = (s16) arg0;
        return;
    case 10:
        temp_a1_4 = arg0 & 0xFFFF;
        phi_v1_9 = temp_a1_4;
        if (temp_a1_4 != 0) {
            temp_v0_12 = (temp_t0_2 & 0xFF) << 0x10;
            sp38 = temp_v0_12;
            sp3C = temp_a1_4;
            sp44 = temp_t0_2;
            func_801938D0(temp_v0_12 | 0x90000000, temp_a1_4);
            func_801938A0(temp_v0_12 | 0x8000000 | 0xFF00, 1);
            phi_v1_9 = sp3C;
        }
        temp_a2_5 = phi_v1_9 ^ 0xFFFF;
        if (temp_a2_5 != 0) {
            temp_v0_13 = ((temp_t0 >> 0x18) & 0xFF) << 0x10;
            func_801938D0(temp_v0_13 | 0x90000000, temp_a2_5 & 0xFFFF, temp_a2_5);
            func_801938A0(temp_v0_13 | 0x8000000 | 0xFF00, 0);
            return;
        }
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    case 11:
        (&D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C))->unk_1CC = arg0;
        return;
    case 12:
        if ((((u32) (arg0 & 0xF00000) >> 0x14) & 0xFF) != 0xF) {
            temp_v1_17 = &D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C);
            temp_v0_14 = temp_v1_17->unk_219;
            temp_t1_3 = temp_v0_14 & 0xFF;
            if (((s32) temp_v0_14 < 7) && (temp_v1_17->unk_219 = (u8) (temp_v0_14 + 1), ((temp_t1_3 < 8) != 0))) {
                (temp_v1_17 + (temp_t1_3 * 4))->unk_1DC = arg0;
                temp_v1_17->unk_218 = 2;
                return;
            }
            /* Duplicate return node #88. Try simplifying control flow for better match */
            return;
        }
        (&D_80200140 + ((temp_t0_2 & 0xFF) * 0x21C))->unk_219 = 0;
        return;
    case 14:
        temp_v0_15 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        if (temp_v0_15 != 0) {
            if (temp_v0_15 != 1) {
                if (temp_v0_15 != 2) {
                    return;
                }
                D_801DB4C8 = (D_801DB4C8 & 0xFD) | ((arg0 & 1) * 2);
                return;
            }
            D_801DB4C8 = (D_801DB4C8 & 0xFE) | (arg0 & 1);
            return;
        }
        func_8019387C(0xF0000000, (s32) *(&D_801DB4CC + (arg0 & 0xFF)));
        return;
    case 15:
        if ((((u32) (arg0 & 0xFF0000) >> 0x10) & 0xFF) == 0) {
            D_801DB49C = (s8) ((u32) (arg0 & 0xFF00) >> 8);
            temp_a0_4 = arg0 & 0xFF;
            D_801DB4D4 = temp_a0_4;
            sp61 = D_801DB4D4;
            func_80193D08(temp_a0_4, temp_a1);
            func_801A4DF4(sp61);
            func_8019387C(0xF8000000, 0);
            return;
        }
        D_801DB4DC = arg0;
        D_80200BCE = 0x7FFF;
        D_80200BCC = 0x14;
        *D_80200BD0 = 0x666;
        /* Duplicate return node #88. Try simplifying control flow for better match */
        return;
    }
}

void func_801A89A8(s32 arg0) {
    u8 temp_v0;

    temp_v0 = D_801DB4C0;
    *(&D_801FFD40 + (temp_v0 * 4)) = arg0;
    D_801DB4C0 = temp_v0 + 1;
}

void func_801A89D0(void) {
    if (D_801DB4C4 != D_801DB4C0) {
        do {
            D_801DB4C4 += 1;
            func_801A7D84(*(&D_801FFD40 + (D_801DB4C4 * 4)));
        } while (D_801DB4C4 != D_801DB4C0);
    }
}

s32 func_801A8A50(s32 param1) {
    u16 temp_a0;
    void *temp_v1;

    temp_v1 = ((param1 & 0xFF) * 0x21C) + &D_80200140;
    if (temp_v1->unk_210 == 1) {
        return temp_v1->unk_1FC & 0xFF & 0xFFFF;
    }
    temp_a0 = temp_v1->unk_20A;
    if (temp_a0 != 0xFFFF) {
        return (s32) temp_a0;
    }
    return 0xFFFF;
}

s32 func_801A8ABC(s32 arg0, s32 arg1) {
    u8 temp_v0;
    u8 temp_v0_2;
    u8 temp_v1;
    u8 phi_v0;

    temp_v1 = D_801DB4C0;
    temp_v0 = D_801DB4C4;
    phi_v0 = temp_v0;
    if (temp_v1 != temp_v0) {
loop_1:
        temp_v0_2 = (phi_v0 + 1) & 0xFF;
        phi_v0 = temp_v0_2;
        if (arg0 == (*(&D_801FFD40 + (phi_v0 * 4)) & arg1)) {
            return 0;
        }
        if (temp_v1 == temp_v0_2) {
            /* Duplicate return node #4. Try simplifying control flow for better match */
            return 1;
        }
        goto loop_1;
    }
    return 1;
}

void func_801A8B14(s32 arg0) {
    *(&D_801FFD34 + (arg0 & 0xFF)) = 0;
}

void func_801A8B2C(s32 arg0, s32 arg1) {
    s32 temp_a0;
    s32 temp_v0;
    u8 temp_a2;
    void *temp_a3;
    void *temp_v1;
    s32 phi_v0;
    s32 phi_a2;

    temp_a0 = arg0 & 0xFF;
    temp_v1 = (temp_a0 * 0x21C) + &D_80200140;
    temp_a2 = temp_v1->unk_219;
    phi_v0 = 0;
    phi_a2 = (s32) temp_a2;
    if ((s32) temp_a2 > 0) {
        do {
            temp_a3 = (temp_a0 * 0x21C) + &D_80200140 + (phi_v0 * 4);
            temp_v0 = (phi_v0 + 1) & 0xFF;
            phi_v0 = temp_v0;
            if ((arg1 & 0xFF) == (((u32) (temp_a3->unk_1DC & 0xF00000) >> 0x14) & 0xFF)) {
                temp_a3->unk_1DC = 0xFF000000;
                phi_a2 = (s32) temp_v1->unk_219;
            }
        } while (temp_v0 < phi_a2);
    }
}

void func_801A8BD0(u8 arg0, s32 arg1, s32 arg2, s32 arg3) {
    f32 temp_f0;
    f32 temp_f6;
    s32 temp_a1;
    s32 temp_v0_2;
    s8 temp_a3;
    u8 temp_t6;
    void *temp_v0;
    void *temp_v1;
    s32 phi_v0;
    f32 phi_f0;
    f32 phi_f6;

    temp_a1 = arg1 & 0xFF;
    temp_v1 = &D_80200140 + (arg0 * 0x21C);
    temp_a3 = arg3 & 0xFF;
    (temp_v1 + temp_a1)->unk_212 = (s8) (arg2 & 0x7F);
    if (temp_a3 != 0) {
        temp_v0 = &D_80200140 + (arg0 * 0x21C);
        temp_v0->unk_217 = 1;
        temp_v0->unk_216 = temp_a3;
        return;
    }
    phi_v0 = 0;
    phi_f0 = 1.0f;
    do {
        temp_t6 = (temp_v1 + phi_v0)->unk_212;
        temp_f6 = (f32) temp_t6;
        phi_f6 = temp_f6;
        if ((s32) temp_t6 < 0) {
            phi_f6 = temp_f6 + 4294967296.0f;
        }
        temp_v0_2 = (phi_v0 + 1) & 0xFF;
        temp_f0 = phi_f0 * (phi_f6 / 127.0f);
        phi_v0 = temp_v0_2;
        phi_f0 = temp_f0;
    } while (temp_v0_2 < 4);
    func_801A7D84((arg0 << 0x18) | 0x40000000 | (temp_a3 << 0x10) | ((u32) (temp_f0 * 127.0f) & 0xFF), temp_a1, temp_a3);
}

void func_801A8D5C(void) {
    ? sp70;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f6;
    f32 temp_f8;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a3;
    s32 temp_a3_2;
    s32 temp_lo;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s1;
    s32 temp_s3;
    s32 temp_s3_2;
    s32 temp_s5;
    s32 temp_v0;
    s32 temp_v0_10;
    s32 temp_v0_4;
    s32 temp_v1;
    s8 temp_s0_3;
    u16 temp_t5;
    u16 temp_t5_2;
    u16 temp_t5_3;
    u16 temp_t7_2;
    u16 temp_v0_2;
    u16 temp_v0_5;
    u16 temp_v0_6;
    u16 temp_v1_2;
    u16 temp_v1_4;
    u32 temp_a0_4;
    u32 temp_t0;
    u32 temp_v0_3;
    u8 temp_t7;
    u8 temp_v0_9;
    u8 temp_v1_6;
    void *temp_a1;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s2;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v1_3;
    void *temp_v1_5;
    s32 phi_s5;
    s32 phi_s3;
    f32 phi_f0;
    f32 phi_f6;
    u32 phi_t0;
    s32 phi_t2;
    f32 phi_f8;
    s32 phi_a2;
    s32 phi_s0;
    s32 phi_s0_2;
    s32 phi_s3_2;
    s32 phi_v1;
    f32 phi_f16;

    phi_s5 = 0;
loop_1:
    temp_s2 = &D_80200140 + (phi_s5 * 0x21C);
    if ((temp_s2->unk_21B != 0) && (((u32) *(&D_802050D0 + (phi_s5 * 0x160)) >> 0x1F) != 0)) {
        temp_s2->unk_21B = 0U;
    }
    if ((func_801A8A50(phi_s5 & 0xFF) != 0xFFFF) && (((u32) *(&D_802050D0 + (phi_s5 * 0x160)) >> 0x1F) == 0) && (temp_s2->unk_21B == 0)) {
        temp_s2->unk_20A = 0xFFFFU;
    }
    if (temp_s2->unk_210 != 0) {
        temp_v0 = func_80193BA0(&sp70);
        if (temp_v0 >= 6) {
            if (temp_v0 != 0xFF) {

            } else {
                temp_s2->unk_210 = 0U;
            }
        } else {
            switch (temp_v0) {                      /* switch 1 */
                temp_s2->unk_210 = 0U;
                func_801A7D84(temp_s2->unk_1FC);
                break;
            }
        }
    }
    if (temp_s2->unk_217 != 0) {
        phi_s3 = 0;
        phi_f0 = 1.0f;
        do {
            temp_t7 = (&D_80200140 + (phi_s5 * 0x21C) + phi_s3)->unk_212;
            temp_f6 = (f32) temp_t7;
            phi_f6 = temp_f6;
            if ((s32) temp_t7 < 0) {
                phi_f6 = temp_f6 + 4294967296.0f;
            }
            temp_s3 = (phi_s3 + 1) & 0xFF;
            temp_f0 = phi_f0 * (phi_f6 / 127.0f);
            phi_s3 = temp_s3;
            phi_f0 = temp_f0;
        } while (temp_s3 < 4);
        func_801A89A8((temp_s2->unk_216 << 0x10) | 0x40000000 | ((phi_s5 + 8) << 0x18) | ((u32) (temp_f0 * 127.0f) & 0xFF));
        temp_s2->unk_217 = 0U;
    }
    temp_v0_2 = temp_s2->unk_200;
    temp_t5 = temp_v0_2 - 1;
    if (temp_v0_2 != 0) {
        temp_s2->unk_200 = temp_t5;
        if ((temp_t5 & 0xFFFF) != 0) {
            temp_s2->unk_1C0 = (f32) (temp_s2->unk_1C0 - temp_s2->unk_1C8);
        } else {
            temp_s2->unk_1C0 = (f32) temp_s2->unk_1C4;
        }
        func_80193858(((phi_s5 & 0xFF) << 0x10) | 0x41000000, temp_s2->unk_1C0);
    }
    temp_a2 = temp_s2->unk_1CC;
    phi_a2 = temp_a2;
    if (temp_a2 != 0) {
        temp_a1 = (phi_s5 * 0x160) + &D_80200C70;
        temp_v0_3 = (u32) (temp_a2 & 0xFF0000) >> 0xF;
        temp_a0 = temp_a2 & 0xFFF;
        temp_a3 = temp_v0_3 & 0xFF;
        temp_t0 = temp_a0 & 0xFFFF;
        phi_t0 = temp_t0;
        phi_t2 = temp_v0_3 & 0xFF;
        phi_t0 = temp_t0;
        if (temp_a3 == 0) {
            phi_t2 = (temp_a3 + 1) & 0xFF;
        }
        if (((u32) temp_a1->unk_4460 >> 0x1F) != 0) {
            temp_lo = (s32) temp_a1->unk_4468 / 0x30;
            temp_v0_4 = ((u32) (temp_a2 & 0xF000) >> 0xC) & 0xFF;
            temp_a2_2 = temp_lo & 0xFFFF;
            phi_a2 = temp_a2_2;
            if (temp_v0_4 != 1) {
                temp_v1 = temp_a0 & 0xFFFF;
                if (temp_v0_4 != 2) {
                    if (temp_v0_4 != 3) {
                        if (temp_v0_4 != 4) {

                        } else {
                            temp_v0_5 = temp_s2->unk_202;
                            phi_t0 = temp_a2_2 & 0xFFFF;
                            if (temp_v0_5 != 0) {
                                phi_t0 = temp_v0_5 & 0xFFFF;
                            }
                        }
                    } else {
                        temp_f16 = (f32) temp_a2_2;
                        phi_f16 = temp_f16;
                        if (temp_a2_2 < 0) {
                            phi_f16 = temp_f16 + 4294967296.0f;
                        }
                        phi_t0 = (u32) (phi_f16 * ((f32) (temp_a0 & 0xFFFF) / 100.0f)) & 0xFFFF;
                    }
                } else if (temp_v1 < temp_a2_2) {
                    phi_t0 = (temp_a2_2 - temp_v1) & 0xFFFF;
                }
            } else {
                phi_t0 = (temp_a0 + temp_a2_2) & 0xFFFF;
            }
            temp_f2 = (f32) temp_lo;
            if (temp_s2->unk_202 == 0) {
                temp_s2->unk_202 = (u16) temp_a2_2;
            }
            temp_f0_2 = (f32) phi_t0;
            temp_s2->unk_1D4 = temp_f0_2;
            temp_s2->unk_1D0 = temp_f2;
            temp_f8 = (f32) phi_t2;
            phi_f8 = temp_f8;
            if (phi_t2 < 0) {
                phi_f8 = temp_f8 + 4294967296.0f;
            }
            temp_s2->unk_204 = (u16) phi_t2;
            temp_s2->unk_1CC = 0;
            temp_s2->unk_1D8 = (f32) ((temp_f2 - temp_f0_2) / phi_f8);
        }
    }
    temp_v0_6 = temp_s2->unk_204;
    temp_t5_2 = temp_v0_6 - 1;
    if (temp_v0_6 != 0) {
        temp_s2->unk_204 = temp_t5_2;
        if ((temp_t5_2 & 0xFFFF) != 0) {
            temp_s2->unk_1D0 = (f32) (temp_s2->unk_1D0 - temp_s2->unk_1D8);
        } else {
            temp_s2->unk_1D0 = (f32) temp_s2->unk_1D4;
        }
        func_8019387C(((phi_s5 & 0xFF) << 0x10) | 0x47000000, (s32) temp_s2->unk_1D0, phi_a2);
    }
    if (temp_s2->unk_208 != 0) {
        phi_s0 = 0;
        do {
            temp_a0_2 = phi_s0 * 0x1C;
            temp_v0_7 = &D_80200140 + (phi_s5 * 0x21C) + temp_a0_2;
            temp_v1_2 = temp_v0_7->unk_18;
            temp_t7_2 = temp_v1_2 - 1;
            if (temp_v1_2 != 0) {
                temp_v0_7->unk_18 = temp_t7_2;
                temp_a2_3 = ((phi_s5 & 0xFF) << 0x10) | 0x1000000;
                if ((temp_t7_2 & 0xFFFF) != 0) {
                    temp_v0_7->unk_0 = (f32) (temp_v0_7->unk_0 - temp_v0_7->unk_8);
                } else {
                    temp_v1_3 = temp_s2 + temp_a0_2;
                    temp_v1_3->unk_0 = (f32) temp_v1_3->unk_4;
                    temp_s2->unk_208 = (u16) (temp_s2->unk_208 ^ (1 << phi_s0));
                }
                func_80193858(temp_a2_3 | ((phi_s0 & 0xFF) << 8), temp_v0_7->unk_0, temp_a2_3);
            }
            temp_s0 = (phi_s0 + 1) & 0xFF;
            phi_s0 = temp_s0;
        } while (temp_s0 < 0x10);
    }
    if (temp_s2->unk_206 != 0) {
        phi_s0_2 = 0;
        do {
            temp_a0_3 = phi_s0_2 * 0x1C;
            temp_v0_8 = &D_80200140 + (phi_s5 * 0x21C) + temp_a0_3;
            temp_v1_4 = temp_v0_8->unk_1A;
            temp_t5_3 = temp_v1_4 - 1;
            if (temp_v1_4 != 0) {
                temp_v0_8->unk_1A = temp_t5_3;
                temp_a2_4 = ((phi_s5 & 0xFF) << 0x10) | 0x4000000;
                if ((temp_t5_3 & 0xFFFF) != 0) {
                    temp_v0_8->unk_C = (f32) (temp_v0_8->unk_C - temp_v0_8->unk_14);
                } else {
                    temp_v1_5 = temp_s2 + temp_a0_3;
                    temp_v1_5->unk_C = (f32) temp_v1_5->unk_10;
                    temp_s2->unk_206 = (u16) (temp_s2->unk_206 ^ (1 << phi_s0_2));
                }
                func_80193858(temp_a2_4 | ((phi_s0_2 & 0xFF) << 8), temp_v0_8->unk_C, temp_a2_4);
            }
            temp_s0_2 = (phi_s0_2 + 1) & 0xFF;
            phi_s0_2 = temp_s0_2;
        } while (temp_s0_2 < 0x10);
    }
    if (temp_s2->unk_219 != 0) {
        if (func_801A8ABC(0xF0000000, 0xF0000000) == 0) {
            temp_s2->unk_219 = 0U;
            return;
        }
        temp_v0_9 = temp_s2->unk_218;
        if (temp_v0_9 != 0) {
            temp_s2->unk_218 = (u8) (temp_v0_9 - 1);
        } else if (((u32) *(&D_802050D0 + (phi_s5 * 0x160)) >> 0x1F) == 0) {
            temp_v1_6 = temp_s2->unk_219;
            phi_s3_2 = 0;
            phi_v1 = (s32) temp_v1_6;
            if ((s32) temp_v1_6 > 0) {
                do {
                    temp_v0_10 = (&D_80200140 + (phi_s5 * 0x21C) + (phi_s3_2 * 4))->unk_1DC;
                    temp_a0_4 = ((u32) (temp_v0_10 & 0xF00000) >> 0x14) & 0xFF;
                    temp_s1 = ((u32) (temp_v0_10 & 0xF0000) >> 0x10) & 0xFF;
                    temp_s0_3 = ((u32) (temp_v0_10 & 0xFF00) >> 8) & 0xFF;
                    temp_a3_2 = temp_v0_10 & 0xFF;
                    switch (temp_a0_4) {            /* switch 2 */
                    case 0:                         /* switch 2 */
                        func_801A8BD0(temp_s1 & 0xFF, 1, 0x7F, temp_a3_2);
block_100:
                        phi_v1 = (s32) temp_s2->unk_219;
                        break;
                    case 7:                         /* switch 2 */
                        if (temp_a3_2 == *(&D_801FFD34 + phi_s5)) {
                            func_801A8BD0(temp_s1 & 0xFF, 1, 0x7F, temp_s0_3 & 0xFF);
                            goto block_100;
                        }
                        break;
                    case 1:                         /* switch 2 */
                        func_801A89A8(temp_s2->unk_20A | 0x30000000 | ((phi_s5 + 8) << 0x18));
                        goto block_100;
                    case 2:                         /* switch 2 */
                        temp_s0_4 = &D_80200140 + (temp_s1 * 0x21C);
                        func_801A89A8(temp_s0_4->unk_20A | ((temp_s1 + 8) << 0x18) | 0x10000);
                        temp_s0_4->unk_217 = 1;
                        temp_s0_4->unk_213 = 0x7F;
                        goto block_100;
                    case 3:                         /* switch 2 */
                        func_801A89A8(((temp_s1 + 8) << 0x18) | 0xB0003000 | (temp_s0_3 << 0x10) | temp_a3_2);
                        goto block_100;
                    case 4:                         /* switch 2 */
                        func_801A89A8(((temp_s1 + 8) << 0x18) | 0xB0004000 | (temp_a3_2 << 0x10));
                        goto block_100;
                    case 5:                         /* switch 2 */
                        temp_s0_5 = &D_80200140 + (temp_s1 * 0x21C);
                        func_801A89A8((temp_s0_5->unk_21A << 0x10) | ((temp_s1 + 8) << 0x18) | (temp_v0_10 & 0xFFFF));
                        func_801A8BD0(temp_s1 & 0xFF, 1, 0x7F, 0);
                        temp_s0_5->unk_21A = 0U;
                        goto block_100;
                    case 6:                         /* switch 2 */
                        temp_s2->unk_21A = temp_s0_3;
                        goto block_100;
                    case 8:                         /* switch 2 */
                        func_801A8BD0(temp_s1 & 0xFF, temp_s0_3 & 0xFF, 0x7F, temp_a3_2);
                        goto block_100;
                    case 14:                        /* switch 2 */
                        if ((temp_a3_2 & 1) != 0) {
                            func_8019387C(0xE3000000, 0);
                        }
                        if ((temp_a3_2 & 2) != 0) {
                            func_8019387C(0xE3000000, 1);
                        }
                        if ((temp_a3_2 & 4) != 0) {
                            func_8019387C(0xE3000000, 2);
                        }
                        goto block_100;
                    case 9:                         /* switch 2 */
                        func_801A89A8(((temp_s1 + 8) << 0x18) | 0xA0000000 | (temp_v0_10 & 0xFFFF));
                        goto block_100;
                    case 10:                        /* switch 2 */
                        func_801A89A8(((temp_s1 + 8) << 0x18) | 0x50000000 | (temp_s0_3 << 0x10) | ((temp_a3_2 * 0xA) & 0xFFFF));
                        goto block_100;
                    }
                    temp_s3_2 = (phi_s3_2 + 1) & 0xFF;
                    phi_s3_2 = temp_s3_2;
                } while (temp_s3_2 < phi_v1);
            }
            temp_s2->unk_219 = 0U;
        }
        goto block_103;
    }
block_103:
    temp_s5 = (phi_s5 + 1) & 0xFF;
    phi_s5 = temp_s5;
    if (temp_s5 >= 5) {
        return;
    }
    goto loop_1;
}

u8 func_801A9768(void) {
    u8 temp_v1;
    u8 phi_v1;

    temp_v1 = D_801DB4D8;
    phi_v1 = temp_v1;
    if (temp_v1 != 0) {
        if (temp_v1 == 1) {
            if (func_80193C5C() == 1) {
                D_801DB4D8 = 0;
                func_801938A0(0x46020000, D_801DB49C);
                func_801A4DA4();
            }
            goto block_9;
        }
        if (temp_v1 == 2) {
            if (func_80193C5C() != 1) {
                do {

                } while (func_80193C5C() != 1);
            }
            D_801DB4D8 = 0;
            func_801938A0(0x46020000, D_801DB49C);
            func_801A4DA4();
block_9:
            phi_v1 = D_801DB4D8;
        }
    }
    return phi_v1;
}

u8 func_801A982C(void) {
    u8 sp37;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_v0;
    u32 temp_v1;
    u8 temp_v1_2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s0_2;
    s32 phi_s1_2;

    temp_v1 = D_801DB4DC;
    sp37 = 0;
    temp_v0 = ((u32) (temp_v1 & 0xFF0000) >> 0x10) & 0xFF;
    phi_s1 = 0;
    phi_s1_2 = 0;
    if (temp_v1 != 0) {
        temp_v1_2 = D_80200BCC;
        D_80200BCC = temp_v1_2 - 1;
        if (temp_v1_2 != 0) {
            phi_s0 = temp_v0;
            if (temp_v0 != 0) {
                do {
                    if ((phi_s0 & 1) != 0) {
                        func_8019387C(((phi_s1 & 0xFF) << 8) | 0xE6040000, (s32) D_80200BCE);
                        func_80193900();
                    }
                    temp_s0 = (phi_s0 >> 1) & 0xFF;
                    phi_s0 = temp_s0;
                    phi_s1 = (phi_s1 + 1) & 0xFF;
                } while (temp_s0 != 0);
            }
            sp37 = 1;
            D_80200BCE -= *D_80200BD0;
        } else {
            phi_s0_2 = temp_v0;
            if (temp_v0 != 0) {
                do {
                    if ((phi_s0_2 & 1) != 0) {
                        func_8019387C(((phi_s1_2 & 0xFF) << 8) | 0xE6000000, (s32) ((&D_801DB930)[D_801DB4DC & 0xFF] + (phi_s1_2 * 0x18)));
                        func_80193900();
                    }
                    temp_s0_2 = (phi_s0_2 >> 1) & 0xFF;
                    phi_s0_2 = temp_s0_2;
                    phi_s1_2 = (phi_s1_2 + 1) & 0xFF;
                } while (temp_s0_2 != 0);
            }
            D_801DB4DC = 0;
            func_801938A0(0x46020000, D_801DB49C);
            func_801A4D50();
        }
    }
    return sp37;
}

void func_801A99B8(void) {
    s32 temp_a0;
    s32 temp_v0;
    void *temp_v1;
    s32 phi_v0;
    s32 phi_a0;

    phi_v0 = 0;
    do {
        *(&D_801FFD34 + phi_v0) = 0;
        temp_v1 = &D_80200140 + (phi_v0 * 0x21C);
        temp_v1->unk_20A = 0xFFFF;
        temp_v1->unk_20C = 0xFFFF;
        temp_v1->unk_204 = 0;
        temp_v1->unk_202 = 0;
        temp_v1->unk_1CC = 0;
        temp_v1->unk_20E = 0;
        temp_v1->unk_219 = 0;
        temp_v1->unk_21A = 0;
        temp_v1->unk_206 = 0;
        temp_v1->unk_208 = 0;
        temp_v1->unk_210 = 0;
        temp_v1->unk_21B = 0;
        phi_a0 = 0;
loop_2:
        temp_a0 = (phi_a0 + 1) & 0xFF;
        (&D_80200140 + (phi_v0 * 0x21C) + phi_a0)->unk_212 = 0x7F;
        phi_a0 = temp_a0;
        if (temp_a0 < 4) {
            goto loop_2;
        }
        temp_v0 = (phi_v0 + 1) & 0xFF;
        temp_v1->unk_216 = 1;
        temp_v1->unk_217 = 1;
        phi_v0 = temp_v0;
    } while (temp_v0 < 5);
}

void func_801A9A74(void) {
    s32 temp_a2;
    s32 temp_v0;
    void *temp_a1;
    s32 phi_a2;
    s32 phi_v0;

    phi_a2 = 0;
    do {
        temp_a2 = (phi_a2 + 1) & 0xFF;
        temp_a1 = &D_80200140 + (phi_a2 * 0x21C);
        temp_a1->unk_1C0 = 1.0f;
        temp_a1->unk_200 = 0;
        temp_a1->unk_217 = 0;
        phi_a2 = temp_a2;
        phi_v0 = 0;
loop_2:
        temp_v0 = (phi_v0 + 1) & 0xFF;
        (&D_80200140 + (phi_a2 * 0x21C) + phi_v0)->unk_212 = 0x7F;
        phi_v0 = temp_v0;
        if (temp_v0 < 4) {
            goto loop_2;
        }
    } while (temp_a2 < 5);
    func_801A99B8(0x7F, temp_a1, temp_a2, &D_80200140);
}

void func_801A9B10(u8 *arg0, s32 arg1, s32 arg2) {
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_v1;
    u8 *temp_a0;
    u8 *phi_a0;
    s32 phi_v0;
    s32 phi_a1;
    u8 *phi_a0_2;

    temp_v1 = arg2 & 0xFF;
    phi_v0 = 0;
    phi_a0_2 = arg0;
    if (temp_v1 > 0) {
        do {
            phi_a0 = phi_a0_2 + 1;
            phi_a1 = 0;
loop_2:
            temp_t1 = (phi_a1 + 1) & 0xFF;
            temp_a0 = phi_a0 + 1;
            *(arg1 + (phi_v0 << 7) + (phi_a1 * 2)) = (s16) *phi_a0;
            phi_a0 = temp_a0;
            phi_a1 = temp_t1;
            phi_a0_2 = temp_a0;
            if (temp_t1 < 0x40) {
                goto loop_2;
            }
            temp_t2 = (phi_v0 + 1) & 0xFF;
            phi_v0 = temp_t2;
        } while (temp_t2 < temp_v1);
    }
}

s16 func_801A9B78(void *arg0, void *arg1) {
    s16 temp_a2;
    s16 temp_v1;
    s32 temp_a3;
    void *temp_a1;
    s32 phi_a3;
    s8 phi_v0;
    s16 phi_v1;
    s16 phi_a2;
    s16 phi_v1_2;
    s16 phi_v1_3;
    s16 phi_a2_2;

    phi_a3 = 1;
    phi_v0 = 1;
    phi_v1_3 = 0;
    phi_a2_2 = 1;
    phi_a2_2 = 1;
    do {
        temp_a1 = phi_a3 + arg0;
        phi_v1 = phi_v1_3;
        phi_a2 = phi_a2_2;
        phi_v1_2 = phi_v1_3;
        if ((s32) temp_a1->unk_-1 > 0) {
            do {
                *(arg1 + phi_v1) = phi_v0;
                temp_a2 = phi_a2 + 1;
                temp_v1 = phi_v1 + 1;
                phi_v1 = temp_v1;
                phi_a2 = temp_a2;
                phi_v1_2 = temp_v1;
            } while ((s32) temp_a1->unk_-1 >= (s32) temp_a2);
        }
        temp_a3 = (phi_v0 + 1) & 0xFF;
        phi_a3 = temp_a3;
        phi_v0 = (s8) temp_a3;
        phi_v1_3 = phi_v1_2;
    } while (temp_a3 < 0x11);
    *(arg1 + phi_v1_2) = 0;
    return phi_v1_2;
}

/*
Failed to decompile function func_801A9BFC:

Label L801A9C40 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/

s8 func_801A9C68(void *arg0, s32 arg1, s32 arg2) {
    s32 temp_t2;
    s32 temp_t4;
    u8 *temp_a1;
    void *temp_a2;
    s32 phi_v0;
    s8 phi_v1;
    s8 phi_v1_2;

    phi_v0 = 0;
    phi_v1 = 0;
    do {
        temp_a1 = phi_v0 + arg0;
        phi_v1_2 = phi_v1;
        if (*temp_a1 != 0) {
            *(arg1 + phi_v0) = phi_v1;
            temp_a2 = arg1 + (phi_v0 * 2);
            temp_a2->unk_10 = (u16) *(arg2 + (phi_v1 * 2));
            temp_t4 = ((phi_v1 + *temp_a1) - 1) & 0xFFFF;
            temp_a2->unk_30 = (u16) *(arg2 + (temp_t4 * 2));
            phi_v1_2 = (temp_t4 + 1) & 0xFFFF;
        } else {
            (arg1 + (phi_v0 * 2))->unk_30 = 0xFFFF;
        }
        temp_t2 = (phi_v0 + 1) & 0xFF;
        phi_v0 = temp_t2;
        phi_v1 = phi_v1_2;
    } while (temp_t2 < 0x10);
    return phi_v1_2;
}

s16 func_801A9D10(void *arg0, s32 arg1, void *arg2, s32 arg3, u8 arg4) {
    s16 sp1E;
    s16 temp_v0;

    temp_v0 = func_801A9B78(arg2);
    if ((temp_v0 == 0) || ((arg4 != 0) && ((s32) temp_v0 >= 0x101)) || ((arg4 == 0) && ((s32) temp_v0 >= 0x11))) {
        return 0;
    }
    sp1E = temp_v0;
    if (func_801A9BFC(arg2, arg3) != temp_v0) {
        return 0;
    }
    sp1E = temp_v0;
    if (temp_v0 != func_801A9C68(arg0, arg1, arg3)) {
        return 0;
    }
    return temp_v0;
}

? func_801A9DCC(u8 *arg0, s32 arg1, void *arg2, s32 arg3, u8 arg4) {
    s16 temp_v0;
    s32 temp_lo;
    s32 temp_t8;
    void *temp_s0;
    void *temp_s0_2;
    u8 *phi_s0;
    s32 phi_s1;

    phi_s0 = arg0;
    phi_s1 = 0;
    if ((s32) arg4 > 0) {
loop_2:
        temp_lo = phi_s1 * 0x54;
        temp_s0 = phi_s0 + 1;
        temp_v0 = func_801A9D10(temp_s0, temp_lo + arg1, arg2, arg3, (u8) ((s32) *phi_s0 >> 4));
        temp_s0_2 = temp_s0 + 0x10;
        if (temp_v0 == 0) {
            return 1;
        }
        temp_t8 = (phi_s1 + 1) & 0xFF;
        (arg1 + temp_lo)->unk_50 = temp_s0_2;
        phi_s0 = temp_s0_2 + temp_v0;
        phi_s1 = temp_t8;
        if (temp_t8 >= (s32) arg4) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    return 0;
}

void func_801A9EA4(void *arg0, s32 arg1, void *arg2, s32 arg3, s16 arg4, u8 arg5) {
    s16 temp_v0;
    u8 temp_v1;
    s16 phi_v0;

    phi_v0 = 0;
    if ((s32) arg4 > 0) {
        do {
            temp_v1 = *(phi_v0 + arg0);
            if (arg5 != 0) {
                (arg1 + (temp_v1 * 2))->unk_100 = (u16) *(arg3 + (phi_v0 * 2));
                *(arg1 + temp_v1) = *(phi_v0 + arg2);
            } else {
                (arg1 + (temp_v1 * 2))->unk_10 = (u16) *(arg3 + (phi_v0 * 2));
                *(arg1 + temp_v1) = *(phi_v0 + arg2);
            }
            temp_v0 = phi_v0 + 1;
            phi_v0 = temp_v0;
        } while ((s32) temp_v0 < (s32) arg4);
    }
}

? func_801A9F4C(u8 *arg0, s32 arg1, void *arg2, s32 arg3) {
    u8 sp2F;
    s16 sp2C;
    s16 temp_v0;
    void *temp_s0;

    temp_s0 = arg0 + 1;
    sp2F = (u8) ((s32) *arg0 >> 4);
    temp_v0 = func_801A9B78(temp_s0, arg2);
    if ((temp_v0 == 0) || ((sp2F != 0) && ((s32) temp_v0 >= 0x101)) || ((sp2F == 0) && ((s32) temp_v0 >= 0x11))) {
        return 1;
    }
    sp2F = sp2F;
    sp2C = temp_v0;
    if (func_801A9BFC(arg2, arg3) != temp_v0) {
        return 1;
    }
    func_801A9EA4(temp_s0 + 0x10, arg1, arg2, arg3, (s16) (s32) temp_v0, (u8) (s32) sp2F);
    return 0;
}
