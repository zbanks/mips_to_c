struct _mips2c_stack_EnMinislime_AddIceShardEffect {
    /* 0x00 */ char pad_0[0x70];
    /* 0x70 */ s32 sp70;                            /* inferred */
    /* 0x74 */ char pad_74[0x24];
};                                                  /* size = 0x98 */

struct _mips2c_stack_EnMinislime_AddIceSmokeEffect {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ f32 sp28;                            /* inferred */
    /* 0x2C */ f32 sp2C;                            /* inferred */
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ f32 sp3C;                            /* inferred */
};                                                  /* size = 0x40 */

struct _mips2c_stack_EnMinislime_ApplyDamage {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_Bounce {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_BreakFromBigslime {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_CheckBackgroundCollision {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_DefeatIdle {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_DefeatMelt {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_Despawn {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_Destroy {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_Disappear {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_Fall {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_FireArrowDamage {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_GekkoThrow {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_GrowAndShrink {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ f32 sp1C;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_IceArrowDamage {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ f32 sp24;                            /* inferred */
    /* 0x28 */ char pad_28[0x4];
    /* 0x2C */ f32 sp2C;                            /* inferred */
};                                                  /* size = 0x30 */

struct _mips2c_stack_EnMinislime_Idle {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ PosRot *sp20;                        /* inferred */
    /* 0x24 */ char pad_24[0xC];
};                                                  /* size = 0x30 */

struct _mips2c_stack_EnMinislime_Init {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_Knockback {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ f32 sp24;                            /* inferred */
    /* 0x28 */ char pad_28[0x4];
    /* 0x2C */ f32 sp2C;                            /* inferred */
};                                                  /* size = 0x30 */

struct _mips2c_stack_EnMinislime_MoveToBigslime {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_MoveToGekko {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_SetupBounce {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_SetupBreakFromBigslime {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_SetupDefeatIdle {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_SetupDefeatMelt {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_SetupDespawn {};   /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupDisappear {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupFall {
    /* 0x00 */ char pad_0[0x22];
    /* 0x22 */ s16 sp22;                            /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_EnMinislime_SetupFireArrowDamage {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupGekkoThrow {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupGrowAndShrink {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_SetupIceArrowDamage {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupIdle {};      /* size 0x0 */

struct _mips2c_stack_EnMinislime_SetupKnockback {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnMinislime_SetupMoveToBigslime {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_EnMinislime_SetupMoveToGekko {}; /* size 0x0 */

struct _mips2c_stack_EnMinislime_Update {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ ColliderCylinder *sp2C;              /* inferred */
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

void EnMinislime_AddIceShardEffect(Actor *arg0);    /* static */
void EnMinislime_AddIceSmokeEffect(EnMinislime *arg0, GlobalContext *arg1); /* static */
void EnMinislime_ApplyDamage(EnMinislime *arg0);    /* static */
void EnMinislime_CheckBackgroundCollision(EnMinislime *arg0); /* static */
void EnMinislime_SetupDefeatIdle(EnMinislime *arg0); /* static */
void EnMinislime_SetupFireArrowDamage(void *arg0);  /* static */
void EnMinislime_SetupIceArrowDamage(void *arg0);   /* static */
void EnMinislime_SetupKnockback(Actor *arg0);       /* static */
void EnMinislime_SetupMoveToBigslime(Actor *arg0);  /* static */
static ColliderCylinderInit D_809857E0 = {
    {0xA, 0x10, 8, 0x38, 0x10, 1},
    {0, {0xF7CFFFFF, 0, 4}, {0xF7CFFFFF, 0, 0}, 9, 5, 1},
    {0x36, 0x3C, 0xFFE2, {0, 0, 0}},
};
static CollisionCheckInfoInit D_8098580C = {4, 0x28, 0x28, 0x1E};
static DamageTable D_80985814 = {
    {
        0,
        1,
        1,
        0xF1,
        1,
        1,
        1,
        0xE0,
        0xF1,
        1,
        0xF1,
        0x21,
        0x31,
        1,
        0xF1,
        1,
        1,
        1,
        0,
        1,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0xF1,
    },
};

void EnMinislime_Init(Actor *thisx, GlobalContext *globalCtx) {
    EnMinislime *this = (EnMinislime *) thisx;
    this->actor.flags &= -2;
    Collider_InitAndSetCylinder(globalCtx, &this->collider, (Actor *) this, &D_809857E0);
    CollisionCheck_SetInfo(&this->actor.colChkInfo, &D_80985814, &D_8098580C);
    this->actor.shape.shadowAlpha = 0xFF;
    this->id = (u8) this->actor.params;
    EnMinislime_SetupDisappear(this);
}

void EnMinislime_Destroy(Actor *thisx, GlobalContext *globalCtx) {
    EnMinislime *this = (EnMinislime *) thisx;
    Collider_DestroyCylinder(globalCtx, &this->collider);
}

void EnMinislime_CheckBackgroundCollision(EnMinislime *arg0) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;
    u16 temp_t0;
    u16 temp_t3;
    u16 temp_t7;
    u16 temp_v0;
    u16 phi_v0;

    temp_f14 = arg0->actor.world.pos.y;
    temp_f2 = arg0->actor.scale.x * 400.0f;
    temp_f12 = arg0->actor.scale.y * 400.0f;
    temp_t7 = arg0->actor.bgCheckFlags & ~0x1A;
    temp_f0 = arg0->actor.scale.z * 400.0f;
    arg0->actor.bgCheckFlags = temp_t7;
    temp_t0 = temp_t7 | 0x10;
    if ((temp_f14 + temp_f12) > -90.0f) {
        arg0->actor.bgCheckFlags = temp_t0;
        arg0->actor.bgCheckFlags = temp_t0 & 0xFFFE;
        arg0->actor.world.pos.y = -90.0f - temp_f12;
    } else if ((temp_f14 - temp_f12) < -690.0f) {
        temp_v0 = arg0->actor.bgCheckFlags;
        arg0->actor.world.pos.y = -690.0f + temp_f12;
        phi_v0 = temp_v0;
        if ((temp_v0 & 1) == 0) {
            temp_t3 = temp_v0 | 2;
            arg0->actor.bgCheckFlags = temp_t3;
            phi_v0 = temp_t3 & 0xFFFF;
        }
        arg0->actor.bgCheckFlags = phi_v0 | 1;
    } else {
        arg0->actor.bgCheckFlags &= 0xFFFE;
    }
    temp_f12_2 = arg0->actor.world.pos.x;
    if ((temp_f12_2 + temp_f2) > 1818.0f) {
        arg0->actor.bgCheckFlags |= 8;
        arg0->actor.world.pos.x = 1818.0f - temp_f2;
    } else if ((temp_f12_2 - temp_f2) < 858.0f) {
        arg0->actor.world.pos.x = 858.0f + temp_f2;
        arg0->actor.bgCheckFlags |= 8;
    }
    temp_f2_2 = arg0->actor.world.pos.z;
    if ((temp_f2_2 + temp_f0) > -2012.0f) {
        arg0->actor.bgCheckFlags |= 8;
        arg0->actor.world.pos.z = -2012.0f - temp_f0;
        return;
    }
    if ((temp_f2_2 - temp_f0) < -2972.0f) {
        arg0->actor.world.pos.z = -2972.0f + temp_f0;
        arg0->actor.bgCheckFlags |= 8;
    }
}

void EnMinislime_AddIceShardEffect(Actor *arg0) {
    s32 sp70;
    f32 temp_f20;
    f32 temp_f20_2;
    f32 temp_f2;
    s16 temp_s1;
    s16 temp_v0_2;
    s32 temp_s5;
    s32 temp_s5_2;
    s32 temp_v0;
    s32 temp_v1;
    void *temp_s0;
    s16 phi_s3;
    void *phi_s0;
    Vec3f *phi_s4;
    s32 phi_s5;

    temp_v1 = (arg0->unk_149 * 0xA) + 0xA2;
    temp_v0 = temp_v1 + 0xA;
    phi_s3 = 0;
    if (temp_v1 < temp_v0) {
        temp_s5 = temp_v1 * 0x24;
        temp_s0 = arg0->parent + temp_s5 + 0xA54;
        sp70 = temp_v0 * 0x24;
        phi_s0 = temp_s0;
        phi_s4 = temp_s0 + 0xC;
        phi_s5 = temp_s5;
        do {
            temp_v0_2 = Rand_S16Offset(0x1000, 0x3000);
            temp_s1 = temp_v0_2;
            temp_f20 = Math_CosS(temp_v0_2);
            phi_s0->unk_C = (f32) (Math_SinS(phi_s3) * temp_f20);
            phi_s0->unk_10 = Math_SinS(temp_s1);
            temp_f20_2 = Math_CosS(temp_s1);
            temp_f2 = Math_CosS(phi_s3) * temp_f20_2;
            phi_s0->unk_14 = temp_f2;
            phi_s0->unk_0 = (f32) (arg0->world.pos.x + (400.0f * arg0->scale.x * phi_s0->unk_C));
            phi_s0->unk_4 = (f32) (arg0->world.pos.y + (((2.0f * phi_s0->unk_10) - 1.0f) * 400.0f * arg0->scale.y));
            phi_s0->unk_8 = (f32) (arg0->world.pos.z + (400.0f * arg0->scale.z * temp_f2));
            phi_s0->unk_1A = (s16) (Rand_Next() >> 0x10);
            phi_s0->unk_1C = (s16) (Rand_Next() >> 0x10);
            phi_s0->unk_1E = (s16) (Rand_Next() >> 0x10);
            phi_s0->unk_18 = 1;
            Math_Vec3f_ScaleAndStore(phi_s4, Rand_ZeroFloat(3.0f) + 7.0f, phi_s4);
            temp_s5_2 = phi_s5 + 0x24;
            phi_s0->unk_20 = (f32) ((Rand_ZeroFloat(6.0f) + 2.0f) * 0.001f);
            phi_s3 = (s16) (phi_s3 + 0x1999);
            phi_s0 += 0x24;
            phi_s4 += 0x24;
            phi_s5 = temp_s5_2;
        } while (temp_s5_2 < sp70);
    }
    arg0->unk_148 = 0;
    Audio_PlayActorSound2(arg0, 0x28CBU);
}

void EnMinislime_AddIceSmokeEffect(EnMinislime *arg0, GlobalContext *arg1) {
    f32 sp3C;
    f32 sp38;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 sp28;
    f32 temp_f2;

    sp34 = (randPlusMinusPoint5Scaled(200.0f) * arg0->actor.scale.x) + arg0->actor.world.pos.x;
    temp_f2 = arg0->actor.world.pos.y;
    if (temp_f2 < -660.0f) {
        sp38 = -660.0f;
    } else {
        sp38 = temp_f2;
    }
    arg0 = arg0;
    sp3C = (randPlusMinusPoint5Scaled(200.0f) * arg0->actor.scale.z) + arg0->actor.world.pos.z;
    sp28 = randPlusMinusPoint5Scaled(1.5f);
    sp30 = randPlusMinusPoint5Scaled(1.5f);
    sp2C = 2.0f;
    EffectSsIceSmoke_Spawn(arg1, (Vec3f *) &sp34, (Vec3f *) &sp28, &D_801D15B0, (s16) 0x1F4);
}

void EnMinislime_SetupDisappear(EnMinislime *this) {
    this->actor.params = 0;
    this->actionFunc = EnMinislime_Disappear;
}

void EnMinislime_Disappear(EnMinislime *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    temp_v0 = this->actor.params;
    if (temp_v0 == 2) {
        EnMinislime_SetupBreakFromBigslime(this);
        return;
    }
    if (temp_v0 == 1) {
        EnMinislime_SetupFall(this, globalCtx);
        return;
    }
    if (temp_v0 == 9) {
        EnMinislime_SetupDespawn(this);
    }
}

void EnMinislime_SetupFall(EnMinislime *this, GlobalContext *globalCtx) {
    s16 sp22;
    Actor *temp_s1;
    s16 temp_v0;
    s32 temp_a0;

    temp_s1 = globalCtx->actorCtx.actorList[2].first;
    this->collider.base.atFlags |= 1;
    this->collider.base.acFlags |= 1;
    this->collider.base.ocFlags1 |= 1;
    this->actor.speedXZ = 0.0f;
    this->actor.gravity = -2.0f;
    if (EnMinislime_GekkoThrow != this->actionFunc) {
        this->actor.scale.x = 0.095f;
        this->actor.scale.z = 0.095f;
        this->actor.scale.y = 0.10700001f;
        if (Actor_XZDistanceBetweenActors((Actor *) this, temp_s1) < 225.0f) {
            temp_v0 = Actor_YawBetweenActors(temp_s1, (Actor *) this);
            temp_a0 = temp_v0 << 0x10;
            sp22 = temp_v0;
            this->actor.world.pos.x = (Math_SinS((s16) (temp_a0 >> 0x10)) * 225.0f) + temp_s1->world.pos.x;
            this->actor.world.pos.z = (Math_CosS(sp22) * 225.0f) + temp_s1->world.pos.z;
        }
    }
    this->actionFunc = EnMinislime_Fall;
}

void EnMinislime_Fall(EnMinislime *this, GlobalContext *globalCtx) {
    Vec3f *temp_a0;

    temp_a0 = &this->actor.scale;
    this = this;
    Math_StepToF((f32 *) temp_a0, 0.17999999f, 0.003f);
    Math_StepToF(&this->actor.scale.y, 0.05f, 0.003f);
    this->actor.scale.z = this->actor.scale.x;
    if ((this->actor.bgCheckFlags & 1) != 0) {
        EnMinislime_SetupGrowAndShrink(this);
    }
}

void EnMinislime_SetupBreakFromBigslime(EnMinislime *this) {
    f32 temp_f10;

    this->actor.world.rot.y = Actor_YawBetweenActors(this->actor.parent, (Actor *) this);
    this->actor.shape.rot.y = this->actor.world.rot.y;
    this->actor.speedXZ = Math_CosS(this->actor.world.rot.x) * 15.0f;
    temp_f10 = Math_SinS(this->actor.world.rot.x) * 15.0f;
    this->actor.bgCheckFlags &= 0xFFFE;
    this->actor.gravity = -1.0f;
    this->actor.velocity.y = temp_f10 + 2.0f;
    this->frozenScale = 0.1f;
    this->actor.world.rot.x = Rand_S16Offset(0x800, 0x800);
    this->actor.shape.rot.x = (s16) (Rand_Next() >> 0x10);
    this->actor.shape.rot.z = (s16) (Rand_Next() >> 0x10);
    this->actor.scale.x = 0.15f;
    this->frozenAlpha = 0xC8;
    this->actionFunc = EnMinislime_BreakFromBigslime;
    this->actor.scale.z = 0.15f;
    this->actor.scale.y = 0.075f;
}

void EnMinislime_BreakFromBigslime(EnMinislime *this, GlobalContext *globalCtx) {
    this->actor.shape.rot.x += this->actor.world.rot.x;
    if (this->actor.velocity.y < 0.0f) {
        this->collider.base.ocFlags1 |= 1;
        if ((this->actor.bgCheckFlags & 1) != 0) {
            EnMinislime_AddIceShardEffect();
            this->attackTimer = 0x28;
            EnMinislime_SetupGrowAndShrink(this);
        }
    }
}

void EnMinislime_SetupIceArrowDamage(void *arg0) {
    arg0->unk_170 = (u8) (arg0->unk_170 & 0xFFFE);
    arg0->unk_14A = 0x50;
    arg0->unk_70 = 0.0f;
    arg0->unk_144 = EnMinislime_IceArrowDamage;
    arg0->unk_150 = 0.1f;
}

void EnMinislime_IceArrowDamage(EnMinislime *this, GlobalContext *globalCtx) {
    f32 sp2C;
    f32 sp24;
    f32 temp_f12;
    s16 temp_v0;
    s16 temp_v0_2;
    s32 phi_v0;
    s32 phi_v0_2;

    temp_v0 = this->frozenTimer;
    if (temp_v0 == 0x50) {
        this->frozenAlpha += 0xA;
        func_800B9010((Actor *) this, 0x20B2U);
        if ((s32) this->frozenAlpha >= 0xC8) {
            this->frozenAlpha = 0xC8;
            this->frozenTimer += -1;
        }
        goto block_16;
    }
    if ((s32) temp_v0 > 0) {
        this->frozenTimer = temp_v0 - 1;
        temp_v0_2 = this->frozenTimer;
        if (temp_v0_2 == 0x28) {
            Math_Vec3f_Copy(&this->shakeRefPos, (Vec3f *) &this->actor.world);
        } else if (((s32) temp_v0_2 > 0) && (((s32) temp_v0_2 < 0x14) || (((s32) temp_v0_2 < 0x28) && ((temp_v0_2 & 1) != 0)))) {
            temp_f12 = 1.0f / (f32) temp_v0_2;
            sp2C = temp_f12;
            sp24 = Rand_ZeroFloat(temp_f12);
            phi_v0 = 1;
            phi_v0_2 = 1;
            if (Rand_ZeroOne() < 0.5f) {
                phi_v0 = -1;
            }
            this->actor.world.pos.x = ((f32) phi_v0 * (sp2C + sp24)) + this->shakeRefPos.x;
            sp24 = Rand_ZeroFloat(sp2C);
            if (Rand_ZeroOne() < 0.5f) {
                phi_v0_2 = -1;
            }
            this->actor.world.pos.z = ((f32) phi_v0_2 * (sp2C + sp24)) + this->shakeRefPos.z;
        }
block_16:
        if ((this->actor.bgCheckFlags & 2) != 0) {
            EnMinislime_AddIceShardEffect((Actor *) this);
            EnMinislime_SetupGrowAndShrink(this);
        }
        return;
    }
    EnMinislime_AddIceShardEffect((Actor *) this);
    EnMinislime_SetupIdle(this);
}

void EnMinislime_SetupFireArrowDamage(void *arg0) {
    arg0->unk_14A = 0x28;
    arg0->unk_BC = 0;
    arg0->unk_BE = 0;
    arg0->unk_C0 = 0;
    arg0->unk_30 = 0;
    arg0->unk_171 = (u8) (arg0->unk_171 & 0xFFFE);
    arg0->unk_144 = EnMinislime_FireArrowDamage;
    arg0->unk_70 = 0.0f;
}

void EnMinislime_FireArrowDamage(EnMinislime *this, GlobalContext *globalCtx) {
    s16 temp_v0;
    s32 temp_v1;
    s16 phi_v0;

    this->frozenTimer += -1;
    temp_v0 = this->frozenTimer;
    phi_v0 = temp_v0;
    if (((s32) temp_v0 % 0x19) == 0) {
        EnMinislime_AddIceSmokeEffect();
        phi_v0 = this->frozenTimer;
    }
    temp_v1 = phi_v0 * 0xA;
    this->frozenScale = (f32) phi_v0 * 0.0025f;
    if (temp_v1 >= 0xC9) {
        this->frozenAlpha = 0xC8;
    } else {
        this->frozenAlpha = (u8) temp_v1;
    }
    this = this;
    func_800B9010((Actor *) this, 0x2144U);
    if (this->frozenTimer == 0) {
        EnMinislime_SetupIdle(this);
    }
}

void EnMinislime_SetupGrowAndShrink(EnMinislime *this) {
    EnMinislime *temp_a2;

    temp_a2 = this;
    temp_a2->collider.base.ocFlags1 |= 1;
    temp_a2->collider.base.acFlags |= 1;
    temp_a2->collider.base.atFlags |= 1;
    temp_a2->actor.shape.rot.x = 0;
    temp_a2->actor.shape.rot.y = 0;
    temp_a2->actor.shape.rot.z = 0;
    temp_a2->actor.world.rot.x = 0;
    temp_a2->actor.speedXZ = 0.0f;
    this = temp_a2;
    Math_Vec3f_Copy((Vec3f *) &temp_a2->actor.home, (Vec3f *) &temp_a2->actor.world);
    this->frozenTimer = 0x2A;
    this->actor.scale.x = 0.19f;
    this->actor.scale.z = 0.19f;
    this->actor.scale.y = 0.044999998f;
    Audio_PlayActorSound2((Actor *) this, 0x38DAU);
    this->actionFunc = EnMinislime_GrowAndShrink;
}

void EnMinislime_GrowAndShrink(EnMinislime *this, GlobalContext *globalCtx) {
    f32 sp1C;
    f32 temp_f2;
    s16 temp_v0;

    this->frozenTimer += -1;
    temp_v0 = this->frozenTimer;
    sp1C = (f32) ((s32) temp_v0 / 6) + 1.0f;
    temp_f2 = ((cos_rad((f32) temp_v0 * 1.0471976f) * (sp1C * 0.06666667f)) + 1.5f) * 0.1f;
    this->actor.scale.x = temp_f2;
    this->actor.scale.z = temp_f2;
    this->actor.scale.y = ((sin_rad((f32) this->frozenTimer * 1.0471976f) * (sp1C * 0.05f)) + 0.75f) * 0.1f;
    if (this->actor.params == 0xA) {
        EnMinislime_SetupMoveToGekko(this);
        return;
    }
    if ((this->actor.xzDistToPlayer < 150.0f) && ((s32) this->frozenTimer < 0x26)) {
        EnMinislime_SetupBounce(this);
        return;
    }
    if (this->frozenTimer == 0) {
        EnMinislime_SetupIdle(this);
    }
}

void EnMinislime_SetupIdle(EnMinislime *this) {
    this->frozenTimer = 0x14;
    this->collider.base.atFlags |= 1;
    this->collider.base.acFlags |= 1;
    this->actor.params = 3;
    this->actionFunc = EnMinislime_Idle;
}

void EnMinislime_Idle(EnMinislime *this, GlobalContext *globalCtx) {
    PosRot *sp20;
    PosRot *temp_a1;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;
    s32 temp_cond;

    this->frozenTimer += -1;
    temp_f0 = sin_rad((f32) this->frozenTimer * 0.31415927f);
    temp_f12 = temp_f0;
    temp_f2 = temp_f0 * 1.5f;
    temp_cond = temp_f2 < 0.0f;
    this->actor.speedXZ = temp_f2;
    if (temp_cond) {
        this->actor.speedXZ = 0.0f;
    } else {
        this->actor.speedXZ = this->actor.speedXZ;
    }
    Math_StepToF((f32 *) &this->actor.scale, ((0.14f * temp_f12) + 1.5f) * 0.1f, 0.010000001f);
    Math_StepToF(&this->actor.scale.y, ((cos_rad((f32) this->frozenTimer * 0.31415927f) * 0.07f) + 0.75f) * 0.1f, 0.010000001f);
    Math_StepToF(&this->actor.scale.z, 0.3f - this->actor.scale.x, 0.010000001f);
    if (this->frozenTimer == 0) {
        temp_a1 = &this->actor.home;
        if (this->actor.xzDistToPlayer < 300.0f) {
            this->actor.world.rot.y = this->actor.yawTowardsPlayer;
        } else {
            sp20 = temp_a1;
            if (Actor_XZDistanceToPoint((Actor *) this, (Vec3f *) temp_a1) < 200.0f) {
                this->actor.world.rot.y = Actor_YawToPoint((Actor *) this, (Vec3f *) temp_a1);
            } else {
                this->actor.world.rot.y += Rand_Next() >> 0x13;
            }
        }
        this->frozenTimer = 0x14;
    }
    if (this->actor.params == 0xA) {
        EnMinislime_SetupMoveToGekko(this);
        return;
    }
    if (this->actor.xzDistToPlayer < 150.0f) {
        EnMinislime_SetupBounce(this);
    }
}

void EnMinislime_SetupBounce(EnMinislime *this) {
    this->actor.speedXZ = 0.0f;
    if (EnMinislime_GrowAndShrink == this->actionFunc) {
        this->frozenTimer = 1;
    } else {
        this->frozenTimer = 4;
    }
    Audio_PlayActorSound2((Actor *) this, 0x38D9U);
    this->actionFunc = EnMinislime_Bounce;
}

void EnMinislime_Bounce(EnMinislime *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    if (this->actor.params == 0xA) {
        EnMinislime_SetupMoveToGekko(this);
        return;
    }
    temp_v0 = this->frozenTimer;
    if ((s32) temp_v0 > 0) {
        this->frozenTimer = temp_v0 - 1;
        if (this->frozenTimer == 0) {
            this->actor.world.rot.y = this->actor.yawTowardsPlayer;
            this->actor.gravity = -2.0f;
            this->actor.speedXZ = 1.0f;
            this->actor.velocity.y = 12.0f;
            this->actor.shape.rot.y = this->actor.world.rot.y;
        }
        Math_StepToF((f32 *) &this->actor.scale, 0.17999999f, 0.010000001f);
        Math_StepToF(&this->actor.scale.y, 0.05f, 0.010000001f);
        goto block_10;
    }
    if (this->actor.velocity.y > 0.0f) {
        Math_StepToF((f32 *) &this->actor.scale, 0.095f, 0.020000001f);
        Math_StepToF(&this->actor.scale.y, 0.10700001f, 0.020000001f);
        goto block_10;
    }
    Math_StepToF((f32 *) &this->actor.scale, 0.17999999f, 0.003f);
    Math_StepToF(&this->actor.scale.y, 0.05f, 0.003f);
    if ((this->actor.bgCheckFlags & 1) != 0) {
        EnMinislime_SetupGrowAndShrink(this);
        return;
    }
block_10:
    this->actor.scale.z = this->actor.scale.x;
}

void EnMinislime_SetupMoveToBigslime(Actor *arg0) {
    u32 temp_v0;

    arg0->gravity = 0.0f;
    arg0->speedXZ = 15.0f;
    arg0->shape.rot.x = Actor_PitchToPoint(arg0, arg0->parent + 8);
    arg0->shape.rot.y = Actor_YawToPoint(arg0, (Vec3f *) &arg0->parent->home);
    arg0->world.rot.x = (s16) -(s32) arg0->shape.rot.x;
    arg0->unk_170 = (u8) (arg0->unk_170 & 0xFFFE);
    arg0->unk_171 = (u8) (arg0->unk_171 & 0xFFFE);
    arg0->unk_172 = (u8) (arg0->unk_172 & 0xFFFE);
    arg0->scale.x = 0.095f;
    arg0->scale.y = 0.095f;
    arg0->world.rot.y = arg0->shape.rot.y;
    arg0->scale.z = 0.15f;
    if ((s32) arg0->unk_148 >= 0x15) {
        EnMinislime_AddIceShardEffect(arg0);
    }
    temp_v0 = arg0->flags;
    arg0->unk_148 = 0U;
    if ((temp_v0 & 0x2000) == 0x2000) {
        arg0->flags = temp_v0 & ~0x2000;
    }
    arg0->unk_144 = EnMinislime_MoveToBigslime;
}

void EnMinislime_MoveToBigslime(EnMinislime *this, GlobalContext *globalCtx) {
    if (this->actor.params == 0) {
        EnMinislime_SetupDisappear(this);
        return;
    }
    if ((this->actor.scale.x > 0.0f) && (this->actor.world.pos.y > -190.0f)) {
        this->actor.params = 5;
        this->actor.speedXZ = 0.0f;
        Actor_SetScale((Actor *) this, 0.0f);
    }
}

void EnMinislime_SetupKnockback(Actor *arg0) {
    arg0->unk_171 = (u8) (arg0->unk_171 & 0xFFFE);
    arg0->unk_172 = (u8) (arg0->unk_172 | 1);
    arg0->unk_14A = 0x1E;
    arg0->speedXZ = 20.0f;
    func_800BE504(arg0, arg0 + 0x160);
    arg0->unk_144 = EnMinislime_Knockback;
}

void EnMinislime_Knockback(EnMinislime *this, GlobalContext *globalCtx) {
    f32 sp2C;
    f32 sp24;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;

    this->frozenTimer += -1;
    Math_StepToF(&this->actor.speedXZ, 0.0f, 1.0f);
    temp_f2 = (f32) this->frozenTimer;
    sp2C = sqrtf(temp_f2);
    temp_f14 = 0.05f * sp2C;
    temp_f2_2 = ((cos_rad(temp_f2 * 1.0471976f) * temp_f14) + 1.0f) * 0.15f;
    this->actor.scale.x = temp_f2_2;
    this->actor.scale.z = temp_f2_2;
    if (this->frozenTimer == 0xF) {
        this->collider.base.acFlags |= 1;
    }
    sp24 = temp_f14;
    this->actor.scale.y = ((sin_rad((f32) this->frozenTimer * 1.0471976f) * temp_f14) + 1.0f) * 0.075f;
    if (this->actor.params == 0xA) {
        EnMinislime_SetupMoveToGekko(this);
        return;
    }
    if (this->frozenTimer == 0) {
        EnMinislime_SetupIdle(this);
    }
}

void EnMinislime_SetupDefeatIdle(EnMinislime *arg0) {
    s32 temp_v0;

    arg0->actor.params = 0;
    arg0->frozenTimer = 0x14;
    arg0->collider.base.atFlags &= -4;
    arg0->collider.base.acFlags &= -4;
    arg0->actor.speedXZ = 0.0f;
    if ((s32) arg0->frozenAlpha >= 0x15) {
        EnMinislime_AddIceShardEffect();
    }
    temp_v0 = arg0->actor.flags;
    arg0->frozenAlpha = 0;
    if ((temp_v0 & 0x2000) == 0x2000) {
        arg0->actor.flags = temp_v0 & ~0x2000;
    }
    arg0->actor.shape.rot.x = 0;
    arg0->actor.shape.rot.z = 0;
    arg0->actionFunc = EnMinislime_DefeatIdle;
}

void EnMinislime_DefeatIdle(EnMinislime *this, GlobalContext *globalCtx) {
    this->frozenTimer += -1;
    Math_StepToF((f32 *) &this->actor.scale, ((0.14f * sin_rad((f32) this->frozenTimer * 0.31415927f)) + 1.5f) * 0.1f, 0.010000001f);
    Math_StepToF(&this->actor.scale.y, ((cos_rad((f32) this->frozenTimer * 0.31415927f) * 0.07f) + 0.75f) * 0.1f, 0.010000001f);
    Math_StepToF(&this->actor.scale.z, 0.3f - this->actor.scale.x, 0.010000001f);
    if (this->frozenTimer == 0) {
        this->frozenTimer = 0x14;
    }
    if (this->actor.params == 8) {
        EnMinislime_SetupDefeatMelt(this, globalCtx);
    }
}

void EnMinislime_SetupDefeatMelt(EnMinislime *this, GlobalContext *globalCtx) {
    this->actor.gravity = 0.0f;
    this->actor.velocity.y = -50.0f;
    this->frozenTimer = (s16) (s32) Rand_ZeroFloat(25.0f);
    EnMinislime_AddIceSmokeEffect(this, globalCtx);
    this->actor.params = 0;
    this->actionFunc = EnMinislime_DefeatMelt;
}

void EnMinislime_DefeatMelt(EnMinislime *this, GlobalContext *globalCtx) {
    s32 temp_v0;

    this->frozenTimer += 1;
    if ((((s32) this->frozenTimer % 0x19) == 0) && ((s32) this->actor.shape.shadowAlpha >= 0x1A)) {
        EnMinislime_AddIceSmokeEffect(this);
    }
    func_800B9010((Actor *) this, 0x2144U);
    if (Math_StepToF(&this->actor.scale.y, 0.001f, 0.00075f) != 0) {
        temp_v0 = this->actor.shape.shadowAlpha - 4;
        if (temp_v0 <= 0) {
            this->actor.shape.shadowAlpha = 0;
            EnMinislime_SetupDisappear(this);
        } else {
            this->actor.shape.shadowAlpha = (u8) temp_v0;
        }
    }
    Math_StepToF((f32 *) &this->actor.scale, 0.25f, 0.001f);
    this->actor.scale.z = this->actor.scale.x;
}

void EnMinislime_SetupDespawn(EnMinislime *this) {
    this->actionFunc = EnMinislime_Despawn;
}

void EnMinislime_Despawn(EnMinislime *this, GlobalContext *globalCtx) {
    Actor_MarkForDeath((Actor *) this);
}

void EnMinislime_SetupMoveToGekko(EnMinislime *this) {
    u32 temp_v0;

    temp_v0 = this->actor.flags;
    this->actor.speedXZ = 0.0f;
    this->actor.gravity = 0.0f;
    this->actor.velocity.y = 0.0f;
    this->collider.base.acFlags &= -2;
    this->collider.base.ocFlags1 &= -2;
    if ((temp_v0 & 0x2000) == 0x2000) {
        this->actor.flags = temp_v0 & ~0x2000;
    }
    this->actionFunc = EnMinislime_MoveToGekko;
}

void EnMinislime_MoveToGekko(EnMinislime *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    Math_StepToF((f32 *) &this->actor.world, this->actor.parent->world.pos.x, 10.0f);
    Math_StepToF(&this->actor.world.pos.z, this->actor.parent->world.pos.z, 10.0f);
    Math_StepToF(&this->actor.world.pos.y, this->actor.parent->world.pos.y + 80.0f, 10.0f);
    Math_StepToF((f32 *) &this->actor.scale, 0.15f, 0.0075000003f);
    Math_StepToF(&this->actor.scale.y, 0.075f, 0.0037500001f);
    Math_StepToF(&this->actor.scale.z, 0.15f, 0.0075000003f);
    temp_v0 = this->actor.params;
    if (temp_v0 == 0xB) {
        EnMinislime_SetupGekkoThrow(this);
        return;
    }
    if (temp_v0 == 3) {
        EnMinislime_SetupFall(this, globalCtx);
    }
}

void EnMinislime_SetupGekkoThrow(EnMinislime *this) {
    f32 temp_f0;
    f32 phi_f2;

    temp_f0 = this->actor.xzDistToPlayer;
    this->collider.base.acFlags |= 1;
    this->collider.base.ocFlags1 |= 1;
    if (temp_f0 < 200.0f) {
        phi_f2 = 200.0f;
    } else {
        phi_f2 = temp_f0;
    }
    this->actor.speedXZ = 17.5f;
    this->actor.world.rot.y = this->actor.yawTowardsPlayer;
    this->actor.gravity = -1.0f;
    this->actor.bgCheckFlags &= 0xFFFE;
    this->frozenTimer = 0xA;
    this->actionFunc = EnMinislime_GekkoThrow;
    this->actor.velocity.y = ((phi_f2 - 200.0f) * 0.01f) + 3.0f;
}

void EnMinislime_GekkoThrow(EnMinislime *this, GlobalContext *globalCtx) {
    this->frozenTimer += -1;
    this->actor.scale.x = ((0.3f * sin_rad((f32) this->frozenTimer * 0.62831855f)) + 1.5f) * 0.1f;
    this->actor.scale.y = ((cos_rad((f32) this->frozenTimer * 0.62831855f) * 0.2f) + 0.75f) * 0.1f;
    this->actor.scale.z = 0.3f - this->actor.scale.x;
    if (this->frozenTimer == 0) {
        this->frozenTimer = 0xA;
    }
    if ((this->actor.bgCheckFlags & 1) != 0) {
        EnMinislime_SetupGrowAndShrink(this);
    }
}

void EnMinislime_ApplyDamage(EnMinislime *arg0) {
    u8 temp_v0;
    u8 temp_v0_2;
    u8 temp_v0_3;

    temp_v0 = arg0->collider.base.acFlags;
    if ((temp_v0 & 2) != 0) {
        arg0->collider.base.acFlags = temp_v0 & 0xFFFD;
        if (EnMinislime_IceArrowDamage == arg0->actionFunc) {
            temp_v0_2 = arg0->actor.colChkInfo.damageEffect;
            if (temp_v0_2 != 0xE) {
                if (temp_v0_2 == 0xF) {
                    EnMinislime_AddIceShardEffect();
                    EnMinislime_SetupIdle(arg0);
                    return;
                }
                if (temp_v0_2 == 2) {
                    EnMinislime_SetupFireArrowDamage();
                    return;
                }
                /* Duplicate return node #11. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #11. Try simplifying control flow for better match */
            return;
        }
        temp_v0_3 = arg0->actor.colChkInfo.damageEffect;
        if (temp_v0_3 != 0xE) {
            if (temp_v0_3 == 3) {
                EnMinislime_SetupIceArrowDamage();
                return;
            }
            EnMinislime_SetupKnockback();
            /* Duplicate return node #11. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
    }
}

void EnMinislime_Update(Actor *thisx, GlobalContext *globalCtx) {
    f32 sp38;
    f32 sp34;
    f32 sp30;
    ColliderCylinder *sp2C;
    Actor *temp_v0_5;
    ColliderCylinder *temp_a1;
    f32 *temp_a1_2;
    s16 temp_v0;
    s16 temp_v0_4;
    u8 temp_v0_2;
    void (*temp_v0_3)(EnMinislime *, GlobalContext *);
    EnMinislime *this = (EnMinislime *) thisx;

    temp_v0 = this->actor.params;
    if ((temp_v0 == 7) && ((this->actor.bgCheckFlags & 1) != 0)) {
        EnMinislime_SetupDefeatIdle(this);
        goto block_11;
    }
    if (temp_v0 == 8) {
        EnMinislime_SetupDefeatMelt(this, globalCtx);
        goto block_11;
    }
    if ((temp_v0 == 4) && (EnMinislime_MoveToBigslime != this->actionFunc)) {
        EnMinislime_SetupMoveToBigslime((Actor *) this);
        goto block_11;
    }
    if ((this->actor.flags & 0x2000) == 0x2000) {
        this->collider.base.acFlags &= 0xFFFD;
        return;
    }
    EnMinislime_ApplyDamage(this);
block_11:
    temp_v0_2 = this->collider.base.atFlags;
    if ((temp_v0_2 & 2) != 0) {
        this->attackTimer = 0xA;
        this->collider.base.atFlags = temp_v0_2 & 0xFFFD;
    }
    this->actionFunc(this, globalCtx);
    temp_v0_3 = this->actionFunc;
    if ((EnMinislime_Disappear != temp_v0_3) && (EnMinislime_Despawn != temp_v0_3)) {
        if (EnMinislime_MoveToBigslime == temp_v0_3) {
            Actor_SetVelocityAndMoveXYRotation((Actor *) this);
        } else {
            Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
        }
        EnMinislime_CheckBackgroundCollision(this);
        temp_a1 = &this->collider;
        sp2C = temp_a1;
        Collider_UpdateCylinder((Actor *) this, temp_a1);
        this->collider.dim.radius = (s16) (s32) (this->actor.scale.x * 360.0f);
        this->collider.dim.height = (s16) (s32) (this->actor.scale.y * 800.0f);
        this->collider.dim.yShift = (s16) (s32) (this->actor.scale.y * -400.0f);
        if ((this->attackTimer == 0) && ((this->collider.base.atFlags & 1) != 0)) {
            CollisionCheck_SetAT(globalCtx, &globalCtx->colChkCtx, (Collider *) sp2C);
        }
        if ((this->collider.base.acFlags & 1) != 0) {
            CollisionCheck_SetAC(globalCtx, &globalCtx->colChkCtx, (Collider *) sp2C);
        }
        if ((this->collider.base.ocFlags1 & 1) != 0) {
            CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) sp2C);
        }
        temp_v0_4 = this->attackTimer;
        if (temp_v0_4 != 0) {
            this->attackTimer = temp_v0_4 - 1;
        }
        if ((this->actor.bgCheckFlags & 2) != 0) {
            temp_v0_5 = globalCtx->actorCtx.actorList[2].first;
            temp_a1_2 = &sp30;
            sp30 = this->actor.world.pos.x;
            sp38 = this->actor.world.pos.z;
            sp34 = temp_v0_5->world.pos.y + temp_v0_5->yDistToWater;
            EffectSsGRipple_Spawn(globalCtx, (Vec3f *) temp_a1_2, 0x1F4, 0x2D0, (s16) 0);
        }
    }
}
