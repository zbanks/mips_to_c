struct _mips2c_stack_EnInvadepoh_Destroy {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_GetTotalPathDistance {
    /* 0x00 */ char pad_0[0x48];
    /* 0x48 */ ? sp48;                              /* inferred */
    /* 0x48 */ char pad_48[0xC];
    /* 0x54 */ ? sp54;                              /* inferred */
    /* 0x54 */ char pad_54[0x14];
};                                                  /* size = 0x68 */

struct _mips2c_stack_EnInvadepoh_Init {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_InitAlien {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ ColliderCylinder *sp20;              /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_EnInvadepoh_InitChildCow {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_InitCremia {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ ColliderCylinder *sp20;              /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_EnInvadepoh_InitDog {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ ColliderCylinder *sp20;              /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_EnInvadepoh_InitParentCow {
    /* 0x00 */ char pad_0[0x40];
};                                                  /* size = 0x40 */

struct _mips2c_stack_EnInvadepoh_InitRomani {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ ColliderCylinder *sp24;              /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_EnInvadepoh_SetPathPointToWorldPos {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_SetSysMatrix {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_SetTextID {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_EnInvadepoh_Update {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B439B0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B43A24 {};              /* size 0x0 */

struct _mips2c_stack_func_80B43A74 {};              /* size 0x0 */

struct _mips2c_stack_func_80B43A9C {};              /* size 0x0 */

struct _mips2c_stack_func_80B43AB0 {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ s32 sp1C;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B43AF0 {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ s32 sp1C;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B43B80 {};              /* size 0x0 */

struct _mips2c_stack_func_80B43BC8 {
    /* 0x00 */ char pad_0[0x70];
    /* 0x70 */ f32 sp70;                            /* inferred */
    /* 0x74 */ f32 sp74;                            /* inferred */
    /* 0x78 */ f32 sp78;                            /* inferred */
    /* 0x7C */ char pad_7C[0x14];
};                                                  /* size = 0x90 */

struct _mips2c_stack_func_80B43DD4 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ ? sp24;                              /* inferred */
    /* 0x24 */ char pad_24[0xC];
    /* 0x30 */ ? sp30;                              /* inferred */
    /* 0x30 */ char pad_30[0x10];
    /* 0x40 */ Vec3s *sp40;                         /* inferred */
    /* 0x44 */ char pad_44[0x4];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B43E6C {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ ? sp2C;                              /* inferred */
    /* 0x2C */ char pad_2C[0xC];
    /* 0x38 */ ? sp38;                              /* inferred */
    /* 0x38 */ char pad_38[0x10];
    /* 0x48 */ Vec3s *sp48;                         /* inferred */
    /* 0x4C */ char pad_4C[0x4];
};                                                  /* size = 0x50 */

struct _mips2c_stack_func_80B43F0C {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ ? sp1C;                              /* inferred */
    /* 0x1C */ char pad_1C[0xC];
    /* 0x28 */ ? sp28;                              /* inferred */
    /* 0x28 */ char pad_28[0x10];
    /* 0x38 */ Vec3s *sp38;                         /* inferred */
    /* 0x3C */ char pad_3C[0x4];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B44024 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B440B8 {
    /* 0x00 */ char pad_0[0x1E];
    /* 0x1E */ s16 sp1E;                            /* inferred */
    /* 0x20 */ char pad_20[0xC];                    /* maybe part of sp1E[7]? */
    /* 0x2C */ f32 sp2C;                            /* inferred */
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ f32 sp3C;                            /* inferred */
    /* 0x40 */ f32 sp40;                            /* inferred */
    /* 0x44 */ char pad_44[0x4];
    /* 0x48 */ void *sp48;                          /* inferred */
    /* 0x4C */ char pad_4C[0x4];
};                                                  /* size = 0x50 */

struct _mips2c_stack_func_80B44234 {
    /* 0x00 */ char pad_0[0x48];
    /* 0x48 */ ? sp48;                              /* inferred */
    /* 0x48 */ char pad_48[0x18];
};                                                  /* size = 0x60 */

struct _mips2c_stack_func_80B442E4 {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ s32 sp18;                            /* inferred */
    /* 0x1C */ char pad_1C[0x4];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B443A0 {
    /* 0x00 */ char pad_0[0x64];
    /* 0x64 */ ? sp64;                              /* inferred */
    /* 0x64 */ char pad_64[0xC];
    /* 0x70 */ ? sp70;                              /* inferred */
    /* 0x70 */ char pad_70[0x18];
};                                                  /* size = 0x88 */

struct _mips2c_stack_func_80B444BC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B444F4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B44514 {};              /* size 0x0 */

struct _mips2c_stack_func_80B44540 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B44570 {};              /* size 0x0 */

struct _mips2c_stack_func_80B44620 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B44640 {};              /* size 0x0 */

struct _mips2c_stack_func_80B44664 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B44690 {};              /* size 0x0 */

struct _mips2c_stack_func_80B446D0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B44700 {};              /* size 0x0 */

struct _mips2c_stack_func_80B447C0 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ Vec3f *sp24;                         /* inferred */
    /* 0x28 */ char pad_28[0x4];
    /* 0x2C */ f32 sp2C;                            /* inferred */
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ char pad_38[0x4];
    /* 0x3C */ f32 sp3C;                            /* inferred */
    /* 0x40 */ f32 sp40;                            /* inferred */
    /* 0x44 */ f32 sp44;                            /* inferred */
    /* 0x48 */ f32 sp48;                            /* inferred */
    /* 0x4C */ f32 sp4C;                            /* inferred */
    /* 0x50 */ f32 sp50;                            /* inferred */
    /* 0x54 */ f32 sp54;                            /* inferred */
    /* 0x58 */ f32 sp58;                            /* inferred */
    /* 0x5C */ char pad_5C[0x4];
    /* 0x60 */ Vec3s *sp60;                         /* inferred */
    /* 0x64 */ char pad_64[0x4];
};                                                  /* size = 0x68 */

struct _mips2c_stack_func_80B44A90 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B44B78 {};              /* size 0x0 */

struct _mips2c_stack_func_80B44B84 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B44C24 {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ f32 sp18;                            /* inferred */
    /* 0x1C */ char pad_1C[0x4];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B44C80 {
    /* 0x00 */ char pad_0[0x40];
    /* 0x40 */ s32 sp40;                            /* inferred */
    /* 0x44 */ f32 sp44;                            /* inferred */
    /* 0x48 */ char pad_48[0xC];                    /* maybe part of sp44[4]? */
    /* 0x54 */ f32 sp54;                            /* inferred */
    /* 0x58 */ char pad_58[0x4];
    /* 0x5C */ f32 sp5C;                            /* inferred */
    /* 0x60 */ f32 sp60;                            /* inferred */
    /* 0x64 */ f32 sp64;                            /* inferred */
    /* 0x68 */ f32 sp68;                            /* inferred */
    /* 0x6C */ f32 sp6C;                            /* inferred */
    /* 0x70 */ f32 sp70;                            /* inferred */
    /* 0x74 */ f32 sp74;                            /* inferred */
    /* 0x78 */ char pad_78[0x20];
};                                                  /* size = 0x98 */

struct _mips2c_stack_func_80B44E90 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B44EFC {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ f32 sp18;                            /* inferred */
    /* 0x1C */ char pad_1C[0x4];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B44F58 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B44FEC {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B45080 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B450C0 {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ f32 sp18;                            /* inferred */
    /* 0x1C */ f32 sp1C;                            /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4516C {};              /* size 0x0 */

struct _mips2c_stack_func_80B451A0 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ s32 sp2C;                            /* inferred */
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B452EC {
    /* 0x00 */ char pad_0[0x50];
};                                                  /* size = 0x50 */

struct _mips2c_stack_func_80B453F4 {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B45460 {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B454BC {
    /* 0x00 */ char pad_0[0x30];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B45550 {
    /* 0x00 */ char pad_0[0x34];
    /* 0x34 */ s32 sp34;                            /* inferred */
    /* 0x38 */ char pad_38[0x8];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B45648 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B456A8 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s32 sp24;                            /* inferred */
    /* 0x28 */ char pad_28[0x8];                    /* maybe part of sp24[3]? */
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ f32 sp3C;                            /* inferred */
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B457A0 {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B458D8 {};              /* size 0x0 */

struct _mips2c_stack_func_80B45980 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B459E8 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B45A4C {};              /* size 0x0 */

struct _mips2c_stack_func_80B45A94 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B45B1C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B45BB8 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B45C04 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B45CE0 {
    /* 0x00 */ char pad_0[0x34];
    /* 0x34 */ s16 sp34;                            /* inferred */
    /* 0x36 */ s16 sp36;                            /* inferred */
    /* 0x38 */ s16 sp38;                            /* inferred */
    /* 0x3A */ char pad_3A[0x2];
    /* 0x3C */ ? sp3C;                              /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B45EC8 {
    /* 0x00 */ char pad_0[0x90];
    /* 0x90 */ f32 sp90;                            /* inferred */
    /* 0x94 */ f32 sp94;                            /* inferred */
    /* 0x98 */ f32 sp98;                            /* inferred */
    /* 0x9C */ f32 sp9C;                            /* inferred */
    /* 0xA0 */ f32 spA0;                            /* inferred */
    /* 0xA4 */ f32 spA4;                            /* inferred */
    /* 0xA8 */ f32 spA8;                            /* inferred */
    /* 0xAC */ f32 spAC;                            /* inferred */
    /* 0xB0 */ f32 spB0;                            /* inferred */
    /* 0xB4 */ char pad_B4[0x4];
};                                                  /* size = 0xB8 */

struct _mips2c_stack_func_80B46118 {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ ? *sp1C;                             /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B46184 {};              /* size 0x0 */

struct _mips2c_stack_func_80B461DC {
    /* 0x00 */ char pad_0[0x30];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4627C {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B468B4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46BB0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46BC0 {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ s32 sp18;                            /* inferred */
    /* 0x1C */ char pad_1C[0x4];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B46C08 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46C34 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46C50 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46C7C {};              /* size 0x0 */

struct _mips2c_stack_func_80B46C94 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46CC0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46CF4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46D28 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46DA8 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46DC8 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46E20 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46E44 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B46EC0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46EE8 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B46F88 {};              /* size 0x0 */

struct _mips2c_stack_func_80B46FA8 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B47064 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47084 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B470E0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47108 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B471C0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B471E0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B47248 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47268 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47278 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47298 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B47304 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47324 {};              /* size 0x0 */

struct _mips2c_stack_func_80B47380 {};              /* size 0x0 */

struct _mips2c_stack_func_80B473E4 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B47478 {};              /* size 0x0 */

struct _mips2c_stack_func_80B474DC {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B47568 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B47600 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4770C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B477B4 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B47830 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B478F4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B47938 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B479E8 {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B47BAC {
    /* 0x00 */ char pad_0[0x30];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B47D30 {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ s16 *sp20;                           /* inferred */
    /* 0x24 */ char pad_24[0x14];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B47FA8 {
    /* 0x00 */ char pad_0[0x34];
    /* 0x34 */ Actor *sp34;                         /* inferred */
    /* 0x38 */ char pad_38[0x8];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B48060 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ ActorShape *sp24;                    /* inferred */
    /* 0x28 */ ? sp28;                              /* inferred */
    /* 0x28 */ char pad_28[0x44];
    /* 0x6C */ s32 sp6C;                            /* inferred */
    /* 0x70 */ char pad_70[0x8];
};                                                  /* size = 0x78 */

struct _mips2c_stack_func_80B481C4 {
    /* 0x00 */ char pad_0[0x34];
    /* 0x34 */ Actor *sp34;                         /* inferred */
    /* 0x38 */ char pad_38[0x8];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B4827C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B482D4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48324 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48374 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B483CC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4843C {
    /* 0x00 */ char pad_0[0x30];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B484EC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48588 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48610 {};              /* size 0x0 */

struct _mips2c_stack_func_80B48620 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ Actor *sp38;                         /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4873C {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ f32 *sp20;                           /* inferred */
    /* 0x24 */ char pad_24[0xC];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B487B4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48848 {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ SkelAnime *sp20;                     /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B48948 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ AlienBehaviorInfo *sp24;             /* inferred */
    /* 0x28 */ f32 sp28;                            /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B48AD4 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B48DE4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B48E4C {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B48FB0 {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B490F0 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s16 *sp24;                           /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B491EC {};              /* size 0x0 */

struct _mips2c_stack_func_80B49228 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ f32 sp28;                            /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B492FC {};              /* size 0x0 */

struct _mips2c_stack_func_80B4934C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B49404 {};              /* size 0x0 */

struct _mips2c_stack_func_80B49454 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ PosRot *sp28;                        /* inferred */
    /* 0x2C */ char pad_2C[0x4];
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0x4];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B49628 {};              /* size 0x0 */

struct _mips2c_stack_func_80B49670 {
    /* 0x00 */ char pad_0[0x30];
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0x4];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B497A4 {};              /* size 0x0 */

struct _mips2c_stack_func_80B497EC {
    /* 0x00 */ char pad_0[0x30];
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0x4];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B49904 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4994C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B499BC {};              /* size 0x0 */

struct _mips2c_stack_func_80B49A00 {
    /* 0x00 */ char pad_0[0x30];
    /* 0x30 */ f32 sp30;                            /* inferred */
    /* 0x34 */ f32 sp34;                            /* inferred */
    /* 0x38 */ f32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0x4];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B49B1C {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B49BD0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B49C38 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ SkelAnime *sp24;                     /* inferred */
    /* 0x28 */ char pad_28[0x8];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B49DA0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B49DFC {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B49F88 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4A168 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A1B8 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s16 *sp24;                           /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4A2C0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A350 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ void *sp2C;                          /* inferred */
    /* 0x30 */ AlienBehaviorInfo *sp30;             /* inferred */
    /* 0x34 */ char pad_34[0xE];                    /* maybe part of sp30[4]? */
    /* 0x42 */ s16 sp42;                            /* inferred */
    /* 0x44 */ ? sp44;                              /* inferred */
    /* 0x44 */ char pad_44[0x14];
};                                                  /* size = 0x58 */

struct _mips2c_stack_func_80B4A570 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A5E4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A614 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A67C {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ SkelAnime *sp20;                     /* inferred */
    /* 0x24 */ char pad_24[0x4];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B4A7C0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4A81C {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4A9C8 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4AB8C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4ABDC {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s16 *sp24;                           /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4ACDC {};              /* size 0x0 */

struct _mips2c_stack_func_80B4ACF0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4AD3C {};              /* size 0x0 */

struct _mips2c_stack_func_80B4AD60 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4ADB8 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4ADCC {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4AEC0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4AEDC {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B4AF80 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4AF94 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4B024 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4B048 {
    /* 0x00 */ char pad_0[0x1C];
    /* 0x1C */ MessageContext *sp1C;                /* inferred */
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4B0C4 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ Actor *sp38;                         /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4B218 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ s16 *sp28;                           /* inferred */
    /* 0x2C */ char pad_2C[0x8];                    /* maybe part of sp28[3]? */
    /* 0x34 */ Actor *sp34;                         /* inferred */
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4B3DC {
    /* 0x00 */ char pad_0[0x18];
    /* 0x18 */ SkelAnime *sp18;                     /* inferred */
    /* 0x1C */ char pad_1C[0x4];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4B430 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4B484 {
    /* 0x00 */ char pad_0[0x20];
};                                                  /* size = 0x20 */

struct _mips2c_stack_func_80B4B510 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4B564 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ ? sp28;                              /* inferred */
    /* 0x28 */ char pad_28[0x10];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4B724 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4B768 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ SkelAnime *sp2C;                     /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4B820 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4B864 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4B8BC {
    /* 0x00 */ char pad_0[0x38];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4BA30 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4BA84 {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ s16 *sp20;                           /* inferred */
    /* 0x24 */ char pad_24[0x8];                    /* maybe part of sp20[3]? */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x4];
    /* 0x34 */ s32 sp34;                            /* inferred */
    /* 0x38 */ char pad_38[0x8];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B4BBE0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4BC4C {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ PosRot *sp2C;                        /* inferred */
    /* 0x30 */ Vec3f *sp30;                         /* inferred */
    /* 0x34 */ s16 *sp34;                           /* inferred */
    /* 0x38 */ char pad_38[0x8];                    /* maybe part of sp34[3]? */
    /* 0x40 */ s16 sp40;                            /* inferred */
    /* 0x42 */ s16 sp42;                            /* inferred */
    /* 0x44 */ char pad_44[0x4];                    /* maybe part of sp42[3]? */
    /* 0x48 */ s32 sp48;                            /* inferred */
    /* 0x4C */ char pad_4C[0x4];
    /* 0x50 */ EnInvadepoh *sp50;                   /* inferred */
    /* 0x54 */ char pad_54[0x4];
};                                                  /* size = 0x58 */

struct _mips2c_stack_func_80B4BFFC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4C058 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4C1BC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4C218 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4C3A0 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4C568 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4C5C0 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s16 *sp24;                           /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4C6C8 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4C730 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0xA];                    /* maybe part of sp2C[3]? */
    /* 0x3A */ s16 sp3A;                            /* inferred */
    /* 0x3C */ char pad_3C[0x4];                    /* maybe part of sp3A[3]? */
    /* 0x40 */ ? sp40;                              /* inferred */
    /* 0x40 */ char pad_40[0xC];
    /* 0x4C */ ? sp4C;                              /* inferred */
    /* 0x4C */ char pad_4C[0x14];
    /* 0x60 */ s32 sp60;                            /* inferred */
    /* 0x64 */ char pad_64[0x4];
    /* 0x68 */ EnInvadepoh *sp68;                   /* inferred */
    /* 0x6C */ char pad_6C[0x4];
};                                                  /* size = 0x70 */

struct _mips2c_stack_func_80B4CAB0 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4CB0C {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4CC70 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4CCCC {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ Actor *sp28;                         /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4CE54 {
    /* 0x00 */ char pad_0[0x38];
    /* 0x38 */ s32 sp38;                            /* inferred */
    /* 0x3C */ char pad_3C[0xC];
};                                                  /* size = 0x48 */

struct _mips2c_stack_func_80B4CFFC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4D054 {
    /* 0x00 */ char pad_0[0x24];
    /* 0x24 */ s16 *sp24;                           /* inferred */
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4D15C {
    /* 0x00 */ char pad_0[0x20];
    /* 0x20 */ void *sp20;                          /* inferred */
    /* 0x24 */ char pad_24[0x4];
    /* 0x28 */ s32 sp28;                            /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4D290 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ f32 sp28;                            /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4D3E4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4D480 {
    /* 0x00 */ char pad_0[0x2C];
    /* 0x2C */ s32 sp2C;                            /* inferred */
    /* 0x30 */ char pad_30[0x8];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4D670 {
    /* 0x00 */ char pad_0[0x34];
    /* 0x34 */ s32 sp34;                            /* inferred */
    /* 0x38 */ char pad_38[0x8];
};                                                  /* size = 0x40 */

struct _mips2c_stack_func_80B4D760 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4D7B8 {
    /* 0x00 */ char pad_0[0x68];
};                                                  /* size = 0x68 */

struct _mips2c_stack_func_80B4D9B4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4D9D8 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4D9F4 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4DB14 {
    /* 0x00 */ char pad_0[0x4C];
    /* 0x4C */ ? *sp4C;                             /* inferred */
    /* 0x50 */ char pad_50[0x4];
    /* 0x54 */ Gfx *sp54;                           /* inferred */
    /* 0x58 */ char pad_58[0x14];                   /* maybe part of sp54[6]? */
    /* 0x6C */ GraphicsContext *sp6C;               /* inferred */
    /* 0x70 */ char pad_70[0x4];
    /* 0x74 */ f32 sp74;                            /* inferred */
    /* 0x78 */ f32 sp78;                            /* inferred */
    /* 0x7C */ f32 sp7C;                            /* inferred */
    /* 0x80 */ f32 sp80;                            /* inferred */
    /* 0x84 */ f32 sp84;                            /* inferred */
    /* 0x88 */ f32 sp88;                            /* inferred */
    /* 0x8C */ char pad_8C[0x2C];                   /* maybe part of sp88[12]? */
    /* 0xB8 */ GraphicsContext *spB8;               /* inferred */
    /* 0xBC */ Gfx *spBC;                           /* inferred */
    /* 0xC0 */ char pad_C0[0xC];                    /* maybe part of spBC[4]? */
    /* 0xCC */ GraphicsContext *spCC;               /* inferred */
    /* 0xD0 */ char pad_D0[0x8];
};                                                  /* size = 0xD8 */

struct _mips2c_stack_func_80B4E120 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4E158 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B4E1B0 {
    /* 0x00 */ char pad_0[0x28];
};                                                  /* size = 0x28 */

struct _mips2c_stack_func_80B4E200 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4E2AC {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4E324 {
    /* 0x00 */ char pad_0[0x30];
    /* 0x30 */ GraphicsContext *sp30;               /* inferred */
    /* 0x34 */ char pad_34[0x4];
};                                                  /* size = 0x38 */

struct _mips2c_stack_func_80B4E3F0 {
    /* 0x00 */ char pad_0[0x40];
    /* 0x40 */ MtxF *sp40;                          /* inferred */
    /* 0x44 */ char pad_44[0xC];                    /* maybe part of sp40[4]? */
    /* 0x50 */ Gfx *sp50;                           /* inferred */
    /* 0x54 */ char pad_54[0x4];
    /* 0x58 */ GraphicsContext *sp58;               /* inferred */
    /* 0x5C */ f32 sp5C;                            /* inferred */
    /* 0x60 */ f32 sp60;                            /* inferred */
    /* 0x64 */ f32 sp64;                            /* inferred */
    /* 0x68 */ char pad_68[0x8];
};                                                  /* size = 0x70 */

struct _mips2c_stack_func_80B4E5B0 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4E61C {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4E660 {
    /* 0x00 */ char pad_0[0x28];
    /* 0x28 */ GraphicsContext *sp28;               /* inferred */
    /* 0x2C */ char pad_2C[0x4];
};                                                  /* size = 0x30 */

struct _mips2c_stack_func_80B4E6E4 {};              /* size 0x0 */

struct _mips2c_stack_func_80B4E784 {
    /* 0x00 */ char pad_0[0x18];
};                                                  /* size = 0x18 */

struct _mips2c_stack_func_80B4E7BC {
    /* 0x00 */ char pad_0[0x30];
    /* 0x30 */ GraphicsContext *sp30;               /* inferred */
    /* 0x34 */ char pad_34[0x4];
};                                                  /* size = 0x38 */

f32 EnInvadepoh_GetTotalPathDistance(Actor *arg0);  /* static */
void EnInvadepoh_SetPathPointToWorldPos(Actor *arg0, s8 arg1); /* static */
void EnInvadepoh_SetSysMatrix(f32 *arg0);           /* static */
void EnInvadepoh_SetTextID(Actor *arg0, GlobalContext *arg1, s32 arg2, EnInvadepoh *); /* static */
void func_80B439B0(s32 arg0, s32 arg1);             /* static */
s32 func_80B43A24(s32 arg0, EnInvadepoh *);         /* static */
void func_80B43A74(s32 arg0);                       /* static */
s32 func_80B43A9C();                                /* static */
s32 func_80B43AB0();                                /* static */
void func_80B43AF0(s32 arg0);                       /* static */
s8 func_80B43B80(EnInvadepoh *arg0, EnInvadepoh *); /* static */
void func_80B43BC8(Actor *arg0, s8 *arg1, void *arg2, Actor *); /* static */
void func_80B43DD4(EnInvadepoh *arg0, s16 arg1, s16 arg2); /* static */
void func_80B43E6C(EnInvadepoh *arg0, s16 arg1, s16 arg2, s16 arg3); /* static */
void func_80B43F0C(Actor *arg0);                    /* static */
void func_80B44024(Actor *arg0, void *arg1);        /* static */
s32 func_80B440B8(Actor *arg0, f32 arg1, f32 arg2); /* static */
s8 func_80B44234(Actor *arg0, Vec3f *arg1);         /* static */
void func_80B442E4(EnInvadepoh *arg0);              /* static */
void func_80B443A0(Actor *arg0);                    /* static */
void func_80B444BC(Actor *arg0, GlobalContext *);   /* static */
void func_80B444F4(Actor *, GlobalContext *);       /* static */
void func_80B44514(EnInvadepoh *arg0);              /* static */
void func_80B44540(Actor *arg0, GlobalContext *);   /* static */
void func_80B44570(EnInvadepoh *arg0);              /* static */
void func_80B44620(Actor *, GlobalContext *);       /* static */
void func_80B44640(EnInvadepoh *arg0);              /* static */
void func_80B44664(Actor *arg0, GlobalContext *);   /* static */
void func_80B44690(EnInvadepoh *arg0);              /* static */
void func_80B446D0(Actor *arg0, GlobalContext *);   /* static */
void func_80B44700(EnInvadepoh *arg0);              /* static */
void func_80B447C0(Actor *arg0, GlobalContext *arg1); /* static */
void func_80B44A90(Actor *arg0, GlobalContext *arg1); /* static */
void func_80B44B78(EnInvadepoh *arg0);              /* static */
s32 func_80B44B84(Actor *arg0, GlobalContext *arg1, f32 arg2, f32 arg3); /* static */
void func_80B44C24(Actor *arg0, GlobalContext *arg1); /* static */
s32 func_80B44C80(Actor *arg0, GlobalContext *arg1); /* static */
void func_80B44E90(Actor *arg0, GlobalContext *arg1); /* static */
void func_80B44EFC(Actor *arg0, GlobalContext *arg1); /* static */
void func_80B44F58();                               /* static */
void func_80B44FEC();                               /* static */
void func_80B45080();                               /* static */
void func_80B451A0(EnInvadepoh *arg0, GlobalContext *arg1, s8, Path *); /* static */
void func_80B452EC(EnInvadepoh *arg0, GlobalContext *arg1); /* static */
void func_80B453F4(Actor *arg0, GlobalContext *arg1, s32 arg2); /* static */
void func_80B45460(Actor *arg0, GlobalContext *arg1, s32); /* static */
void func_80B454BC(EnInvadepoh *arg0, GlobalContext *arg1); /* static */
s32 func_80B45550(EnInvadepoh *arg0, GlobalContext *arg1, f32 arg2, s32 arg3); /* static */
void func_80B45648(EnInvadepoh *arg0);              /* static */
s32 func_80B456A8(GlobalContext *arg0, Vec3f *arg1); /* static */
void func_80B457A0(EnInvadepoh *arg0, EnInvadepoh *); /* static */
Actor *func_80B458D8();                             /* static */
s8 func_80B45980(unkstructInvadepoh1 *arg0, s32 arg1, EnInvadePohStruct *, s8); /* static */
void func_80B459E8(EnInvadePohStruct *arg0, unkstructInvadepoh4 *arg1); /* static */
void func_80B45BB8(f32 *arg0);                      /* static */
void func_80B45C04(f32 *arg0, ? *arg1, s32 arg2, ? *arg3, s32 arg4, Vec3s *arg5, s16 arg6, f32 arg7, f32 arg8, f32 arg9); /* static */
void func_80B45CE0(f32 *arg0);                      /* static */
void func_80B45EC8(EnInvadepoh *arg0, GlobalContext *arg1, s32 arg2); /* static */
? func_80B46118(Vec3f *arg0);                       /* static */
s32 func_80B461DC();                                /* static */
void func_80B47380(Actor *arg0);                    /* static */
void func_80B47478(EnInvadepoh *arg0);              /* static */
void func_80B47830(Actor *arg0);                    /* static */
void func_80B482D4(Actor *arg0);                    /* static */
void func_80B487B4(EnInvadepoh *arg0);              /* static */
void func_80B48DE4(Actor *arg0);                    /* static */
void func_80B497A4(EnInvadepoh *arg0);              /* static */
void func_80B49BD0(EnInvadepoh *arg0);              /* static */
void func_80B49DA0(Actor *arg0);                    /* static */
void func_80B4A2C0(EnInvadepoh *arg0);              /* static */
void func_80B4A614(EnInvadepoh *arg0);              /* static */
void func_80B4A7C0(Actor *arg0);                    /* static */
void func_80B4ACDC(Actor *arg0);                    /* static */
void func_80B4B3DC(Actor *arg0);                    /* static */
void func_80B4B430(EnInvadepoh *arg0);              /* static */
void func_80B4BBE0(EnInvadepoh *arg0, s16);         /* static */
void func_80B4BFFC(Actor *arg0);                    /* static */
void func_80B4C6C8(EnInvadepoh *arg0, s16);         /* static */
void func_80B4CAB0(Actor *arg0);                    /* static */
void func_80B4D15C(Actor *arg0);                    /* static */
void func_80B4D3E4(Actor *arg0);                    /* static */
void func_80B4D7B8(GraphicsContext **arg0);         /* static */
s32 func_80B4D9D8(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *rot, Actor *actor, Gfx **gfx); /* static */
void func_80B4D9F4(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4, Gfx **gfx); /* static */
s32 func_80B4E120(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, s16 *arg4, Actor *arg5); /* static */
s32 func_80B4E200(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5); /* static */
void func_80B4E2AC(void **arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4); /* static */
s32 func_80B4E5B0(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5); /* static */
void func_80B4E61C(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4); /* static */
s32 func_80B4E6E4(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5); /* static */
void func_80B4E784(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4); /* static */
extern ? D_06000080;
extern ? D_060003B0;
extern void D_06000550;
extern void D_06000560;
extern AnimationHeader D_06000608;
extern AnimationHeader D_060006C8;
extern ? D_06000720;
extern AnimationHeader D_06000998;
extern AnimationHeader D_06001560;
extern AnimationHeader D_06001674;
extern AnimationHeader D_06001BD8;
extern AnimationHeader D_06001D80;
extern AnimationHeader D_060021C8;
extern AnimationHeader D_06002A8C;
extern FlexSkeletonHeader D_06004010;
extern AnimationHeader D_06004264;
extern FlexSkeletonHeader D_06004C30;
extern FlexSkeletonHeader D_06004E50;
extern AnimationHeader D_06004E98;
extern AnimationHeader D_06007328;
extern FlexSkeletonHeader D_060080F0;
extern AnimationHeader D_06009E58;
extern AnimationHeader D_0600A174;
extern FlexSkeletonHeader D_06013928;
extern AnimationHeader D_06014088;
extern FlexSkeletonHeader D_06015C28;
extern AnimationHeader D_06016720;
extern s32 D_801BDA9C;
static ColliderCylinderInit D_80B4E8B0 = {
    {3, 0x11, 9, 0x39, 0x10, 1},
    {4, {0xF7CFFFFF, 0, 4}, {0x3820, 0, 0}, 0x19, 1, 1},
    {0x28, 0x5F, 0xA, {0, 0, 0}},
};
static ColliderCylinderInit D_80B4E8DC = {
    {0xA, 0, 0, 0x39, 0x20, 1},
    {0, {0, 0, 0}, {0, 0, 0}, 0, 0, 1},
    {0x12, 0x2E, 0, {0, 0, 0}},
};
static ColliderCylinderInit D_80B4E908 = {
    {0xA, 0, 0, 0x39, 0x10, 1},
    {1, {0, 0, 0}, {0, 0, 0}, 0, 0, 1},
    {0xD, 0x13, 0, {0, 0, 0}},
};
static ? D_80B4E934;                                /* unable to generate initializer */
static f32 D_80B4E938[2] = {-20.0f, 1395.0f};
static s32 D_80B4E940 = 0;
static void *D_80B4E944[5] = {
    (void *)0x600FFC8,
    (void *)0x60107C8,
    (void *)0x6010FC8,
    (void *)0x60117C8,
    (void *)0x6011FC8,
};
static void *D_80B4E958[4] = {(void *)0x60127C8, (void *)0x6012BC8, (void *)0x6012FC8, (void *)0x60133C8};
static s8 D_80B4E968 = 0;
static void *D_80B4E96C[6] = {
    (void *)0x6011AD8,
    (void *)0x60122D8,
    (void *)0x6012AD8,
    (void *)0x60132D8,
    (void *)0x6013AD8,
    (void *)0x60142D8,
};
static void *D_80B4E984[4] = {(void *)0x6014AD8, (void *)0x6014ED8, (void *)0x60152D8, (void *)0x60156D8};
static s8 D_80B4E994 = 0;
static s8 D_80B4E998 = 0;
static ? D_80B4EA90;                                /* unable to generate initializer */
static ? D_80B4EB00;                                /* unable to generate initializer */
static ? D_80B4EBDC;                                /* unable to generate initializer */
static ? D_80B4EC08;                                /* unable to generate initializer */
static ? D_80B4EC0C;                                /* unable to generate initializer */
static Color_RGBA8 D_80B4EC18 = {0xFF, 0xFF, 0xC8, 0xFF};
static Color_RGBA8 D_80B4EC1C = {0xFF, 0xC8, 0, 0};
static ? D_80B4EC20;                                /* unable to generate initializer */
static InitChainEntry D_80B4EC24[4];                /* unable to generate initializer */
static InitChainEntry D_80B4EC34[4];                /* unable to generate initializer */
static InitChainEntry D_80B4EC44[4];                /* unable to generate initializer */
static InitChainEntry D_80B4EC54[5];                /* unable to generate initializer */
static InitChainEntry D_80B4EC68[6];                /* unable to generate initializer */
static InitChainEntry D_80B4EC80[6];                /* unable to generate initializer */
static InitChainEntry D_80B4EC98[6];                /* unable to generate initializer */
static ? D_80B4ECB0;                                /* unable to generate initializer */
static ? D_80B4ECE8;                                /* unable to generate initializer */
static s16 D_80B4ED20[8] = {0x82, 0x7D, 0x73, 0x64, 0x50, 0x4E, 0x4C, 0x4A};
static ? D_80B4ED30;                                /* unable to generate initializer */
static ? D_80B4ED6C;                                /* unable to generate initializer */
static ? D_80B4EDC0;                                /* unable to generate initializer */
static ? D_80B4EDC8;                                /* unable to generate initializer */
static ? D_80B4EDD0;                                /* unable to generate initializer */
static ? D_80B4EE0C;                                /* unable to generate initializer */
static Vec3f D_80B4EE24 = {2000.0f, 1000.0f, 0.0f};
static Vec3f D_80B4EE30 = {400.0f, 270.0f, 0.0f};
static MtxF D_80B502A0;
static MtxF D_80B502E0;
static Actor *D_80B50320;
static ? D_80B50324;
static ? D_80B50328;
static ? D_80B5032C;
static u8 D_80B50340;
static s8 D_80B50348;
static ? D_80B50350;
static Actor *D_80B503F0;
static EnInvadepoh *D_80B503F4;
static EnInvadepoh *D_80B503F8;
static void *D_80B503FC;
static void *D_80B50400;
static s16 D_80B50404;
static s16 D_80B50406;
static ? D_80B5040A;
static Actor *D_80B5040C;

void func_80B439B0(s32 arg0, s32 arg1) {
    s32 temp_a1;
    s32 temp_t4;
    s32 temp_t7;
    s32 phi_a1;

    temp_a1 = arg1 - 0x1AAA;
    phi_a1 = temp_a1;
    if (temp_a1 < 0) {
        phi_a1 = 0;
    }
    temp_t4 = arg0 >> 1;
    if ((arg0 & 1) == 0) {
        temp_t7 = arg0 >> 1;
        gSaveContext.roomInf[124][temp_t7] = (gSaveContext.roomInf[124][temp_t7] & 0xFFFF0000) | (phi_a1 & 0xFFFF);
        return;
    }
    gSaveContext.roomInf[124][temp_t4] = (gSaveContext.roomInf[124][temp_t4] & 0xFFFF) | (phi_a1 << 0x10);
}

s32 func_80B43A24(s32 arg0) {
    u32 phi_v1;

    if ((arg0 & 1) == 0) {
        phi_v1 = gSaveContext.roomInf[124][arg0 >> 1] & 0xFFFF;
    } else {
        phi_v1 = (u32) (gSaveContext.roomInf[124][arg0 >> 1] & 0xFFFF0000) >> 0x10;
    }
    return phi_v1 + 0x1AAA;
}

void func_80B43A74(s32 arg0) {
    gSaveContext.roomInf[124][4] = (gSaveContext.roomInf[124][4] & ~0xFF) | (arg0 & 0xFF);
}

s32 func_80B43A9C(void) {
    return gSaveContext.roomInf[124][4] & 0xFF;
}

s32 func_80B43AB0(void) {
    s32 sp1C;
    s32 temp_a0;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_80B43A9C();
    phi_a0 = temp_v0;
    if (temp_v0 < 0xC) {
        temp_a0 = temp_v0 + 1;
        sp1C = temp_a0;
        func_80B43A74(temp_a0);
        phi_a0 = temp_a0;
    }
    return phi_a0;
}

void func_80B43AF0(s32 arg0) {
    s32 sp1C;
    u16 temp_v1;

    temp_v1 = gSaveContext.time;
    if ((((s32) gSaveContext.day % 5) == 1) && ((s32) temp_v1 >= 0x1AAA) && ((s32) temp_v1 < 0x3800)) {
        sp1C = (s32) temp_v1;
        func_80B439B0(arg0, temp_v1 + (s32) ((f32) (0xC - func_80B43A9C()) * 25.0f));
    }
}

s8 func_80B43B80(EnInvadepoh *arg0) {
    s32 temp_v0;
    s8 temp_v1;
    EnInvadepoh *phi_a1;
    s8 phi_v1;
    s8 phi_v1_2;

    temp_v0 = arg0->endPoint - 1;
    phi_a1 = arg0;
    phi_v1 = 0;
    phi_v1_2 = 0;
    if (temp_v0 > 0) {
loop_2:
        phi_v1_2 = phi_v1;
        if (!(arg0->clockTime < phi_a1->unk37C[0])) {
            temp_v1 = phi_v1 + 1;
            phi_a1 += 4;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
            if (temp_v1 != temp_v0) {
                goto loop_2;
            }
        }
    }
    return phi_v1_2;
}

void func_80B43BC8(Actor *arg0, s8 *arg1, void *arg2) {
    f32 sp78;
    f32 sp74;
    f32 sp70;
    f32 *temp_a0;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f22;
    f32 temp_f6;
    s32 temp_v0;
    s8 temp_s2;
    s8 temp_s5;
    void *temp_s1;
    void *phi_s0;
    void *phi_s1;
    f32 phi_f20;
    s8 phi_s2;
    f32 phi_f24;

    temp_s5 = arg0->unk_308;
    temp_s1 = arg0->unk_30C;
    temp_f22 = 1.0f / arg0[2].floorHeight;
    phi_s0 = temp_s1 + 6;
    phi_s1 = temp_s1;
    phi_f20 = 0.0f;
    phi_s2 = 0;
    phi_f24 = 0.0f;
    if ((s32) temp_s5 > 0) {
loop_2:
        temp_a0 = &sp70;
        sp70 = (f32) (phi_s0->unk_0 - phi_s1->unk_0);
        sp74 = (f32) (phi_s0->unk_2 - phi_s1->unk_2);
        sp78 = (f32) (phi_s0->unk_4 - phi_s1->unk_4);
        temp_f14 = phi_f20 + Math3D_Vec3fMagnitude((Vec3f *) temp_a0);
        temp_f12 = temp_f14 * temp_f22;
        if (arg0[2].xzDistToPlayer <= temp_f12) {
            temp_f6 = temp_f12 - phi_f24;
            *arg1 = phi_s2;
            temp_f0 = (arg0[2].xzDistToPlayer - phi_f24) / temp_f6;
            arg2->unk_0 = (f32) ((temp_f0 * sp70) + (f32) phi_s1->unk_0);
            arg2->unk_4 = (f32) ((temp_f0 * sp74) + (f32) phi_s1->unk_2);
            arg2->unk_8 = (f32) ((temp_f0 * sp78) + (f32) phi_s1->unk_4);
            return;
        }
        temp_s2 = phi_s2 + 1;
        phi_s0 += 6;
        phi_s1 = phi_s0;
        phi_f20 = temp_f14;
        phi_s2 = temp_s2;
        phi_f24 = temp_f12;
        if (temp_s2 == temp_s5) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    *arg1 = temp_s5;
    temp_v0 = temp_s5 * 6;
    arg2->unk_0 = (f32) *(arg0->unk_30C + temp_v0);
    arg2->unk_4 = (f32) (arg0->unk_30C + temp_v0)->unk_2;
    arg2->unk_8 = (f32) (arg0->unk_30C + temp_v0)->unk_4;
}

void func_80B43DD4(EnInvadepoh *arg0, s16 arg1, s16 arg2) {
    Vec3s *sp40;
    ? sp30;
    ? sp24;
    Vec3s *temp_a1;
    Vec3s *temp_t8;
    s8 temp_v0;

    temp_v0 = arg0->pathIndex;
    temp_t8 = arg0->pathPoints + (temp_v0 * 6);
    sp40 = temp_t8;
    temp_a1 = temp_t8;
    if (arg0->endPoint != temp_v0) {
        arg0 = arg0;
        Math_Vec3s_ToVec3f((Vec3f *) &sp30, temp_a1);
        Math_Vec3s_ToVec3f((Vec3f *) &sp24, &sp40[1]);
        Math_ScaledStepToS(arg0 + 0xBE, (s16) (Math_Vec3f_Yaw((Vec3f *) &sp30, (Vec3f *) &sp24) + arg2), arg1);
    }
}

void func_80B43E6C(EnInvadepoh *arg0, s16 arg1, s16 arg2, s16 arg3) {
    Vec3s *sp48;
    ? sp38;
    ? sp2C;
    Vec3s *temp_t9;
    s8 temp_v0;

    temp_v0 = arg0->pathIndex;
    temp_t9 = arg0->pathPoints + (temp_v0 * 6);
    sp48 = temp_t9;
    if (arg0->endPoint != temp_v0) {
        Math_Vec3s_ToVec3f((Vec3f *) &sp38, temp_t9);
        Math_Vec3s_ToVec3f((Vec3f *) &sp2C, &sp48[1]);
        Math_SmoothStepToS(arg0 + 0xBE, Math_Vec3f_Yaw((Vec3f *) &sp38, (Vec3f *) &sp2C), arg1, arg2, (s16) (s32) arg3);
    }
}

void func_80B43F0C(Actor *arg0) {
    Vec3s *sp38;
    ? sp28;
    ? sp1C;
    Vec3s *temp_a1;
    s32 temp_t6;
    s8 temp_t7;

    temp_t7 = arg0->unk_309;
    temp_t6 = arg0->unk_30C;
    arg0 = arg0;
    temp_a1 = temp_t6 + (temp_t7 * 6);
    sp38 = temp_a1;
    Math_Vec3s_ToVec3f((Vec3f *) &sp28, temp_a1);
    Math_Vec3s_ToVec3f((Vec3f *) &sp1C, &sp38[1]);
    arg0->shape.rot.y = Math_Vec3f_Yaw((Vec3f *) &sp28, (Vec3f *) &sp1C);
}

f32 EnInvadepoh_GetTotalPathDistance(Actor *arg0) {
    ? sp54;
    ? sp48;
    Vec3s *temp_s0;
    f32 temp_f20;
    s32 temp_s1;
    s32 temp_s4;
    Vec3s *phi_s0;
    s32 phi_s1;
    f32 phi_f20;
    f32 phi_f20_2;

    temp_s0 = arg0->unk_30C;
    temp_s4 = arg0->unk_308 + 1;
    Math_Vec3s_ToVec3f((Vec3f *) &sp48, temp_s0);
    phi_s0 = &temp_s0[1];
    phi_s1 = 1;
    phi_f20 = 0.0f;
    phi_f20_2 = 0.0f;
    if (temp_s4 >= 2) {
        do {
            Math_Vec3f_Copy((Vec3f *) &sp54, (Vec3f *) &sp48);
            Math_Vec3s_ToVec3f((Vec3f *) &sp48, phi_s0);
            temp_s1 = phi_s1 + 1;
            temp_f20 = phi_f20_2 + Math3D_Distance((Vec3f *) &sp54, (Vec3f *) &sp48);
            phi_s0 = &phi_s0[1];
            phi_s1 = temp_s1;
            phi_f20 = temp_f20;
            phi_f20_2 = temp_f20;
        } while (temp_s1 != temp_s4);
    }
    return phi_f20;
}

void func_80B44024(Actor *arg0, void *arg1) {
    void *temp_a0;
    void *temp_v0;

    temp_v0 = arg1->unk_18864 + ((((s32) arg0->params >> 8) & 0x7F) * 8);
    arg0->unk_308 = (s8) (temp_v0->unk_0 - 1);
    temp_a0 = temp_v0->unk_4;
    arg0 = arg0;
    arg0->unk_30C = Lib_SegmentedToVirtual(temp_a0);
}

void EnInvadepoh_SetPathPointToWorldPos(Actor *arg0, s8 arg1) {
    Math_Vec3s_ToVec3f(arg0 + 0x24, arg0->unk_30C + (arg1 * 6));
}

s32 func_80B440B8(Actor *arg0, f32 arg1, f32 arg2) {
    void *sp48;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    s16 sp1E;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    s16 temp_v0_2;
    s32 temp_a0;
    s32 temp_f6;
    s8 temp_v0;
    void *temp_a2;
    void *temp_a3;
    s32 phi_v0;

    temp_v0 = arg0->unk_309;
    temp_a2 = arg0->unk_30C + (temp_v0 * 6);
    temp_a3 = temp_a2 + 6;
    if ((s32) temp_v0 >= (s32) arg0->unk_308) {
        return 0;
    }
    temp_f6 = temp_a3->unk_4 - temp_a2->unk_4;
    temp_f14 = (f32) (temp_a3->unk_0 - temp_a2->unk_0);
    sp48 = temp_a2;
    arg0 = arg0;
    temp_f12 = (f32) temp_f6;
    sp40 = temp_f14;
    sp3C = temp_f12;
    temp_v0_2 = Math_FAtan2F(temp_f12, temp_f14);
    temp_a0 = temp_v0_2 << 0x10;
    sp1E = temp_v0_2;
    sp38 = Math_CosS((s16) (temp_a0 >> 0x10));
    temp_f0 = Math_SinS(sp1E);
    temp_f18 = temp_f0;
    temp_f2 = arg0->world.pos.x - (f32) temp_a2->unk_0;
    temp_f16 = arg0->world.pos.z - (f32) temp_a2->unk_4;
    if ((arg1 - arg2) < fabsf((temp_f2 * sp38) - (temp_f16 * temp_f0))) {
        return 0;
    }
    sp30 = temp_f2;
    sp2C = temp_f16;
    sp34 = temp_f18;
    temp_f12_2 = (temp_f16 * sp38) + (temp_f2 * temp_f18);
    if ((temp_f12_2 < 0.0f) || (phi_v0 = 1, (Math3D_XZLength(sp40, sp3C) < temp_f12_2))) {
        phi_v0 = 0;
    }
    return phi_v0;
}

s8 func_80B44234(Actor *arg0, Vec3f *arg1) {
    ? sp48;
    f32 temp_f0;
    s8 temp_s0;
    s8 temp_s3;
    Vec3s *phi_s1;
    f32 phi_f20;
    s8 phi_s0;
    s8 phi_s4;
    s8 phi_s4_2;

    temp_s3 = arg0->unk_308;
    phi_s1 = arg0->unk_30C;
    phi_f20 = 3.4028235e38f;
    phi_s0 = 0;
    phi_s4 = 0;
    phi_s4_2 = 0;
    if ((s32) temp_s3 > 0) {
        do {
            Math_Vec3s_ToVec3f((Vec3f *) &sp48, phi_s1);
            temp_f0 = Math3D_DistanceSquared((Vec3f *) &sp48, arg1);
            if (temp_f0 < phi_f20) {
                phi_f20 = temp_f0;
                phi_s4_2 = phi_s0;
            }
            temp_s0 = phi_s0 + 1;
            phi_s1 = &phi_s1[1];
            phi_s0 = temp_s0;
            phi_s4 = phi_s4_2;
        } while (temp_s0 != temp_s3);
    }
    return phi_s4;
}

void func_80B442E4(EnInvadepoh *arg0) {
    s32 sp18;
    EnInvadepoh *temp_a0_2;
    EnInvadepoh *temp_a1;
    EnInvadepoh *temp_a1_2;
    f32 temp_f0;
    s16 temp_a0;
    s32 temp_v1;
    s32 temp_v1_2;

    temp_a1 = arg0;
    sp18 = (s32) gSaveContext.time;
    temp_a0 = temp_a1->actor.params;
    arg0 = temp_a1;
    temp_v1 = D_80B4E940;
    temp_a1_2 = arg0;
    temp_a0_2 = temp_a1_2;
    if (temp_v1 == 1) {
        temp_a1_2->clockTime = 0.0f;
    } else if (temp_v1 == 2) {
        temp_v1_2 = sp18 - func_80B43A24(temp_a0 & 7, temp_a1);
        if (temp_v1_2 < 0) {
            temp_a1_2->clockTime = 0.0f;
        } else {
            temp_f0 = (f32) temp_v1_2 * 0.00027777778f;
            temp_a1_2->clockTime = temp_f0;
            if (temp_f0 > 1.0f) {
                temp_a1_2->clockTime = 1.0f;
            }
        }
    }
    arg0 = temp_a1_2;
    arg0->pathIndex = func_80B43B80(temp_a0_2, temp_a1_2);
}

void func_80B443A0(Actor *arg0) {
    ? sp70;
    ? sp64;
    Vec3s *temp_s1;
    f32 temp_f20;
    f32 temp_f26;
    f32 temp_f2;
    s32 temp_cond;
    s32 temp_s2;
    s8 temp_s5;
    Vec3s *phi_s1;
    f32 phi_f20;
    f32 *phi_s0;
    s32 phi_s2;

    temp_s1 = arg0->unk_30C;
    temp_s5 = arg0->unk_308;
    temp_f26 = 1.0f / arg0[2].floorHeight;
    Math_Vec3s_ToVec3f((Vec3f *) &sp64, temp_s1);
    phi_s1 = &temp_s1[1];
    phi_f20 = 0.0f;
    phi_s0 = arg0 + 0x37C;
    phi_s2 = 1;
    if ((s32) temp_s5 >= 2) {
        do {
            Math_Vec3f_Copy((Vec3f *) &sp70, (Vec3f *) &sp64);
            Math_Vec3s_ToVec3f((Vec3f *) &sp64, phi_s1);
            temp_f20 = phi_f20 + Math3D_Distance((Vec3f *) &sp70, (Vec3f *) &sp64);
            temp_s2 = phi_s2 + 1;
            temp_f2 = temp_f20 * temp_f26;
            temp_cond = temp_f2 < 0.0f;
            *phi_s0 = temp_f2;
            phi_s1 = &phi_s1[1];
            phi_s2 = temp_s2;
            if (temp_cond) {
                *phi_s0 = 0.0f;
            } else if (*phi_s0 > 1.0f) {
                *phi_s0 = 1.0f;
            }
            phi_f20 = temp_f20;
            phi_s0 += 4;
        } while (temp_s2 != temp_s5);
    }
}

void func_80B444BC(Actor *arg0) {
    func_80B44024(arg0);
    arg0[2].floorHeight = EnInvadepoh_GetTotalPathDistance(arg0);
    func_80B443A0(arg0);
}

void func_80B444F4(void) {
    func_80B44024();
}

void func_80B44514(EnInvadepoh *arg0) {
    arg0->pathIndex += 1;
    if ((s32) arg0->pathIndex >= (s32) arg0->endPoint) {
        arg0->pathIndex = 0;
    }
}

void func_80B44540(Actor *arg0) {
    func_80B44024(arg0);
    arg0[2].floorHeight = EnInvadepoh_GetTotalPathDistance(arg0);
}

void func_80B44570(EnInvadepoh *arg0) {
    f32 temp_f0;
    f32 temp_f0_2;
    u16 temp_v0;
    f32 phi_f2;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 < 0x1555) || ((s32) temp_v0 >= 0x4000)) {
        arg0->clockTime = 0.0f;
        return;
    }
    if (((s32) temp_v0 >= 0x1800) && ((s32) temp_v0 < 0x4000)) {
        arg0->clockTime = 1.0f;
        return;
    }
    temp_f0 = (f32) (temp_v0 - 0x1555) * 0.0014641288f;
    arg0->clockTime = temp_f0;
    if (temp_f0 < 0.0f) {
        arg0->clockTime = 0.0f;
        return;
    }
    temp_f0_2 = arg0->clockTime;
    if (temp_f0_2 > 1.0f) {
        phi_f2 = 1.0f;
    } else {
        phi_f2 = temp_f0_2;
    }
    arg0->clockTime = phi_f2;
}

void func_80B44620(void) {
    func_80B44024();
}

void func_80B44640(EnInvadepoh *arg0) {
    s8 temp_v0;

    temp_v0 = arg0->pathIndex;
    if ((s32) temp_v0 < (s32) arg0->endPoint) {
        arg0->pathIndex = temp_v0 + 1;
    }
}

void func_80B44664(Actor *arg0) {
    func_80B44024(arg0);
    arg0->unk_30A = 1;
}

void func_80B44690(EnInvadepoh *arg0) {
    s8 temp_v0;
    s8 temp_v1;

    temp_v1 = arg0->endPoint;
    arg0->pathIndex += arg0->direction;
    temp_v0 = arg0->pathIndex;
    if ((s32) temp_v0 >= (s32) temp_v1) {
        arg0->pathIndex = 0;
        return;
    }
    if ((s32) temp_v0 < 0) {
        arg0->pathIndex = temp_v1 - 1;
    }
}

void func_80B446D0(Actor *arg0) {
    func_80B44024(arg0);
    arg0[2].floorHeight = EnInvadepoh_GetTotalPathDistance(arg0);
}

void func_80B44700(EnInvadepoh *arg0) {
    f32 temp_f0;
    f32 temp_f0_2;
    u16 temp_v0;
    f32 phi_f2;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 < 0xD555) && ((s32) temp_v0 >= 0x4000)) {
        arg0->clockTime = 0.0f;
        return;
    }
    if (((s32) temp_v0 >= 0xD7E1) || ((s32) temp_v0 < 0x4000)) {
        arg0->clockTime = 1.0f;
        return;
    }
    temp_f0 = (f32) (temp_v0 + 0xFFFF2AAB) * 0.0015337423f;
    arg0->clockTime = temp_f0;
    if (temp_f0 < 0.0f) {
        arg0->clockTime = 0.0f;
        return;
    }
    temp_f0_2 = arg0->clockTime;
    if (temp_f0_2 > 1.0f) {
        phi_f2 = 1.0f;
    } else {
        phi_f2 = temp_f0_2;
    }
    arg0->clockTime = phi_f2;
}

void func_80B447C0(Actor *arg0, GlobalContext *arg1) {
    Vec3s *sp60;
    f32 sp50;
    f32 sp44;
    f32 sp40;
    f32 sp3C;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    Vec3f *sp24;
    Vec3f *temp_a2;
    Vec3s *temp_a3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    s8 temp_v0;
    f32 phi_f2;
    Vec3f *phi_a2;

    sp40 = arg0->world.pos.y;
    temp_v0 = arg0->unk_309;
    temp_a3 = arg0->unk_30C + (temp_v0 * 6);
    if ((s32) temp_v0 <= 0) {
        sp3C = 0.0f;
    } else {
        sp3C = (arg0 + (temp_v0 * 4))->unk_378;
    }
    if ((s32) temp_v0 < (arg0->unk_308 - 1)) {
        phi_f2 = (arg0 + (temp_v0 * 4))->unk_37C;
    } else {
        phi_f2 = 1.0f;
    }
    temp_f18 = phi_f2 - sp3C;
    temp_a2 = arg0 + 0x314;
    if (temp_f18 < 0.001f) {
        sp24 = temp_a2;
        Math_Vec3s_ToVec3f(temp_a2, temp_a3);
        phi_a2 = temp_a2;
    } else {
        temp_f0 = arg0[2].xzDistToPlayer;
        temp_f16 = 1.0f / temp_f18;
        sp60 = temp_a3;
        temp_f14 = phi_f2 - temp_f0;
        temp_f12 = temp_f0 - sp3C;
        sp30 = temp_f14;
        sp34 = temp_f12;
        sp2C = temp_f16;
        Math_Vec3s_ToVec3f((Vec3f *) &sp50, temp_a3);
        Math_Vec3s_ToVec3f((Vec3f *) &sp44, &temp_a3[1]);
        arg0[2].yDistToWater = ((sp50 * temp_f14) + (sp44 * temp_f12)) * temp_f16;
        arg0->unk_318 = (f32) (((sp54 * temp_f14) + (sp48 * temp_f12)) * temp_f16);
        arg0[2].xyzDistToPlayerSq = ((sp58 * temp_f14) + (sp4C * temp_f12)) * temp_f16;
        phi_a2 = arg0 + 0x314;
    }
    Math_Vec3f_Copy(arg0 + 0x24, phi_a2);
    func_800B4AEC(arg1, arg0, 0.0f);
    temp_f2 = arg0->floorHeight;
    if (temp_f2 > -31999.0f) {
        if (sp40 < temp_f2) {
            temp_f0_2 = arg0->velocity.y;
            if (temp_f0_2 < 0.0f) {
                arg0->velocity.y = 0.0f;
            } else {
                arg0->velocity.y = temp_f0_2 + 2.0f;
                temp_f0_3 = arg0->velocity.y;
                if (temp_f0_3 > 30.0f) {
                    arg0->velocity.y = 30.0f;
                } else {
                    arg0->velocity.y = temp_f0_3;
                }
            }
            temp_f2_2 = arg0->floorHeight;
            temp_f12_2 = arg0->velocity.y + sp40;
            arg0->world.pos.y = temp_f12_2;
            if (temp_f2_2 < temp_f12_2) {
                arg0->world.pos.y = temp_f2_2;
                return;
            }
            /* Duplicate return node #26. Try simplifying control flow for better match */
            return;
        }
        temp_f0_4 = arg0->velocity.y;
        if (temp_f0_4 > 0.0f) {
            arg0->velocity.y = 0.0f;
        } else {
            arg0->velocity.y = temp_f0_4 - 2.0f;
        }
        temp_f0_5 = arg0->velocity.y;
        temp_f2_3 = arg0->floorHeight;
        temp_f12_3 = temp_f0_5 + sp40;
        arg0->world.pos.y = temp_f12_3;
        if (temp_f12_3 < temp_f2_3) {
            arg0->world.pos.y = temp_f2_3;
            if (temp_f0_5 < -30.0f) {
                arg0->velocity.y = -30.0f;
                return;
            }
            arg0->velocity.y = temp_f0_5;
            return;
        }
        /* Duplicate return node #26. Try simplifying control flow for better match */
        return;
    }
    arg0->world.pos.y = sp40;
}

void func_80B44A90(Actor *arg0, GlobalContext *arg1) {
    u16 temp_v0;

    temp_v0 = arg0->bgCheckFlags;
    if ((temp_v0 & 1) != 0) {
        arg0->velocity.y *= 0.3f;
        arg0->speedXZ *= 0.8f;
    } else if ((temp_v0 & 8) != 0) {
        arg0->velocity.y *= 0.8f;
        arg0->speedXZ *= 0.3f;
    } else {
        arg0->velocity.y *= 0.8f;
        arg0->speedXZ *= 0.8f;
    }
    Actor_SetVelocityAndMoveYRotationAndGravity(arg0);
    Actor_UpdateBgCheckInfo(arg1, arg0, 30.0f, 40.0f, 0.0f, 5U);
}

void func_80B44B78(EnInvadepoh *arg0) {

}

s32 func_80B44B84(Actor *arg0, GlobalContext *arg1, f32 arg2, f32 arg3) {
    s32 sp2C;
    s32 temp_v0;
    void *temp_v0_2;

    temp_v0_2 = arg0->unk_30C + (arg0->unk_309 * 6);
    temp_v0 = func_80B450C0(arg0 + 0x24, arg0 + 0x2C, (f32) temp_v0_2->unk_6, (f32) temp_v0_2->unk_A, arg2);
    sp2C = temp_v0;
    func_800B4AEC(arg1, arg0, arg3);
    func_80B4516C((EnInvadepoh *) arg0);
    return temp_v0;
}

void func_80B44C24(Actor *arg0, GlobalContext *arg1) {
    f32 sp18;
    Actor *temp_a3;
    f32 temp_f4;

    temp_a3 = arg0;
    temp_f4 = temp_a3->world.pos.y;
    arg0 = temp_a3;
    sp18 = temp_f4;
    func_80B43BC8(temp_a3, temp_a3 + 0x309, temp_a3 + 0x24, temp_a3);
    arg0->world.pos.y = sp18;
    func_800B4AEC(arg1, arg0, 50.0f);
    func_80B4516C((EnInvadepoh *) arg0);
}

s32 func_80B44C80(Actor *arg0, GlobalContext *arg1) {
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp54;
    f32 sp44;
    s32 sp40;
    f32 *temp_a0;
    f32 *temp_a1;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f4;
    f32 temp_f6;
    s32 temp_a3;
    s32 temp_v1;
    s8 temp_t0;
    s8 temp_v0;
    void *temp_a2;
    void *temp_v0_2;
    s32 phi_v1;
    u32 phi_v0;

    temp_v0 = arg0->unk_309;
    temp_a3 = arg0->unk_30C;
    sp40 = 0;
    temp_t0 = arg0->unk_308;
    temp_v1 = temp_v0 + arg0->unk_30A;
    temp_a2 = temp_a3 + (temp_v0 * 6);
    phi_v1 = temp_v1;
    if (temp_v1 >= (s32) temp_t0) {
        phi_v1 = 0;
    } else if (temp_v1 < 0) {
        phi_v1 = temp_t0 - 1;
    }
    temp_a0 = &sp6C;
    temp_f0 = (f32) temp_a2->unk_0;
    temp_a1 = &sp60;
    temp_v0_2 = temp_a3 + (phi_v1 * 6);
    temp_f2 = (f32) temp_a2->unk_4;
    temp_f12 = (f32) temp_v0_2->unk_0;
    sp70 = 0.0f;
    temp_f14 = (f32) temp_v0_2->unk_4;
    sp6C = temp_f12 - temp_f0;
    sp74 = temp_f14 - temp_f2;
    sp64 = 0.0f;
    sp60 = temp_f12 - arg0->world.pos.x;
    sp68 = temp_f14 - arg0->world.pos.z;
    temp_f4 = arg0->world.pos.x;
    temp_f6 = arg0->world.pos.z;
    if (arg0->speedXZ > 0.0f) {
        sp54 = temp_f0 - temp_f4;
        sp5C = temp_f2 - temp_f6;
        if (Math3D_AngleBetweenVectors((Vec3f *) temp_a0, (Vec3f *) temp_a1, &sp44) != 0) {
            sp40 = 1;
        } else if (sp44 <= 0.0f) {
            sp40 = 1;
        }
    }
    Math_SmoothStepToS(arg0 + 0x32, Math_FAtan2F(((sp68 + (temp_f2 - temp_f6)) * 0.9f) + sp74, ((sp60 + (temp_f0 - temp_f4)) * 0.9f) + sp6C), 4, 0xFA0, (s16) 0x64);
    Actor_SetVelocityAndMoveYRotationAndGravity(arg0);
    if (func_80B440B8(arg0, 50.0f, 15.0f) != 0) {
        phi_v0 = 4U;
    } else {
        phi_v0 = 5U;
    }
    Actor_UpdateBgCheckInfo(arg1, arg0, 30.0f, 15.0f, 0.0f, phi_v0);
    Math_SmoothStepToS(&arg0->shape.rot.y, arg0->world.rot.y, 3, 0x1F40, (s16) 0x64);
    return sp40;
}

void func_80B44E90(Actor *arg0, GlobalContext *arg1) {
    Actor_SetVelocityAndMoveYRotationAndGravity(arg0);
    Actor_UpdateBgCheckInfo(arg1, arg0, 30.0f, 15.0f, 0.0f, 5U);
    Math_SmoothStepToS(&arg0->shape.rot.y, arg0->world.rot.y, 3, 0x1F40, (s16) 0x64);
}

void func_80B44EFC(Actor *arg0, GlobalContext *arg1) {
    f32 sp18;
    Actor *temp_a3;
    f32 temp_f4;

    temp_a3 = arg0;
    temp_f4 = temp_a3->world.pos.y;
    arg0 = temp_a3;
    sp18 = temp_f4;
    func_80B43BC8(temp_a3, temp_a3 + 0x309, temp_a3 + 0x24, temp_a3);
    arg0->world.pos.y = sp18;
    func_800B4AEC(arg1, arg0, 50.0f);
    func_80B4516C((EnInvadepoh *) arg0);
}

void func_80B44F58(void) {
    s32 temp_s1;
    s32 temp_s1_2;
    void **temp_s0;
    void **temp_s0_2;
    void **phi_s0;
    s32 phi_s1;
    void **phi_s0_2;
    s32 phi_s1_2;

    phi_s1 = 0;
    phi_s1_2 = 0;
    if (D_80B4E968 == 0) {
        D_80B4E968 = 1;
        phi_s0 = D_80B4E944;
        do {
            temp_s1 = phi_s1 + 1;
            temp_s0 = phi_s0 + 4;
            temp_s0->unk_-4 = Lib_SegmentedToVirtual(*phi_s0);
            phi_s0 = temp_s0;
            phi_s1 = temp_s1;
        } while (temp_s1 < 5);
        phi_s0_2 = D_80B4E958;
        do {
            temp_s1_2 = phi_s1_2 + 1;
            temp_s0_2 = phi_s0_2 + 4;
            temp_s0_2->unk_-4 = Lib_SegmentedToVirtual(*phi_s0_2);
            phi_s0_2 = temp_s0_2;
            phi_s1_2 = temp_s1_2;
        } while (temp_s1_2 != 4);
    }
}

void func_80B44FEC(void) {
    s32 temp_s1;
    s32 temp_s1_2;
    void **temp_s0;
    void **temp_s0_2;
    void **phi_s0;
    s32 phi_s1;
    void **phi_s0_2;
    s32 phi_s1_2;

    phi_s1 = 0;
    phi_s1_2 = 0;
    if (D_80B4E994 == 0) {
        D_80B4E994 = 1;
        phi_s0 = D_80B4E96C;
        do {
            temp_s1 = phi_s1 + 1;
            temp_s0 = phi_s0 + 4;
            temp_s0->unk_-4 = Lib_SegmentedToVirtual(*phi_s0);
            phi_s0 = temp_s0;
            phi_s1 = temp_s1;
        } while (temp_s1 < 6);
        phi_s0_2 = D_80B4E984;
        do {
            temp_s1_2 = phi_s1_2 + 1;
            temp_s0_2 = phi_s0_2 + 4;
            temp_s0_2->unk_-4 = Lib_SegmentedToVirtual(*phi_s0_2);
            phi_s0_2 = temp_s0_2;
            phi_s1_2 = temp_s1_2;
        } while (temp_s1_2 != 4);
    }
}

void func_80B45080(void) {
    D_80B50400 = Lib_SegmentedToVirtual(&D_06000560);
    D_80B503FC = Lib_SegmentedToVirtual(&D_06000550);
}

s32 func_80B450C0(f32 *arg0, f32 *arg1, f32 arg2, f32 arg3, f32 arg4) {
    f32 sp1C;
    f32 sp18;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;

    temp_f12 = arg2 - *arg0;
    temp_f14 = arg3 - *arg1;
    sp1C = temp_f12;
    sp18 = temp_f14;
    temp_f0 = Math3D_XZLength(temp_f12, temp_f14);
    if (arg4 < temp_f0) {
        temp_f2 = arg4 / temp_f0;
        *arg0 += temp_f2 * temp_f12;
        *arg1 += temp_f2 * temp_f14;
        return 0;
    }
    *arg0 = arg2;
    *arg1 = arg3;
    return 1;
}

s32 func_80B4516C(EnInvadepoh *this) {
    f32 temp_f0;

    temp_f0 = this->actor.floorHeight;
    if (temp_f0 > -31999.0f) {
        this->actor.world.pos.y = temp_f0;
        return 1;
    }
    return 0;
}

void func_80B451A0(EnInvadepoh *arg0, GlobalContext *arg1) {
    s32 sp2C;
    s32 temp_hi;
    s32 temp_s0;
    s32 temp_v0;
    s32 temp_v0_2;
    u16 temp_v1;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_v1;
    s32 phi_s1_2;
    s32 phi_v0;
    SaveContext *phi_a2;
    s32 *phi_a1;
    s32 phi_s1_3;

    temp_v0 = D_80B4E940;
    phi_v0 = temp_v0;
    phi_a2 = &gSaveContext;
    phi_a1 = &D_80B4E940;
    if (temp_v0 == 0) {
        temp_hi = (s32) gSaveContext.day % 5;
        if (temp_hi <= 0) {
            D_80B4E940 = 1;
            phi_v0 = 1;
        } else if (temp_hi == 1) {
            temp_v1 = gSaveContext.time;
            phi_v1 = (s32) temp_v1;
            if (((s32) temp_v1 < 0x1AAA) || ((s32) temp_v1 >= 0x4000)) {
                D_80B4E940 = 1;
                phi_v0 = 1;
            } else if ((s32) temp_v1 < 0x3800) {
                phi_s0 = 0;
                phi_s1 = 0x3800;
                phi_s1_2 = 0x3800;
                if ((s32) arg0->unk379 > 0) {
                    sp2C = (s32) temp_v1;
                    do {
                        temp_v0_2 = func_80B43A24(phi_s0);
                        phi_s1_3 = phi_s1;
                        if (temp_v0_2 < phi_s1) {
                            phi_s1_3 = temp_v0_2;
                        }
                        temp_s0 = phi_s0 + 1;
                        phi_s0 = temp_s0;
                        phi_s1 = phi_s1_3;
                        phi_s1_2 = phi_s1_3;
                    } while (temp_s0 < (s32) arg0->unk379);
                    phi_v1 = sp2C;
                }
                phi_a2 = &gSaveContext;
                phi_a1 = &D_80B4E940;
                if (phi_v1 < (phi_s1_2 + 0xE11)) {
                    D_80B4E940 = 2;
                }
                phi_v0 = D_80B4E940;
            }
        }
        if (phi_v0 == 0) {
            if ((phi_a2->weekEventReg[22] & 1) != 0) {
                *phi_a1 = 3;
                return;
            }
            *phi_a1 = 4;
            /* Duplicate return node #21. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #21. Try simplifying control flow for better match */
    }
}

void func_80B452EC(EnInvadepoh *arg0, GlobalContext *arg1) {
    s32 temp_s3;
    s32 phi_s3;
    u8 phi_s2;
    Actor **phi_s0;

    phi_s3 = 0;
    phi_s2 = ((s32) arg0->actor.params >> 8) & 0x7F;
    if ((s32) arg0->unk379 > 0) {
        phi_s0 = &D_80B50320;
        do {
            *phi_s0 = Actor_Spawn(arg1 + 0x1CA0, arg1, 0x200, arg0->actor.world.pos.x, arg0->actor.world.pos.y, arg0->actor.world.pos.z, (s16) 0, (s16) 0, (s16) 0, (s16) ((phi_s3 & 7) | ((phi_s2 << 8) & 0x7F00) | 0x10));
            if (phi_s2 != 0xFF) {
                phi_s2 = arg1->setupPathList[phi_s2].unk1;
            }
            temp_s3 = phi_s3 + 1;
            phi_s3 = temp_s3;
            phi_s0 += 4;
        } while (temp_s3 < (s32) arg0->unk379);
    }
}

void func_80B453F4(Actor *arg0, GlobalContext *arg1, s32 arg2) {
    Actor_SpawnAsChild(arg1 + 0x1CA0, arg0, arg1, 0x200, arg0->home.pos.x, arg0->home.pos.y, arg0->home.pos.z, (s16) 0, (s16) 0, (s16) 0, (arg2 & 7) | 0x20);
}

void func_80B45460(Actor *arg0, GlobalContext *arg1) {
    Actor_SpawnAsChild(arg1 + 0x1CA0, arg0, arg1, 0x200, arg0->home.pos.x, arg0->home.pos.y, arg0->home.pos.z, (s16) 0, (s16) 0, (s16) 0, 0x40);
}

void func_80B454BC(EnInvadepoh *arg0, GlobalContext *arg1) {
    D_80B503F0 = Actor_Spawn(arg1 + 0x1CA0, arg1, 0x200, arg0->actor.world.pos.x, arg0->actor.world.pos.y, arg0->actor.world.pos.z, (s16) 0, (s16) 0, (s16) 0, (s16) 0x60);
}

void EnInvadepoh_SetSysMatrix(f32 *arg0) {
    MtxF *temp_v0;

    temp_v0 = SysMatrix_GetCurrentState();
    temp_v0->mf[3][0] = arg0->unk_0;
    temp_v0->mf[3][1] = arg0[1];
    temp_v0->mf[3][2] = arg0[2];
}

s32 func_80B45550(EnInvadepoh *arg0, GlobalContext *arg1, f32 arg2, s32 arg3) {
    s32 sp34;
    void *temp_s0;
    void *temp_s0_2;
    void *phi_s0;

    temp_s0 = arg1->actorCtx.actorList[10].first;
    sp34 = 0;
    phi_s0 = temp_s0;
    if (temp_s0 != 0) {
loop_1:
        if ((phi_s0->id == 5) && (phi_s0->update != 0) && (arg0->actor.room == phi_s0->room) && (Math3D_DistanceSquared(phi_s0 + 0x24, arg0 + 0x24) < arg2)) {
            phi_s0->unk_1A7 = (s8) arg3;
            sp34 = 1;
        } else {
            temp_s0_2 = phi_s0->next;
            phi_s0 = temp_s0_2;
            if (temp_s0_2 != 0) {
                goto loop_1;
            }
        }
    }
    return sp34;
}

void EnInvadepoh_SetTextID(Actor *arg0, GlobalContext *arg1, s32 arg2) {
    s16 temp_a3;

    temp_a3 = arg2 & 0xFFFF;
    arg0->unk_376 = temp_a3;
    func_801518B0(arg1, temp_a3 & 0xFFFF, arg0);
}

void func_80B45648(EnInvadepoh *arg0) {
    s16 *temp_s0;
    s16 phi_s1;
    s16 *phi_s0;

    phi_s1 = (s16) arg0->actor.cutscene;
    phi_s0 = &D_80B50404;
    do {
        *phi_s0 = phi_s1;
        temp_s0 = phi_s0 + 2;
        phi_s1 = ActorCutscene_GetAdditionalCutscene(phi_s1);
        phi_s0 = temp_s0;
    } while (temp_s0 != &D_80B5040A);
}

s32 func_80B456A8(GlobalContext *arg0, Vec3f *arg1) {
    f32 sp34;
    f32 sp30;
    s32 sp24;
    f32 temp_f12;
    f32 temp_f2;

    func_800B4EDC(arg0, arg1, (Vec3f *) &sp34, &sp30);
    if ((sp3C > 1.0f) && (temp_f2 = sp34 * sp30, (fabsf(temp_f2) < 1.0f)) && (temp_f12 = sp38 * sp30, (fabsf(temp_f12) < 1.0f)) && (sp24 = (s32) (sp3C * sp30 * 16352.0f) + 0x3FE0, ((sp24 < func_80178A94((s32) ((temp_f2 * 160.0f) + 160.0f), (s32) ((temp_f12 * -120.0f) + 120.0f))) != 0))) {
        return 1;
    }
    return 0;
}

void func_80B457A0(EnInvadepoh *arg0) {
    Actor *temp_v0;
    f32 temp_f0;
    s32 temp_s0;
    u8 *temp_v0_2;
    Actor **phi_s2;
    f32 phi_f20;
    u8 *phi_s1;
    s32 phi_s0;
    f32 phi_f20_2;
    s32 phi_s5;
    f32 phi_f20_3;
    s32 phi_s5_2;

    phi_f20 = 3.4028235e38f;
    phi_s0 = 0;
    phi_f20_2 = 3.4028235e38f;
    phi_s5 = -1;
    phi_s5_2 = -1;
    if ((s32) arg0->unk379 > 0) {
        phi_s2 = &D_80B50320;
        phi_s1 = &D_80B50340;
        do {
            temp_v0 = *phi_s2;
            phi_f20_3 = phi_f20;
            if ((temp_v0 != 0) && (temp_v0->unk_38B != 0)) {
                temp_f0 = Math3D_DistanceSquared(temp_v0 + 0x24, arg0 + 0x24);
                if (temp_f0 < phi_f20) {
                    phi_f20_3 = temp_f0;
                    phi_s5_2 = phi_s0;
                }
            }
            temp_s0 = phi_s0 + 1;
            *phi_s1 &= -3;
            phi_s2 += 4;
            phi_f20 = phi_f20_3;
            phi_s1 += 1;
            phi_s0 = temp_s0;
            phi_f20_2 = phi_f20_3;
            phi_s5 = phi_s5_2;
        } while (temp_s0 < (s32) arg0->unk379);
    }
    D_80B50348 = 0;
    temp_v0_2 = phi_s5 + &D_80B50340;
    if (phi_f20_2 <= 4000000.0f) {
        *temp_v0_2 |= 2;
        if (phi_f20_2 <= 115600.0f) {
            D_80B50348 = 1;
        }
    }
}

Actor *func_80B458D8(void) {
    s32 temp_v1;
    u8 *phi_v0;
    s32 phi_v1;

    phi_v0 = &D_80B50340;
    phi_v1 = 0;
loop_1:
    if ((phi_v0->unk_0 & 2) != 0) {
        return (&D_80B50320)[phi_v1];
    }
    if ((phi_v0[1] & 2) != 0) {
        return *(&D_80B50324 + (phi_v1 * 4));
    }
    if ((phi_v0[2] & 2) != 0) {
        return *(&D_80B50328 + (phi_v1 * 4));
    }
    if ((phi_v0[3] & 2) != 0) {
        return *(&D_80B5032C + (phi_v1 * 4));
    }
    temp_v1 = phi_v1 + 4;
    phi_v0 += 4;
    phi_v1 = temp_v1;
    if (temp_v1 == 8) {
        return NULL;
    }
    goto loop_1;
}

s8 func_80B45980(unkstructInvadepoh1 *arg0, s32 arg1) {
    s32 temp_a1;
    s32 temp_v1;
    unkstructInvadepoh1 *phi_v0;
    s32 phi_v1;
    s32 phi_v1_2;

    temp_a1 = arg1 - 1;
    phi_v0 = arg0;
    phi_v1 = 0;
    phi_v1_2 = 0;
    if (temp_a1 > 0) {
loop_1:
        phi_v1_2 = phi_v1;
        if (!(Rand_ZeroOne() <= phi_v0->unk04)) {
            temp_v1 = phi_v1 + 1;
            phi_v0 += 8;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
            if (temp_v1 != temp_a1) {
                goto loop_1;
            }
        }
    }
    return *((phi_v1_2 * 8) + arg0);
}

void func_80B459E8(EnInvadePohStruct *arg0, unkstructInvadepoh4 *arg1) {
    arg0->unk8 = arg1;
    arg0->unkE = 0;
    arg0->unk4 = arg1->unk00;
    arg0->unkF = **arg1->unk04;
    if (arg0->unk4 == 2) {
        arg0 = arg0;
        arg0->unkC = Rand_S16Offset(arg1->unk10, arg1->unk12);
    }
}

void func_80B45A4C(EnInvadePohStruct *s, unkstructInvadepoh4 **u) {
    s8 temp_a1;
    unkstructInvadepoh0 *temp_v1;

    temp_a1 = s->unkE;
    temp_v1 = s->unk8->unk04;
    if ((s32) temp_a1 < (temp_v1->unk04 - 1)) {
        s->unkE = temp_a1 + 1;
        s->unkF = temp_v1->unk00[s->unkE];
    }
}

void func_80B45A94(EnInvadePohStruct *s, unkstructInvadepoh4 **u) {
    EnInvadePohStruct *temp_a2;
    s8 temp_a1;
    s8 temp_a3;
    unkstructInvadepoh0 *temp_v1;
    unkstructInvadepoh1 *temp_a0;
    unkstructInvadepoh4 *temp_v0;

    temp_a2 = s;
    temp_v0 = temp_a2->unk8;
    temp_a3 = temp_a2->unkE;
    temp_v1 = temp_v0->unk04;
    if ((s32) temp_a3 < (temp_v1->unk04 - 1)) {
        temp_a2->unkE = temp_a3 + 1;
        temp_a2->unkF = temp_v1->unk00[temp_a2->unkE];
        return;
    }
    temp_a0 = temp_v0->unk0C;
    temp_a1 = temp_v0->unk08;
    s = temp_a2;
    func_80B459E8(s, u[func_80B45980(temp_a0, (s32) temp_a1, temp_a2, temp_a3)]);
}

void func_80B45B1C(EnInvadePohStruct *s, unkstructInvadepoh4 **u) {
    EnInvadePohStruct *temp_a2;
    s16 temp_v1_2;
    s8 temp_a1;
    s8 temp_a3;
    unkstructInvadepoh0 *temp_v1;
    unkstructInvadepoh1 *temp_a0;
    unkstructInvadepoh4 *temp_v0;

    temp_a2 = s;
    temp_v0 = temp_a2->unk8;
    temp_a3 = temp_a2->unkE;
    temp_v1 = temp_v0->unk04;
    if ((s32) temp_a3 < (temp_v1->unk04 - 1)) {
        temp_a2->unkE = temp_a3 + 1;
        temp_a2->unkF = temp_v1->unk00[temp_a2->unkE];
        return;
    }
    temp_v1_2 = temp_a2->unkC;
    if ((s32) temp_v1_2 > 0) {
        temp_a2->unkC = temp_v1_2 - 1;
        return;
    }
    temp_a0 = temp_v0->unk0C;
    temp_a1 = temp_v0->unk08;
    s = temp_a2;
    func_80B459E8(s, u[func_80B45980(temp_a0, (s32) temp_a1, temp_a2, temp_a3)]);
}

void func_80B45BB8(f32 *arg0) {
    s32 temp_a1;

    temp_a1 = arg0->unk_0;
    if ((temp_a1 != 0) && (arg0[2] != 0)) {
        *(&D_80B4EC0C + (arg0->unk_4 * 4))(temp_a1);
    }
}

void func_80B45C04(f32 *arg0, ? *arg1, s32 arg2, ? *arg3, s32 arg4, Vec3s *arg5, s16 arg6, f32 arg7, f32 arg8, f32 arg9) {
    void *temp_v0;
    void *temp_v0_2;

    Math_Vec3s_Copy(arg0 + 0x26, arg5);
    arg0->unk_2C = arg6;
    arg0[12] = arg7;
    arg0[14] = arg8;
    arg0[15] = arg9;
    if (arg1 != 0) {
        temp_v0 = *(arg1 + (arg2 * 4));
        arg0->unk_0 = arg1;
        arg0->unk_C = 0;
        arg0->unk_E = 0;
        arg0[2] = temp_v0;
        arg0->unk_4 = (s8) temp_v0->unk_0;
        arg0->unk_F = (s8) **temp_v0->unk_4;
    }
    if (arg3 != 0) {
        temp_v0_2 = *(arg3 + (arg4 * 4));
        arg0[4] = arg3;
        arg0->unk_1C = 0;
        arg0->unk_1E = 0;
        arg0[6] = temp_v0_2;
        arg0->unk_14 = (s8) temp_v0_2->unk_0;
        arg0->unk_1F = (s8) **temp_v0_2->unk_4;
    }
}

void func_80B45CE0(f32 *arg0) {
    ? sp3C;
    s16 sp38;
    s16 sp36;
    s16 sp34;
    s16 *temp_a1;
    s16 temp_a1_2;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s32 temp_f16;
    s32 phi_v0;
    s32 phi_a2;
    s16 phi_a2_2;
    s16 phi_v1;

    temp_a1 = &sp34;
    sp34 = arg0->unk_26 - arg0->unk_20;
    sp36 = arg0->unk_28 - arg0->unk_22;
    sp38 = arg0->unk_2A - arg0->unk_24;
    Math_Vec3s_ToVec3f((Vec3f *) &sp3C, (Vec3s *) temp_a1);
    Math_Vec3f_Scale((Vec3f *) &sp3C, arg0[12]);
    Math_Vec3f_ToVec3s((Vec3s *) &sp34, (Vec3f *) &sp3C);
    if ((s32) sp34 < 0) {
        sp34 = (s32) sp34 * -1;
    }
    if ((s32) sp36 < 0) {
        sp36 = (s32) sp36 * -1;
    }
    if ((s32) sp38 < 0) {
        sp38 = (s32) sp38 * -1;
    }
    temp_v0 = arg0->unk_2C;
    if ((s32) temp_v0 < (s32) sp34) {
        sp34 = temp_v0;
    }
    phi_v0 = (s32) arg0->unk_2C;
    if ((s32) arg0->unk_2C < (s32) sp36) {
        sp36 = (s16) (s32) arg0->unk_2C;
        phi_v0 = (s32) arg0->unk_2C;
    }
    if (phi_v0 < (s32) sp38) {
        sp38 = (s16) phi_v0;
    }
    Math_ScaledStepToS(arg0 + 0x20, arg0->unk_26, sp34);
    Math_ScaledStepToS(arg0 + 0x22, arg0->unk_28, sp36);
    Math_ScaledStepToS(arg0 + 0x24, arg0->unk_2A, sp38);
    Math_StepToF(arg0 + 0x34, arg0[14], arg0[15]);
    temp_a1_2 = arg0->unk_42;
    temp_v0_2 = arg0->unk_40;
    if (temp_a1_2 != temp_v0_2) {
        temp_f16 = (s32) ((f32) (s16) (temp_a1_2 - temp_v0_2) * arg0[17]);
        phi_a2 = (s32) (s16) temp_f16;
        if ((s32) (s16) temp_f16 < 0) {
            phi_a2 = (s32) (s16) ((s32) (s16) temp_f16 * -1);
        }
        if (phi_a2 < 0x64) {
            phi_a2_2 = 0x64;
        } else {
            temp_v0_3 = arg0->unk_48;
            phi_v1 = (s16) phi_a2;
            if ((s32) temp_v0_3 < phi_a2) {
                phi_v1 = temp_v0_3;
            }
            phi_a2_2 = phi_v1;
        }
        Math_ScaledStepToS(arg0 + 0x40, temp_a1_2, phi_a2_2);
    }
    func_80B45BB8(arg0);
    func_80B45BB8(arg0 + 0x10);
}

void func_80B45EC8(EnInvadepoh *arg0, GlobalContext *arg1, s32 arg2) {
    f32 spB0;
    f32 spAC;
    f32 spA8;
    f32 spA4;
    f32 spA0;
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 *temp_s4;
    f32 *temp_s5;
    f32 *temp_s6;
    f32 temp_f20;
    f32 temp_f6;
    f32 temp_f8;
    s16 temp_s0;
    s32 temp_s1;
    s16 phi_s0;
    s32 phi_s1;

    phi_s0 = 0;
    phi_s1 = 0;
    if (arg2 > 0) {
        temp_s6 = &sp90;
        temp_s5 = &sp9C;
        temp_s4 = &spA8;
        do {
            temp_s0 = phi_s0 + (s16) (s32) (65536.0f / (f32) arg2);
            temp_f20 = (Rand_ZeroOne() * 0.5f) + 0.5f;
            spA8 = Math_SinS(temp_s0) * temp_f20;
            spB0 = Math_CosS(temp_s0) * temp_f20;
            temp_f8 = Rand_ZeroOne() * 16.0f;
            spA0 = -8.0f;
            sp9C = (temp_f8 + (spA8 * 30.0f)) - 8.0f;
            temp_f6 = ((Rand_ZeroOne() * 16.0f) + (spB0 * 30.0f)) - 8.0f;
            sp90 = sp9C * -0.025f;
            spA4 = temp_f6;
            sp94 = spA0 * -0.025f;
            sp98 = temp_f6 * -0.025f;
            spA8 = (spA8 * 100.0f) + arg0->actor.world.pos.x;
            spAC = ((Rand_ZeroOne() * 180.0f) + arg0->actor.world.pos.y) - 90.0f;
            spB0 = (spB0 * 100.0f) + arg0->actor.world.pos.z;
            EffectSsKiraKira_SpawnDispersed(arg1, (Vec3f *) temp_s4, (Vec3f *) temp_s5, (Vec3f *) temp_s6, &D_80B4EC18, &D_80B4EC1C, (s16) 0x1770, -0x28);
            temp_s1 = phi_s1 + 1;
            phi_s0 = temp_s0;
            phi_s1 = temp_s1;
        } while (temp_s1 != arg2);
    }
}

? func_80B46118(Vec3f *arg0) {
    ? *sp1C;
    s32 temp_v0;
    ? *phi_v1;
    s32 phi_v0;

    phi_v1 = &D_80B50350;
    phi_v0 = 0;
loop_1:
    temp_v0 = phi_v0 + 1;
    phi_v0 = temp_v0;
    if ((s32) phi_v1->unk_1 <= 0) {
        phi_v1->unk_0 = 0;
        phi_v1->unk_1 = 0x28;
        sp1C = phi_v1;
        Math_Vec3f_Copy(phi_v1 + 4, arg0);
        phi_v1->unk_2 = 0;
        return 1;
    }
    phi_v1 += 0x10;
    if (temp_v0 == 0xA) {
        return 0;
    }
    goto loop_1;
}

void func_80B46184(unkStruct80B50350 *unkStruct) {
    u8 temp_v0;
    u8 temp_v0_2;

    if ((s32) unkStruct->unk1 >= 0x15) {
        temp_v0 = unkStruct->unk2;
        if ((s32) temp_v0 < 0x7D) {
            unkStruct->unk2 = temp_v0 + 0xA;
            return;
        }
        unkStruct->unk2 = 0x87;
        return;
    }
    temp_v0_2 = unkStruct->unk2;
    if ((s32) temp_v0_2 >= 0xE) {
        unkStruct->unk2 = temp_v0_2 - 0xD;
        return;
    }
    unkStruct->unk2 = 0;
}

s32 func_80B461DC(void) {
    s32 temp_s1;
    ? *phi_s0;
    s32 phi_s1;
    s32 phi_s4;

    phi_s0 = &D_80B50350;
    phi_s1 = 0;
    phi_s4 = 0;
    do {
        if ((s32) phi_s0->unk_1 > 0) {
            *(&D_80B4EC20 + (phi_s0->unk_0 * 4))(phi_s0);
            phi_s0->unk_1 = (s8) (phi_s0->unk_1 - 1);
            phi_s4 = 1;
        }
        temp_s1 = phi_s1 + 1;
        phi_s0 += 0x10;
        phi_s1 = temp_s1;
    } while (temp_s1 != 0xA);
    return phi_s4;
}

void func_80B4627C(EnInvadepoh *this, GlobalContext *globalCtx) {
    Path *temp_a3;
    s32 temp_v0;
    s8 temp_a2;
    u32 temp_v0_2;
    u8 temp_v1;
    u8 phi_v1;
    s8 phi_a2;
    s8 phi_a2_2;

    this->actor.flags |= 0x20;
    temp_a3 = globalCtx->setupPathList;
    phi_v1 = ((s32) this->actor.params >> 8) & 0x7F;
    phi_a2 = 1;
loop_1:
    temp_v1 = temp_a3[phi_v1].unk1;
    phi_v1 = temp_v1;
    phi_a2_2 = phi_a2;
    if (temp_v1 != 0xFF) {
        temp_a2 = phi_a2 + 1;
        phi_a2 = temp_a2;
        phi_a2_2 = temp_a2;
        if (temp_a2 != 8) {
            goto loop_1;
        }
    }
    this->unk379 = phi_a2_2;
    func_80B451A0(this, globalCtx, phi_a2_2, temp_a3);
    func_80B45648(this);
    func_800BC154(globalCtx, &globalCtx->actorCtx, (Actor *) this, 0U);
    temp_v0 = D_80B4E940;
    if (temp_v0 == 1) {
        func_80B46DA8(this);
        return;
    }
    if (temp_v0 == 2) {
        if ((s32) gSaveContext.time < 0x1AD8) {
            func_80B46DA8(this);
            return;
        }
        func_80B454BC(this, globalCtx);
        func_80B452EC(this, globalCtx);
        func_801A89A8(0x800D);
        func_80B46F88(this);
        return;
    }
    if (temp_v0 == 3) {
        temp_v0_2 = gSaveContext.entranceIndex;
        if (temp_v0_2 == 0x6460) {
            func_80B471C0(this);
            return;
        }
        if (temp_v0_2 == 0x6470) {
            func_80B47248(this);
            return;
        }
        func_80B47248(this);
        return;
    }
    if (temp_v0 == 4) {
        func_80B47304(this);
    }
}

void EnInvadepoh_InitAlien(EnInvadepoh *this, GlobalContext *globalCtx) {
    ColliderCylinder *sp20;
    ColliderCylinder *temp_a1;

    Actor_ProcessInitChain((Actor *) this, D_80B4EC24);
    temp_a1 = &this->collider;
    sp20 = temp_a1;
    Collider_InitCylinder(globalCtx, temp_a1);
    ActorShape_Init(&this->actor.shape, 6800.0f, func_800B4088, 150.0f);
    this->actor.shape.shadowAlpha = 0x8C;
    this->actor.flags = 0x80001010;
    if ((((s32) this->actor.params >> 4) & 0xF) == 0xD) {
        this->actor.update = func_80B4D670;
        this->actor.world.pos.y = this->actor.home.pos.y + 150.0f;
    } else {
        this->actor.update = func_80B47BAC;
        Collider_SetCylinder(globalCtx, sp20, (Actor *) this, &D_80B4E8B0);
        this->actor.colChkInfo.mass = 0x28;
    }
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0x23E);
    if ((s32) this->bankIndex < 0) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void EnInvadepoh_InitParentCow(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor_ProcessInitChain((Actor *) this, D_80B4EC34);
    this->actor.update = func_80B47FA8;
    Actor_SpawnAsChild(&globalCtx->actorCtx, (Actor *) this, globalCtx, 0x200, 0.0f, 0.0f, 0.0f, (s16) 0, (s16) 0, (s16) 0, 0x30);
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0x146);
    if ((s32) this->bankIndex < 0) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void EnInvadepoh_InitChildCow(EnInvadepoh *this, GlobalContext *globalCtx) {
    EnInvadepoh *temp_a0;

    temp_a0 = this;
    this = this;
    Actor_ProcessInitChain((Actor *) temp_a0, D_80B4EC44);
    this->actor.update = func_80B481C4;
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0x146);
    if ((s32) this->bankIndex < 0) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void EnInvadepoh_InitRomani(EnInvadepoh *this, GlobalContext *globalCtx) {
    s32 sp28;
    ColliderCylinder *sp24;
    ColliderCylinder *temp_a1;
    s32 temp_v1;
    s32 temp_v1_2;
    u16 temp_v0;

    temp_v1 = (s32) this->actor.params >> 4;
    temp_v1_2 = temp_v1 & 0xF;
    sp28 = temp_v1_2;
    Actor_ProcessInitChain((Actor *) this, D_80B4EC54);
    if ((temp_v1_2 == 7) || (temp_v1_2 == 0xC)) {
        this->actor.targetMode = 3;
    } else {
        this->actor.targetMode = 6;
    }
    sp28 = temp_v1_2;
    func_800BC154(globalCtx, &globalCtx->actorCtx, (Actor *) this, 4U);
    temp_a1 = &this->collider;
    sp24 = temp_a1;
    Collider_InitCylinder(globalCtx, temp_a1);
    if (temp_v1_2 != 4) {
        sp28 = temp_v1_2;
        ActorShape_Init(&this->actor.shape, 0.0f, func_800B3FC0, 18.0f);
        Collider_SetCylinder(globalCtx, sp24, (Actor *) this, &D_80B4E8DC);
        this->actor.colChkInfo.mass = 0xFF;
    }
    if ((temp_v1 & 0xF) == 4) {
        this->actor.update = func_80B48620;
    } else if ((temp_v1 & 0xF) == 5) {
        this->actor.update = func_80B48FB0;
        this->actor.flags = 0x19;
    } else if ((temp_v1 & 0xF) == 7) {
        this->actor.update = func_80B49F88;
    } else if ((temp_v1 & 0xF) == 8) {
        this->actor.update = func_80B4A9C8;
    } else if ((temp_v1 & 0xF) == 9) {
        this->actor.update = func_80B4B0C4;
    } else {
        this->actor.update = func_80B4CE54;
    }
    sp28 = temp_v1 & 0xF;
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0xB7);
    if ((s32) this->bankIndex < 0) {
        sp28 = temp_v1 & 0xF;
        Actor_MarkForDeath((Actor *) this);
    }
    if ((temp_v1 & 0xF) == 5) {
        if ((gSaveContext.weekEventReg[22] & 1) != 0) {
            Actor_MarkForDeath((Actor *) this);
            return;
        }
        /* Duplicate return node #34. Try simplifying control flow for better match */
        return;
    }
    if ((temp_v1 & 0xF) == 7) {
        temp_v0 = gSaveContext.time;
        if (((s32) temp_v0 < 0x4000) && ((s32) temp_v0 >= 0x1800)) {
            Actor_MarkForDeath((Actor *) this);
            return;
        }
        /* Duplicate return node #34. Try simplifying control flow for better match */
        return;
    }
    if ((temp_v1 & 0xF) != 8) {
        if ((temp_v1 & 0xF) == 9) {
            if (gSaveContext.entranceIndex != 0x6460) {
                Actor_MarkForDeath((Actor *) this);
                return;
            }
            /* Duplicate return node #34. Try simplifying control flow for better match */
            return;
        }
        if ((temp_v1 & 0xF) == 0xC) {
            if ((gSaveContext.weekEventReg[22] & 1) == 0) {
                Actor_MarkForDeath((Actor *) this);
            }
            D_80B503F4 = this;
        }
        /* Duplicate return node #34. Try simplifying control flow for better match */
    }
}

void func_80B468B4(EnInvadepoh *this, GlobalContext *globalCtx) {
    EnInvadepoh *temp_a0;
    s32 temp_v0;

    temp_a0 = this;
    this = this;
    Actor_ProcessInitChain((Actor *) temp_a0, D_80B4EC68);
    this->actor.update = func_80B49B1C;
    this->actor.draw = func_80B4E3F0;
    func_800BC154(globalCtx, &globalCtx->actorCtx, (Actor *) this, 4U);
    temp_v0 = D_80B4E940;
    if ((temp_v0 == 1) || ((s32) gSaveContext.time < 0x1AD8)) {
        this->actor.world.pos.x += D_80B4E934.unk_0;
        this->actor.world.pos.y += D_80B4E934.unk_4 + 3000.0f;
        this->actor.world.pos.z += D_80B4E934.unk_8;
        func_80B491EC(this);
        return;
    }
    if (temp_v0 == 2) {
        this->actor.world.pos.y += 1500.0f;
        func_80B49628(this);
        return;
    }
    Actor_MarkForDeath((Actor *) this);
}

void EnInvadepoh_InitDog(EnInvadepoh *this, GlobalContext *globalCtx) {
    ColliderCylinder *sp20;
    ColliderCylinder *temp_a1;

    Actor_ProcessInitChain((Actor *) this, D_80B4EC80);
    this->actor.update = func_80B4B8BC;
    temp_a1 = &this->collider;
    sp20 = temp_a1;
    Collider_InitCylinder(globalCtx, temp_a1);
    Collider_SetCylinder(globalCtx, temp_a1, (Actor *) this, &D_80B4E908);
    this->actor.colChkInfo.mass = 0x50;
    ActorShape_Init(&this->actor.shape, 0.0f, func_800B3FC0, 24.0f);
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0x132);
    if ((s32) this->bankIndex < 0) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void EnInvadepoh_InitCremia(EnInvadepoh *this, GlobalContext *globalCtx) {
    ColliderCylinder *sp20;
    ColliderCylinder *temp_a1;

    Actor_ProcessInitChain((Actor *) this, D_80B4EC98);
    this->actor.update = func_80B4C3A0;
    func_800BC154(globalCtx, &globalCtx->actorCtx, (Actor *) this, 4U);
    temp_a1 = &this->collider;
    sp20 = temp_a1;
    Collider_InitCylinder(globalCtx, temp_a1);
    Collider_SetCylinder(globalCtx, temp_a1, (Actor *) this, &D_80B4E8DC);
    this->actor.colChkInfo.mass = 0xFE;
    ActorShape_Init(&this->actor.shape, 0.0f, func_800B3FC0, 18.0f);
    this->bankIndex = Object_GetIndex(&globalCtx->objectCtx, 0xA7);
    if ((s32) this->bankIndex < 0) {
        Actor_MarkForDeath((Actor *) this);
    }
    if ((gSaveContext.weekEventReg[22] & 1) == 0) {
        Actor_MarkForDeath((Actor *) this);
    }
    D_80B503F8 = this;
}

void EnInvadepoh_Init(Actor *thisx, GlobalContext *globalCtx) {
    EnInvadepoh *this = (EnInvadepoh *) thisx;
    *(&D_80B4ECB0 + ((((s32) this->actor.params >> 4) & 0xF) * 4))();
}

void func_80B46BB0(EnInvadepoh *this, GlobalContext *globalCtx) {

}

void func_80B46BC0(EnInvadepoh *this, GlobalContext *globalCtx) {
    s32 sp18;

    sp18 = this->actor.params & 7;
    Collider_DestroyCylinder(globalCtx, &this->collider);
    (&D_80B50320)[sp18] = NULL;
}

void func_80B46C08(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *temp_v0;
    Actor *temp_v0_2;

    temp_v0 = this->actor.parent;
    if (temp_v0 != 0) {
        temp_v0->child = NULL;
    }
    temp_v0_2 = this->actor.child;
    if (temp_v0_2 != 0) {
        temp_v0_2->parent = NULL;
    }
}

void func_80B46C34(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *temp_v0;

    temp_v0 = this->actor.parent;
    if (temp_v0 != 0) {
        temp_v0->child = NULL;
    }
}

void func_80B46C50(EnInvadepoh *this, GlobalContext *globalCtx) {
    Collider_DestroyCylinder(globalCtx, &this->collider);
}

void func_80B46C7C(EnInvadepoh *this, GlobalContext *globalCtx) {
    D_80B503F0 = NULL;
}

void func_80B46C94(EnInvadepoh *this, GlobalContext *globalCtx) {
    Collider_DestroyCylinder(globalCtx, &this->collider);
}

void func_80B46CC0(EnInvadepoh *this, GlobalContext *globalCtx) {
    Collider_DestroyCylinder(globalCtx, &this->collider);
    D_80B503F8 = NULL;
}

void func_80B46CF4(EnInvadepoh *this, GlobalContext *globalCtx) {
    Collider_DestroyCylinder(globalCtx, &this->collider);
    D_80B503F4 = NULL;
}

void func_80B46D28(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *temp_v0;
    ColliderCylinder *temp_a1;

    temp_a1 = &this->collider;
    this = this;
    Collider_DestroyCylinder(globalCtx, temp_a1);
    temp_v0 = this->actor.child;
    if (temp_v0 != 0) {
        temp_v0->parent = NULL;
    }
}

void EnInvadepoh_Destroy(Actor *thisx, GlobalContext *globalCtx) {
    EnInvadepoh *this = (EnInvadepoh *) thisx;
    *(&D_80B4ECE8 + ((((s32) this->actor.params >> 4) & 0xF) * 4))();
}

void func_80B46DA8(EnInvadepoh *this) {
    D_80B4E940 = 1;
    this->actionFunc = func_80B46DC8;
}

void func_80B46DC8(EnInvadepoh *this, GlobalContext *globalCtx) {
    u16 temp_v0;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 < 0x4000) && ((s32) temp_v0 >= 0x1AAA)) {
        func_80B454BC(this, globalCtx);
        func_80B452EC(this, globalCtx);
        func_80B46E20(this);
    }
}

void func_80B46E20(EnInvadepoh *this) {
    D_80B4E940 = 2;
    this->actionTimer = (s16) 2;
    this->actionFunc = func_80B46E44;
}

void func_80B46E44(EnInvadepoh *this, GlobalContext *globalCtx) {
    EnInvadepoh *temp_a1;
    s16 temp_v0;

    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    this = this;
    temp_a1 = this;
    if (ActorCutscene_GetCanPlayNext(D_80B50404) != 0) {
        this = temp_a1;
        ActorCutscene_StartAndSetUnkLinkFields(D_80B50404, (Actor *) temp_a1);
        func_80B46EC0(this);
        return;
    }
    ActorCutscene_SetIntentToPlay(D_80B50404);
}

void func_80B46EC0(EnInvadepoh *this) {
    D_80B4E940 = 2;
    this->actionTimer = 0xA0;
    this->actionFunc = func_80B46EE8;
}

void func_80B46EE8(EnInvadepoh *this, GlobalContext *globalCtx) {
    s32 temp_v1;
    u8 *temp_v0;
    s16 phi_a2;
    s16 *phi_a1;
    s32 phi_v1;
    s16 phi_a2_2;

    phi_a2 = this->actionTimer;
    phi_a1 = D_80B4ED20;
    phi_v1 = 0;
    do {
        temp_v0 = &(&D_80B50340)[phi_v1];
        phi_a2_2 = phi_a2;
        if (phi_a2 == *phi_a1) {
            *temp_v0 |= 1;
            phi_a2_2 = this->actionTimer;
        }
        temp_v1 = phi_v1 + 1;
        phi_a2 = phi_a2_2;
        phi_a1 += 2;
        phi_v1 = temp_v1;
    } while (temp_v1 != 8);
    this->actionTimer = phi_a2_2 - 1;
    if ((s32) this->actionTimer <= 0) {
        ActorCutscene_Stop(D_80B50404);
        func_801A89A8(0x800D);
        func_80B46F88(this);
    }
}

void func_80B46F88(EnInvadepoh *this) {
    D_80B4E940 = 2;
    this->actionFunc = func_80B46FA8;
}

void func_80B46FA8(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *temp_a0_2;
    EnInvadepoh *temp_a0;
    EnInvadepoh *temp_a2;
    s32 temp_v0_2;
    s8 temp_a1;
    u16 temp_v0;
    Actor **phi_v1;
    s32 phi_v0;

    temp_a2 = this;
    temp_v0 = gSaveContext.time;
    temp_a0 = temp_a2;
    if (((s32) temp_v0 < 0x4000) && ((s32) temp_v0 >= 0x3800)) {
        gSaveContext.weekEventReg[22] |= 1;
        func_80B47064(temp_a2);
        return;
    }
    this = temp_a2;
    func_80B457A0(temp_a0, temp_a2);
    temp_a1 = this->unk379;
    phi_v1 = &D_80B50320;
    phi_v0 = 0;
    if ((s32) temp_a1 > 0) {
loop_4:
        temp_a0_2 = *phi_v1;
        temp_v0_2 = phi_v0 + 1;
        phi_v0 = temp_v0_2;
        if ((temp_a0_2 != 0) && (temp_a0_2->unk_38A != 0)) {
            func_80B47278(this);
            return;
        }
        phi_v1 += 4;
        if (temp_v0_2 >= (s32) temp_a1) {
            /* Duplicate return node #8. Try simplifying control flow for better match */
            return;
        }
        goto loop_4;
    }
}

void func_80B47064(EnInvadepoh *this) {
    D_80B4E940 = 3;
    this->actionFunc = func_80B47084;
}

void func_80B47084(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (ActorCutscene_GetCanPlayNext(D_80B50406) != 0) {
        ActorCutscene_StartAndSetUnkLinkFields((&D_80B50404)[1], (Actor *) this);
        func_80B470E0(this);
        return;
    }
    ActorCutscene_SetIntentToPlay((&D_80B50404)[1]);
}

void func_80B470E0(EnInvadepoh *this) {
    D_80B4E940 = 3;
    this->actionTimer = 0x6E;
    this->actionFunc = func_80B47108;
}

void func_80B47108(EnInvadepoh *this, GlobalContext *globalCtx) {
    s16 temp_v0;
    s16 phi_v0;

    temp_v0 = this->actionTimer;
    phi_v0 = temp_v0;
    if (temp_v0 == 0x64) {
        this = this;
        func_801A3098(0x19U);
        phi_v0 = this->actionTimer;
    }
    this->actionTimer = phi_v0 - 1;
    if ((s32) this->actionTimer <= 0) {
        globalCtx->nextEntranceIndex = 0x6460;
        gSaveContext.nextCutsceneIndex = 0;
        globalCtx->sceneLoadFlag = 0x14;
        globalCtx->unk_1887F = 0x49;
        gSaveContext.nextTransition = 0x48;
        D_801BDAA0 = 1;
        D_801BDA9C = 0;
        func_80B47248(this);
    }
}

void func_80B471C0(EnInvadepoh *this) {
    D_80B4E940 = 3;
    this->actionFunc = func_80B471E0;
}

void func_80B471E0(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (D_80B4E998 != 0) {
        globalCtx->nextEntranceIndex = 0x6470;
        gSaveContext.nextCutsceneIndex = 0;
        globalCtx->sceneLoadFlag = 0x14;
        globalCtx->unk_1887F = 0x48;
        gSaveContext.nextTransition = 0x48;
        func_80B47248(this);
    }
}

void func_80B47248(EnInvadepoh *this) {
    D_80B4E940 = 3;
    this->actionFunc = func_80B47268;
}

void func_80B47268(EnInvadepoh *this, GlobalContext *globalCtx) {

}

void func_80B47278(EnInvadepoh *this) {
    D_80B4E940 = 4;
    this->actionFunc = func_80B47298;
}

void func_80B47298(EnInvadepoh *this, GlobalContext *globalCtx) {
    globalCtx->nextEntranceIndex = 0x6400;
    gSaveContext.nextCutsceneIndex = 0xFFF3;
    globalCtx->sceneLoadFlag = 0x14;
    globalCtx->unk_1887F = 0x48;
    gSaveContext.nextTransition = 0x48;
    gSaveContext.weekEventReg[89] |= 0x10;
    func_80B47304(this);
}

void func_80B47304(EnInvadepoh *this) {
    D_80B4E940 = 4;
    this->actionFunc = func_80B47324;
}

void func_80B47324(EnInvadepoh *this, GlobalContext *globalCtx) {

}

void EnInvadepoh_Update(Actor *thisx, GlobalContext *globalCtx) {
    EnInvadepoh *this = (EnInvadepoh *) thisx;
    this->actionFunc(this, globalCtx);
    if (func_80B461DC() != 0) {
        this->actor.draw = func_80B4D9B4;
        return;
    }
    this->actor.draw = NULL;
}

void func_80B47380(Actor *arg0) {
    arg0->unk_2B0 = (u8) (arg0->unk_2B0 & ~1);
    arg0->unk_2B1 = (u8) (arg0->unk_2B1 & ~1);
    arg0->unk_2B2 = (u8) (arg0->unk_2B2 & ~1);
    arg0->flags &= 0x7FFFFFFF;
    arg0->unk_389 = 0;
    arg0->draw = NULL;
    arg0->unk_38B = 0;
    arg0->unk_38C = 0;
    arg0->unk_38D = 0;
    arg0[2].velocity.x = func_80B473E4;
}

void func_80B473E4(EnInvadepoh *this, GlobalContext *globalCtx) {
    func_80B442E4(this);
    func_80B447C0((Actor *) this, globalCtx);
    func_80B43DD4(this, 0x320, 0);
    if (((&D_80B50340)[this->actor.params & 7] & 1) != 0) {
        Actor_SetScale((Actor *) this, 0.01f);
        func_80B4516C(this);
        func_80B46118((Vec3f *) &this->actor.world);
        func_80B47568(this);
    }
}

void func_80B47478(EnInvadepoh *arg0) {
    arg0->collider.base.atFlags &= -2;
    arg0->collider.base.acFlags &= -2;
    arg0->collider.base.ocFlags1 &= -2;
    arg0->actor.flags &= 0x7FFFFFFF;
    arg0->alienAlpha = 0;
    arg0->actor.draw = NULL;
    arg0->drawAlien = 0;
    arg0->drawAlienDeathEffect = 0;
    arg0->alienBeamAlpha = 0;
    arg0->actionFunc = func_80B474DC;
}

void func_80B474DC(EnInvadepoh *this, GlobalContext *globalCtx) {
    func_80B442E4(this);
    func_80B447C0((Actor *) this, globalCtx);
    func_80B43DD4(this, 0x320, 0);
    if (this->clockTime > 0.0f) {
        Actor_SetScale((Actor *) this, 0.01f);
        func_80B4516C(this);
        func_80B46118((Vec3f *) &this->actor.world);
        func_80B47568(this);
    }
}

void func_80B47568(EnInvadepoh *this) {
    SkelAnime *temp_a0;

    temp_a0 = &this->skelAnime;
    this = this;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06001D80, -6.0f);
    this->collider.base.atFlags &= 0xFFFE;
    this->collider.base.acFlags &= 0xFFFE;
    this->collider.base.ocFlags1 &= 0xFFFE;
    this->alienAlpha = 0;
    this->actor.draw = func_80B4DB14;
    this->drawAlien = 1;
    this->drawAlienDeathEffect = 0;
    this->alienBeamAlpha = 0;
    this->actor.flags |= 0x80000000;
    this->actionFunc = func_80B47600;
}

void func_80B47600(EnInvadepoh *this, GlobalContext *globalCtx) {
    u8 temp_v0;
    u8 temp_v0_2;

    func_80B442E4(this);
    func_80B447C0((Actor *) this, globalCtx);
    func_80B43DD4(this, 0x320, 0);
    func_800B9010((Actor *) this, 0x320AU);
    if (this->clockTime >= 0.9999f) {
        this->unk38A = 1;
    }
    temp_v0 = this->alienAlpha;
    if ((s32) temp_v0 >= 0xF9) {
        this->alienAlpha = 0xFF;
    } else {
        this->alienAlpha = temp_v0 + 6;
    }
    if ((s32) this->alienAlpha >= 0x81) {
        this->collider.base.atFlags |= 1;
        this->collider.base.acFlags |= 1;
        this->collider.base.ocFlags1 |= 1;
    }
    if (this->alienAlpha == 0xFF) {
        temp_v0_2 = this->alienBeamAlpha;
        if ((s32) temp_v0_2 >= 0xF5) {
            this->alienBeamAlpha = 0xFF;
            func_80B4770C(this);
            return;
        }
        this->alienBeamAlpha = temp_v0_2 + 0xA;
        /* Duplicate return node #11. Try simplifying control flow for better match */
    }
}

void func_80B4770C(EnInvadepoh *this) {
    SkelAnime *temp_a0;

    temp_a0 = &this->skelAnime;
    if (&D_06001D80 != this->skelAnime.animCurrentSeg) {
        this = this;
        SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06001D80, -6.0f);
    }
    this->collider.base.atFlags |= 1;
    this->collider.base.acFlags |= 1;
    this->collider.base.ocFlags1 |= 1;
    this->alienAlpha = 0xFF;
    this->actor.draw = func_80B4DB14;
    this->drawAlien = 1;
    this->drawAlienDeathEffect = 0;
    this->alienBeamAlpha = 0xFF;
    this->actor.flags |= 0x80000000;
    this->actionFunc = func_80B477B4;
}

void func_80B477B4(EnInvadepoh *this, GlobalContext *globalCtx) {
    func_80B442E4(this);
    func_80B447C0((Actor *) this, globalCtx);
    func_80B43DD4(this, 0x320, 0);
    func_800B9010((Actor *) this, 0x320AU);
    if (this->clockTime >= 0.9999f) {
        this->unk38A = 1;
    }
}

void func_80B47830(Actor *arg0) {
    arg0->unk_2B0 = (u8) (arg0->unk_2B0 & ~1);
    arg0->unk_2B1 = (u8) (arg0->unk_2B1 & ~1);
    arg0->unk_2B2 = (u8) (arg0->unk_2B2 | 1);
    SkelAnime_ChangeAnimDefaultRepeat(arg0 + 0x144, &D_060006C8);
    func_800BCB70(arg0, 0x4000, 0xFF, 0, (s16) 0x10);
    arg0->unk_389 = 0xFF;
    arg0->draw = func_80B4DB14;
    arg0->unk_38B = 1;
    arg0->unk_38C = 0;
    arg0->unk_38D = 0;
    arg0->unk_2F0 = 8;
    arg0->unk_2F2 = 0;
    arg0->flags |= 0x80000000;
    arg0[2].velocity.x = (bitwise f32) func_80B478F4;
}

void func_80B478F4(EnInvadepoh *this, GlobalContext *globalCtx) {
    func_80B44A90();
    this->actionTimer += -1;
    if ((s32) this->actionTimer <= 0) {
        func_80B47938(this);
    }
}

void func_80B47938(EnInvadepoh *this) {
    EnInvadepoh *temp_a2;
    u32 temp_t3;
    u32 temp_t8;

    temp_a2 = this;
    temp_a2->collider.base.atFlags &= -2;
    temp_a2->collider.base.acFlags &= -2;
    temp_a2->collider.base.ocFlags1 &= -2;
    this = temp_a2;
    SkelAnime_ChangeAnimDefaultRepeat(&temp_a2->skelAnime, &D_06000608);
    temp_t3 = this->actor.flags & ~1;
    temp_t8 = temp_t3 | 0x80000000;
    this->actor.flags = temp_t3;
    this->actionTimer = 0xA;
    this->alienAlpha = 0xFF;
    this->actor.draw = func_80B4DB14;
    this->drawAlien = 1;
    this->drawAlienDeathEffect = 0;
    this->alienBeamAlpha = 0xFF;
    this->actor.flags = temp_t8;
    this->actionFunc = func_80B479E8;
}

void func_80B479E8(EnInvadepoh *this, GlobalContext *globalCtx) {
    Vec3f *temp_a1;
    Vec3f *temp_a1_2;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 phi_v0;

    func_80B44B78(this);
    temp_v0 = this->counter;
    if ((s32) temp_v0 < 5) {
        temp_a1 = (temp_v0 * 0xC) + &D_80B4ED30;
        if (temp_a1->x > 0.0f) {
            this->drawAlien = 1;
            this->alienBeamAlpha = 0xFF;
            Math_Vec3f_Copy(&this->actor.scale, temp_a1);
        } else {
            this->drawAlien = 0;
            goto block_5;
        }
    } else {
        this->drawAlien = 0;
block_5:
        this->alienBeamAlpha = 0;
    }
    temp_v0_2 = this->counter;
    if (((s32) temp_v0_2 >= 2) && ((s32) temp_v0_2 < 9)) {
        temp_a1_2 = (temp_v0_2 * 0xC) - 0x18 + &D_80B4ED6C;
        if (temp_a1_2->x > 0.0f) {
            this->drawAlienDeathEffect = 1;
            Math_Vec3f_Copy(&this->alienDeathEffectScale, temp_a1_2);
        } else {
            goto block_11;
        }
    } else {
block_11:
        this->drawAlienDeathEffect = 0;
    }
    this->counter += 1;
    if (this->actionTimer == 8) {
        Actor_Spawn(&globalCtx->actorCtx, globalCtx, 0xA2, this->actor.world.pos.x, this->actor.world.pos.y - 10.0f, this->actor.world.pos.z, (s16) 0, (s16) 0, (s16) 3, (s16) 0xC8);
    }
    phi_v0 = this->actionTimer;
    if (this->actionTimer == 8) {
        Enemy_StartFinishingBlow(globalCtx, (Actor *) this);
        phi_v0 = this->actionTimer;
    }
    this->actionTimer = phi_v0 - 1;
    if ((s32) this->actionTimer <= 0) {
        func_80B43AF0(this->actor.params & 7);
        func_80B43AB0();
        Item_DropCollectible(globalCtx, (Vec3f *) &this->actor.world, 8U);
        func_80B47478(this);
    }
}

void func_80B47BAC(Actor *thisx, GlobalContext *globalCtx) {
    s32 temp_v1;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B45080();
        thisx->update = func_80B47D30;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06004E50, &D_06001D80, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0xE);
        thisx->unk_15C = (f32) ((f32) (thisx->params & 7) * thisx[1].home.pos.z * 0.125f);
        func_80B444BC(thisx, globalCtx);
        func_80B442E4((EnInvadepoh *) thisx);
        func_80B447C0(thisx, globalCtx);
        func_80B43F0C(thisx);
        func_80B4516C((EnInvadepoh *) thisx);
        temp_v1 = D_80B4E940;
        if ((temp_v1 == 1) || ((s32) gSaveContext.time < 0x1AD8)) {
            func_80B47380(thisx);
            return;
        }
        if (temp_v1 == 2) {
            if (thisx[2].xzDistToPlayer >= 0.0001f) {
                func_80B4770C((EnInvadepoh *) thisx);
                return;
            }
            func_80B47568((EnInvadepoh *) thisx);
            return;
        }
        Actor_MarkForDeath(thisx);
        /* Duplicate return node #9. Try simplifying control flow for better match */
    }
}

void func_80B47D30(Actor *thisx, GlobalContext *globalCtx) {
    s16 *sp20;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_v0;
    s16 *temp_a1;
    u8 temp_v0_3;
    u8 temp_v0_4;
    u8 temp_v0_5;
    void *temp_v0_2;
    f32 phi_f2;
    f32 phi_f2_2;

    if (D_80B4E940 == 3) {
        temp_v0 = thisx[2].velocity.x;
        if ((func_80B477B4 == (bitwise s32) temp_v0) || (func_80B47600 == (bitwise s32) temp_v0)) {
            thisx->speedXZ = 0.0f;
            thisx->velocity.y = 0.0f;
            thisx->gravity = 0.0f;
            func_80B47830(thisx);
            goto block_20;
        }
        if ((func_80B474DC == (bitwise s32) temp_v0) || (func_80B473E4 == (bitwise s32) temp_v0)) {
            Actor_MarkForDeath(thisx);
            return;
        }
        goto block_20;
    }
    if ((thisx->unk_2B1 & 2) != 0) {
        temp_v0_2 = thisx->unk_2A8;
        thisx->speedXZ = temp_v0_2->unk_70 * 0.5f;
        temp_f0 = thisx->speedXZ;
        phi_f2 = -60.0f;
        if (temp_f0 < -60.0f) {

        } else if (temp_f0 > 60.0f) {
            phi_f2 = 60.0f;
        } else {
            phi_f2 = temp_f0;
        }
        thisx->speedXZ = phi_f2;
        thisx->gravity = 0.0f;
        thisx->world.rot.y = temp_v0_2->unk_32;
        thisx->velocity.y = temp_v0_2->unk_68 * 0.5f;
        temp_f0_2 = thisx->velocity.y;
        if (temp_f0_2 < -30.0f) {
            thisx->velocity.y = -30.0f;
        } else {
            if (temp_f0_2 > 30.0f) {
                phi_f2_2 = 30.0f;
            } else {
                phi_f2_2 = temp_f0_2;
            }
            thisx->velocity.y = phi_f2_2;
        }
        Audio_PlaySoundAtPosition(globalCtx, (Vec3f *) &thisx->world, 0x32, 0x3A09U);
        func_80B47830(thisx);
    }
block_20:
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if (thisx->draw != 0) {
        thisx->unk_29C = SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
    }
    temp_a1 = &thisx[2].home.rot.z;
    sp20 = temp_a1;
    Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a1);
    temp_v0_3 = thisx->unk_2B0;
    if ((temp_v0_3 & 1) != 0) {
        CollisionCheck_SetAT(globalCtx, &globalCtx->colChkCtx, (Collider *) sp20);
    } else {
        thisx->unk_2B0 = (u8) (temp_v0_3 & 0xFFFD);
    }
    temp_v0_4 = thisx->unk_2B1;
    if ((temp_v0_4 & 1) != 0) {
        CollisionCheck_SetAC(globalCtx, &globalCtx->colChkCtx, (Collider *) sp20);
    } else {
        thisx->unk_2B1 = (u8) (temp_v0_4 & 0xFFFD);
    }
    temp_v0_5 = thisx->unk_2B2;
    if ((temp_v0_5 & 1) != 0) {
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) sp20);
        return;
    }
    thisx->unk_2B2 = (u8) (temp_v0_5 & 0xFFFD);
}

void func_80B47FA8(Actor *thisx, GlobalContext *globalCtx) {
    Actor *sp34;
    Actor *temp_a1;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        thisx->update = func_80B48060;
        thisx->draw = func_80B4E158;
        temp_a1 = &thisx[1];
        sp34 = temp_a1;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) temp_a1, &D_06004010, NULL, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 6);
        SkelAnime_ChangeAnimDefaultRepeat((SkelAnime *) sp34, &D_06004264);
    }
}

void func_80B48060(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp6C;
    ? sp28;
    ActorShape *sp24;
    ActorShape *temp_a0;

    if ((D_80B503F0 == 0) || (thisx->parent == 0)) {
        Actor_MarkForDeath(thisx);
        return;
    }
    sp6C = thisx->params & 7;
    SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
    temp_a0 = &thisx->shape;
    sp24 = temp_a0;
    Math_ScaledStepToS((s16 *) temp_a0, *(&D_80B4EDC0 + (sp6C * 2)), 0x32);
    if (thisx->child != 0) {
        SysMatrix_StatePush();
        SysMatrix_SetStateRotationAndTranslation(thisx->world.pos.x, thisx->world.pos.y, thisx->world.pos.z, (Vec3s *) sp24);
        SysMatrix_InsertTranslation(0.0f, 57.0f, -36.0f, 1);
        SysMatrix_InsertXRotation_s((s16) (s32) ((f32) thisx->shape.rot.x * -0.7f), 1);
        SysMatrix_InsertZRotation_s((s16) (s32) ((f32) thisx->shape.rot.z * -0.7f), 1);
        SysMatrix_GetStateTranslation((Vec3f *) &thisx->child->world);
        SysMatrix_CopyCurrentState((MtxF *) &sp28);
        func_8018219C((MtxF *) &sp28, (Vec3s *) &thisx->child->shape, 0);
        SysMatrix_StatePop();
    }
}

void func_80B481C4(Actor *thisx, GlobalContext *globalCtx) {
    Actor *sp34;
    Actor *temp_a1;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        thisx->update = func_80B4827C;
        thisx->draw = func_80B4E1B0;
        temp_a1 = &thisx[1];
        sp34 = temp_a1;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) temp_a1, &D_06004C30, NULL, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 6);
        SkelAnime_ChangeAnimDefaultRepeat((SkelAnime *) sp34, &D_06004E98);
    }
}

void func_80B4827C(Actor *thisx, GlobalContext *globalCtx) {
    if ((D_80B503F0 == 0) || (thisx->parent == 0)) {
        Actor_MarkForDeath(thisx);
        return;
    }
    SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
}

void func_80B482D4(Actor *arg0) {
    Actor *temp_a3;

    temp_a3 = arg0;
    temp_a3->unk_2F0 = 0x28;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_06002A8C, -10.0f);
    arg0->draw = NULL;
    arg0[2].velocity.x = func_80B48324;
}

void func_80B48324(EnInvadepoh *this, GlobalContext *globalCtx) {
    this->actionTimer += -1;
    if ((s32) this->actionTimer <= 0) {
        EnInvadepoh_SetTextID((Actor *)0x332F);
        this->actor.draw = func_80B4E324;
        func_80B48374(this);
    }
}

void func_80B48374(EnInvadepoh *this) {
    EnInvadepoh *temp_a3;

    temp_a3 = this;
    temp_a3->actionTimer = 0x3C;
    this = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(&temp_a3->skelAnime, &D_06002A8C, -10.0f);
    this->actor.draw = func_80B4E324;
    this->actionFunc = func_80B483CC;
}

void func_80B483CC(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (this->actionTimer == 0x14) {
        this->behaviorInfo.unk26.x = 0x7D0;
        this->behaviorInfo.unk26.y = 0;
        this->behaviorInfo.unk26.z = 0;
        this->behaviorInfo.unk2C = 0x3E8;
        this->behaviorInfo.unk30 = 0.1f;
    }
    this->actionTimer += -1;
    if ((s32) this->actionTimer <= 0) {
        func_80B4843C(this);
    }
}

void func_80B4843C(EnInvadepoh *this) {
    this->behaviorInfo.unk26.x = 0xBB8;
    this->behaviorInfo.unk26.y = 0;
    this->behaviorInfo.unk26.z = 0;
    this->behaviorInfo.unk2C = 0xBB8;
    this->behaviorInfo.unk42 = 0x3A98;
    this->behaviorInfo.unk30 = 0.24f;
    this->behaviorInfo.unk48 = 0x7D0;
    this->actionTimer = 0x32;
    this->behaviorInfo.unk44 = 0.1f;
    SkelAnime_ChangeAnim(&this->skelAnime, &D_06007328, 2.0f, 0.0f, 0.0f, (u8) 0, -5.0f);
    this->actor.draw = func_80B4E324;
    this->actionFunc = func_80B484EC;
}

void func_80B484EC(EnInvadepoh *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    temp_v0 = this->actionTimer;
    if (temp_v0 == 0x28) {
        this->behaviorInfo.unk26.y = 0x1B58;
        goto block_8;
    }
    if (temp_v0 == 0x1E) {
        this->behaviorInfo.unk26.y = -0x1B58;
        goto block_8;
    }
    if (temp_v0 == 0x14) {
        this->behaviorInfo.unk26.y = 0x1B58;
        goto block_8;
    }
    if (temp_v0 == 0xA) {
        this->behaviorInfo.unk26.y = 0;
block_8:
    }
    this->actionTimer += -1;
    if ((s32) this->actionTimer <= 0) {
        func_80B48588(this);
    }
}

void func_80B48588(EnInvadepoh *this) {
    EnInvadepoh *temp_a3;

    temp_a3 = this;
    temp_a3->behaviorInfo.unk26.x = 0;
    temp_a3->behaviorInfo.unk26.y = 0;
    temp_a3->behaviorInfo.unk26.z = 0;
    temp_a3->behaviorInfo.unk2C = 0x1388;
    temp_a3->behaviorInfo.unk42 = 0;
    temp_a3->behaviorInfo.unk30 = 0.24f;
    temp_a3->behaviorInfo.unk48 = 0x1B58;
    temp_a3->behaviorInfo.unk44 = 0.28f;
    this = temp_a3;
    SkelAnime_ChangeAnimTransitionStop(&temp_a3->skelAnime, &D_06009E58, -10.0f);
    this->actor.draw = func_80B4E324;
    this->actionFunc = func_80B48610;
}

void func_80B48610(EnInvadepoh *this, GlobalContext *globalCtx) {

}

void func_80B48620(Actor *thisx, GlobalContext *globalCtx) {
    Actor *sp38;
    Actor *temp_a1;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        thisx->update = func_80B4873C;
        temp_a1 = &thisx[1];
        sp38 = temp_a1;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) temp_a1, &D_06013928, &D_06009E58, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EA90, 6, &D_80B4EB00, 2, &D_801D15BC, (s16) 0x1388, 0.05f, 0.3f, 0.12f);
        SkelAnime_ChangeAnimDefaultRepeat((SkelAnime *) sp38, &D_06009E58);
        func_80B482D4(thisx);
    }
}

void func_80B4873C(Actor *thisx, GlobalContext *globalCtx) {
    f32 *sp20;
    f32 *temp_a0;
    s16 temp_v0;

    if (thisx->parent == 0) {
        Actor_MarkForDeath(thisx);
        return;
    }
    (bitwise ? (*)(Actor *)) thisx[2].velocity.x(thisx);
    SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
    temp_a0 = &thisx[2].yDistToPlayer;
    sp20 = temp_a0;
    func_80B45CE0(temp_a0);
    temp_v0 = temp_a0->unk_40;
    if (temp_v0 != 0) {
        thisx->shape.rot.x = (s16) -(s32) temp_v0;
    }
}

void func_80B487B4(EnInvadepoh *arg0) {
    s16 temp_t9;
    void *temp_v1;

    arg0->actionTimer = Rand_S16Offset(0x96, 0xFA);
    temp_t9 = *(&D_80B4EDC8 + ((Rand_Next() >> 0x1E) * 2));
    temp_v1 = arg0 + 0x324;
    temp_v1->unk_28 = 0;
    temp_v1->unk_2A = 0;
    temp_v1->unk_26 = temp_t9;
    temp_v1->unk_2C = 0x320;
    temp_v1->unk_30 = 0.1f;
    SkelAnime_ChangeAnimTransitionRepeat(arg0 + 0x144, &D_06014088, -10.0f);
    arg0->actionFunc = func_80B48848;
}

void func_80B48848(EnInvadepoh *this, GlobalContext *globalCtx) {
    SkelAnime *sp20;
    SkelAnime *temp_a0;
    s16 temp_v0;

    Math_StepToF(&this->actor.speedXZ, 1.6f, 0.1f);
    if (func_80B44B84((Actor *) this, globalCtx, this->actor.speedXZ, 50.0f) != 0) {
        func_80B44514(this);
        this->behaviorInfo.unk4C = 0xC8;
        this->actor.speedXZ *= 0.25f;
    } else {
        Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x46);
    }
    func_80B43E6C(this, 6, this->behaviorInfo.unk4C, 0x46);
    temp_a0 = &this->skelAnime;
    if (((this->actor.flags & 0x40) == 0x40) && ((sp20 = temp_a0, (func_801378B8(temp_a0, 0.0f) != 0)) || (func_801378B8(temp_a0, 7.0f) != 0))) {
        Audio_PlayActorSound2((Actor *) this, 0x3ABEU);
    }
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    func_80B48948(this);
}

void func_80B48948(EnInvadepoh *this) {
    f32 sp28;
    AlienBehaviorInfo *sp24;
    AlienBehaviorInfo *temp_v1;
    AlienBehaviorInfo *temp_v1_2;
    AlienBehaviorInfo *temp_v1_3;
    AlienBehaviorInfo *temp_v1_4;

    sp28 = Rand_ZeroOne();
    temp_v1 = &this->behaviorInfo;
    this->actionTimer = Rand_S16Offset(0x96, 0x96);
    if (sp28 < 0.5f) {
        this->rand = 0;
        sp24 = temp_v1;
        Math_Vec3s_Copy(&temp_v1->unk26, &D_801D15BC);
        temp_v1->unk2C = 0x3E8;
        temp_v1->unk30 = 0.1f;
    } else if (sp28 < 0.75f) {
        this->rand = 1;
        temp_v1_2 = &this->behaviorInfo;
        temp_v1_2->unk26.x = Rand_S16Offset(0, 0x7D0);
        temp_v1_2->unk26.y = 0;
        temp_v1_2->unk26.z = 0;
        temp_v1_2->unk2C = 0x3E8;
        temp_v1_2->unk30 = 0.06f;
    } else {
        temp_v1_3 = &this->behaviorInfo;
        if (sp28 < 0.8f) {
            this->rand = 2;
            temp_v1_4 = &this->behaviorInfo;
            temp_v1_4->unk26.x = Rand_S16Offset(-0x7D0, 0x7D0);
            temp_v1_4->unk26.y = 0;
            temp_v1_4->unk26.z = 0;
            temp_v1_4->unk2C = 0x3E8;
            temp_v1_4->unk30 = 0.05f;
        } else {
            this->rand = 3;
            temp_v1_3->unk26.x = 0;
            temp_v1_3->unk26.y = 0;
            sp24 = temp_v1_3;
            temp_v1_3->unk26.z = Rand_S16Offset(-0x9C4, 0x1388);
            temp_v1_3->unk2C = 0x3E8;
            temp_v1_3->unk30 = 0.04f;
        }
    }
    SkelAnime_ChangeAnimTransitionRepeat(&this->skelAnime, &D_06009E58, -10.0f);
    this->actionFunc = func_80B48AD4;
}

void func_80B48AD4(EnInvadepoh *this, GlobalContext *globalCtx) {
    AlienBehaviorInfo *temp_s0;
    AlienBehaviorInfo *temp_s0_2;
    s16 temp_v1;
    s16 temp_v1_2;
    s32 temp_f18;
    s32 temp_v1_3;
    s8 temp_v0;
    s16 phi_v0;
    s16 phi_v0_2;

    Math_StepToF(&this->actor.speedXZ, 0.0f, 0.2f);
    if (func_80B44B84((Actor *) this, globalCtx, this->actor.speedXZ, 50.0f) != 0) {
        func_80B44514(this);
    }
    if (this->rand == 0) {
        if ((this->actor.xzDistToPlayer < 350.0f) && ((globalCtx->gameplayFrames & 0x60) != 0)) {
            temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &globalCtx->actorCtx.actorList[2].first->focus) * 0.85f) - this->actor.shape.rot.x;
            if ((s32) temp_v1 < -0x9C4) {
                this->behaviorInfo.unk26.x = -0x9C4;
            } else {
                phi_v0 = temp_v1;
                if ((s32) temp_v1 >= 0x9C5) {
                    phi_v0 = 0x9C4;
                }
                this->behaviorInfo.unk26.x = phi_v0;
            }
            temp_f18 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
            if ((s32) (s16) temp_f18 < -0x1F40) {
                this->behaviorInfo.unk26.y = -0x1F40;
            } else {
                phi_v0_2 = (s16) temp_f18;
                if ((s32) (s16) temp_f18 >= 0x1F41) {
                    phi_v0_2 = 0x1F40;
                }
                this->behaviorInfo.unk26.y = phi_v0_2;
            }
        }
    } else {
        temp_s0 = &this->behaviorInfo;
        temp_s0->unk26.x = 0;
        temp_s0->unk26.y = 0;
    }
    temp_v1_2 = this->actionTimer;
    if ((s32) temp_v1_2 > 0) {
        if (((temp_v1_2 & 0x1F) == 0) && (Rand_ZeroOne() < 0.3f)) {
            temp_v1_3 = Rand_Next() % 4;
            if (temp_v1_3 != this->rand) {
                this->rand = (s8) temp_v1_3;
                temp_v0 = this->rand;
                temp_s0_2 = &this->behaviorInfo;
                if (temp_v0 == 0) {
                    Math_Vec3s_Copy(&temp_s0_2->unk26, &D_801D15BC);
                    temp_s0_2->unk30 = 0.07f;
                } else if (temp_v0 == 1) {
                    temp_s0_2->unk26.x = Rand_S16Offset(0x3E8, 0x3E8);
                    temp_s0_2->unk26.y = Rand_S16Offset(-0x3E8, 0x7D0);
                    temp_s0_2->unk26.z = Rand_S16Offset(-0x320, 0x640);
                    temp_s0_2->unk30 = 0.06f;
                } else if (temp_v0 == 2) {
                    temp_s0_2->unk26.x = Rand_S16Offset(-0x7D0, 0x3E8);
                    temp_s0_2->unk26.y = Rand_S16Offset(-0x3E8, 0x7D0);
                    temp_s0_2->unk26.z = Rand_S16Offset(-0x320, 0x640);
                    temp_s0_2->unk30 = 0.05f;
                } else {
                    temp_s0_2->unk26.x = Rand_S16Offset(-0x3E8, 0x7D0);
                    temp_s0_2->unk26.y = Rand_S16Offset(-0x7D0, 0xFA0);
                    temp_s0_2->unk26.z = Rand_S16Offset(-0x7D0, 0xFA0);
                    temp_s0_2->unk30 = 0.04f;
                }
            }
        }
        this->actionTimer += -1;
        return;
    }
    func_80B487B4(this);
}

void func_80B48DE4(Actor *arg0) {
    Actor *temp_a3;
    void *temp_v0;

    temp_a3 = arg0;
    temp_a3->speedXZ = 0.0f;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_06009E58, -10.0f);
    arg0->unk_370 = 0;
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_2C = 0x4B0;
    temp_v0->unk_30 = 0.05f;
    arg0[2].velocity.x = func_80B48E4C;
}

void func_80B48E4C(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x32);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 6, this->behaviorInfo.unk4C, (s16) 0x23);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    if (func_800B867C((Actor *) this, globalCtx) != 0) {
        func_80B48948(this);
    }
}

void func_80B48FB0(Actor *thisx, GlobalContext *globalCtx) {
    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        thisx->update = func_80B490F0;
        thisx->draw = func_80B4E324;
        thisx->textId = 0x3330;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06013928, &D_06009E58, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EA90, 6, &D_80B4EB00, 2, &D_801D15BC, (s16) 0x64, 0.03f, 0.3f, 0.03f);
        func_80B444F4(thisx, globalCtx);
        EnInvadepoh_SetPathPointToWorldPos(thisx, 0);
        func_800B4AEC(globalCtx, thisx, 50.0f);
        func_80B4516C((EnInvadepoh *) thisx);
        func_80B487B4((EnInvadepoh *) thisx);
    }
}

void func_80B490F0(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp2C;
    s32 sp28;
    s16 *sp24;
    s16 *temp_a2;
    s32 temp_v0;

    sp2C = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_800B84D0(thisx, globalCtx);
    sp28 = temp_v0;
    if (temp_v0 != 0) {
        func_80151BB4(globalCtx, 5U);
        func_80B48DE4(thisx);
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if (sp2C != 0) {
        SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        func_80B45CE0(&thisx[2].yDistToPlayer);
        if ((func_80B48E4C != (bitwise s32) thisx[2].velocity.x) && (sp28 == 0) && (thisx->isTargeted != 0)) {
            func_800B8614(thisx, globalCtx, 100.0f);
        }
        temp_a2 = &thisx[2].home.rot.z;
        sp24 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B491EC(EnInvadepoh *this) {
    this->scaleFactorAdj = 0.0f;
    this->scaleStep = 0.0f;
    this->unk3AA = 0;
    this->actionFunc = func_80B49228;
    this->actor.gravity = -15.0f;
    this->scaleTarget = 1.0f;
}

void func_80B49228(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp28;
    f32 temp_f0;

    Actor_SetVelocityYRotationAndGravity((Actor *) this);
    this->actor.velocity.y *= 0.97f;
    temp_f0 = Math_SmoothStepToF(&this->actor.world.pos.y, this->actor.home.pos.y + *D_80B4E938 + 300.0f, 0.7f, fabsf(this->actor.velocity.y), 1.0f);
    sp28 = temp_f0;
    func_800B9010((Actor *) this, 0x217BU);
    if (fabsf(temp_f0) < 1.0f) {
        func_80B45EC8(this, globalCtx, 0x32);
        func_80B492FC(this);
    }
}

void func_80B492FC(EnInvadepoh *this) {
    this->actionTimer = 0x14;
    this->actor.velocity.y *= 0.1f;
    this->scaleTarget = 0.3f;
    this->unk3AA = 0xBB8;
    this->actionFunc = func_80B4934C;
    this->scaleStep = 0.03f;
}

void func_80B4934C(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (this->actor.world.pos.y < (this->actor.home.pos.y + *D_80B4E938 + 300.0f)) {
        this->actor.gravity = 3.0f;
    } else {
        this->actor.gravity = -2.0f;
    }
    this->actor.velocity.y *= 0.96f;
    Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
    func_800B9010((Actor *) this, 0x217BU);
    this->actionTimer += -1;
    if ((s32) this->actionTimer <= 0) {
        func_80B49404(this);
    }
}

void func_80B49404(EnInvadepoh *this) {
    this->actionTimer = 0x78;
    this->scaleTarget = 0.2f;
    this->unk3AA = 0xBB8;
    this->unk3AC = 0;
    this->counter = 0;
    this->actionFunc = func_80B49454;
    this->scaleStep = 0.01f;
    this->actor.gravity = 33.0f;
}

void func_80B49454(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp30;
    PosRot *sp28;
    PosRot *temp_a0;
    s16 temp_v0;
    s16 temp_v0_3;
    s8 temp_v0_2;

    temp_v0 = this->counter;
    if ((s32) temp_v0 < 0x19) {
        this->counter = temp_v0 + 1;
    } else {
        this->counter = 0;
        this->unk3AC += 1;
        temp_v0_2 = this->unk3AC;
        if ((s32) temp_v0_2 >= 5) {
            this->unk3AC = 4;
        } else {
            this->unk3AC = temp_v0_2;
        }
        this->actor.gravity = 33.0f;
        func_80B45EC8(this, (GlobalContext *)0x14);
    }
    Math_Vec3f_Sum((this->unk3AC * 0xC) + &D_80B4EDD0, (Vec3f *) &this->actor.home, (Vec3f *) &sp30);
    temp_a0 = &this->actor.world;
    sp28 = temp_a0;
    if (Math3D_DistanceSquared((Vec3f *) temp_a0, (Vec3f *) &sp30) < 160000.0f) {
        this->actor.speedXZ *= 0.8f;
    } else {
        Math_StepToF(&this->actor.speedXZ, 170.0f, 21.0f);
        this->actor.speedXZ *= 0.98f;
    }
    if (func_80B450C0((f32 *) sp28, &this->actor.world.pos.z, sp30, sp38, this->actor.speedXZ) != 0) {
        this->actor.speedXZ = 0.0f;
    }
    if (sp34 < this->actor.world.pos.y) {
        Math_StepToF(&this->actor.gravity, -12.0f, 7.0f);
    } else {
        Math_StepToF(&this->actor.gravity, 5.0f, 4.0f);
    }
    this->actor.velocity.y += this->actor.gravity;
    this->actor.velocity.y *= 0.97f;
    this->actor.world.pos.y += this->actor.velocity.y;
    func_800B9010((Actor *) this, 0x217BU);
    temp_v0_3 = this->actionTimer;
    if ((s32) temp_v0_3 > 0) {
        this->actionTimer = temp_v0_3 - 1;
        return;
    }
    func_80B49628(this);
}

void func_80B49628(EnInvadepoh *this) {
    this->scaleTarget = 0.2f;
    this->unk3AA = 0xBB8;
    this->scaleStep = 0.01f;
    this->actionFunc = func_80B49670;
    this->actor.velocity.y *= 0.8f;
}

void func_80B49670(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp38;
    f32 sp34;
    f32 sp30;

    sp30 = this->actor.home.pos.x;
    sp34 = this->actor.home.pos.y + 1500.0f;
    sp38 = this->actor.home.pos.z;
    Math_SmoothStepToS(&this->actor.world.rot.y, Math_Vec3f_Yaw((Vec3f *) &this->actor.world, (Vec3f *) &sp30), 0xA, 0xBB8, (s16) 0x64);
    if ((u32) (globalCtx->gameplayFrames & 0x3F) < 0xEU) {
        Math_StepToF(&this->actor.speedXZ, 5.0f, 1.0f);
    } else {
        this->actor.speedXZ *= 0.97f;
    }
    if (sp34 < this->actor.world.pos.y) {
        this->actor.gravity = -0.5f;
    } else {
        this->actor.gravity = 2.0f;
    }
    this->actor.velocity.y *= 0.97f;
    Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
    if (D_80B4E940 == 3) {
        func_80B499BC(this);
    }
}

void func_80B497A4(EnInvadepoh *arg0) {
    arg0->scaleTarget = 0.2f;
    arg0->unk3AA = 0xBB8;
    arg0->actionTimer = 0x23;
    arg0->actionFunc = func_80B497EC;
    arg0->scaleStep = 0.01f;
    arg0->actor.gravity = -1.5f;
}

void func_80B497EC(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp38;
    f32 sp34;
    f32 sp30;
    f32 *temp_a1;
    s16 temp_v0;

    temp_a1 = &sp30;
    sp30 = this->actor.home.pos.x + D_80B4E934.unk_0;
    sp34 = this->actor.home.pos.y + D_80B4E934.unk_4 + 400.0f;
    sp38 = this->actor.home.pos.z + D_80B4E934.unk_8;
    Math_SmoothStepToS(&this->actor.world.rot.y, Math_Vec3f_Yaw((Vec3f *) &this->actor.world, (Vec3f *) temp_a1), 4, 0x1F40, (s16) 0x64);
    Math_StepToF(&this->actor.speedXZ, 70.0f, 3.0f);
    if (sp34 < this->actor.world.pos.y) {
        this->actor.gravity = -2.0f;
    } else {
        this->actor.gravity = 2.0f;
    }
    this->actor.velocity.y *= 0.97f;
    Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    func_80B49904(this);
}

void func_80B49904(EnInvadepoh *this) {
    this->scaleTarget = 0.2f;
    this->unk3AA = 0xBB8;
    this->actionTimer = 0x3C;
    this->actionFunc = func_80B4994C;
    this->scaleStep = 0.01f;
    this->actor.gravity = 1.0f;
}

void func_80B4994C(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 *temp_a0;
    s16 temp_v0;

    temp_a0 = &this->actor.speedXZ;
    this = this;
    Math_StepToF(temp_a0, 150.0f, 4.0f);
    this->actor.velocity.y *= 0.95f;
    Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    Actor_MarkForDeath((Actor *) this);
}

void func_80B499BC(EnInvadepoh *this) {
    this->actionTimer = 0x28;
    this->scaleTarget = 0.2f;
    this->unk3AA = 0xBB8;
    this->actionFunc = func_80B49A00;
    this->actor.speedXZ = 0.0f;
    this->scaleStep = 0.01f;
}

void func_80B49A00(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp38;
    f32 sp34;
    f32 sp30;
    s16 temp_v0;

    sp30 = this->actor.home.pos.x;
    sp34 = this->actor.home.pos.y + 800.0f;
    sp38 = this->actor.home.pos.z;
    Math_SmoothStepToS(&this->actor.world.rot.y, Math_Vec3f_Yaw((Vec3f *) &this->actor.world, (Vec3f *) &sp30), 4, 0x1F40, (s16) 0x64);
    Math_StepToF(&this->actor.speedXZ, 30.0f, 3.0f);
    this->actor.velocity.y *= 0.98f;
    if (sp34 < this->actor.world.pos.y) {
        this->actor.gravity = -0.5f;
    } else {
        this->actor.gravity = 2.0f;
    }
    Actor_SetVelocityAndMoveYRotationAndGravity((Actor *) this);
    Actor_UpdateBgCheckInfo(globalCtx, (Actor *) this, 0.0f, 0.0f, 0.0f, 4U);
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    func_80B497A4(this);
}

void func_80B49B1C(Actor *thisx, GlobalContext *globalCtx) {
    (bitwise ? (*)(Actor *)) thisx[2].velocity.x(thisx);
    thisx->unk_3A8 = (s16) (thisx->unk_3A8 + thisx->unk_3AA);
    Math_StepToF((f32 *) &thisx[2].isTargeted, thisx->unk_3A0, thisx->unk_3A4);
    Actor_SetScale(thisx, 0.27f * ((Math_SinS(thisx->unk_3A8) * thisx->unk_39C) + 1.0f));
    Math_StepToS(thisx + 0x306, 0x258, 8);
    thisx->world.rot.y += thisx->unk_306;
    thisx->unk_304 = (s16) (thisx->unk_304 + 0x258);
}

void func_80B49BD0(EnInvadepoh *arg0) {
    SkelAnime *temp_a0;
    void *temp_v0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06014088, -10.0f);
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_26 = 0;
    temp_v0->unk_28 = 0;
    temp_v0->unk_2A = 0;
    temp_v0->unk_2C = 0x320;
    temp_v0->unk_30 = 0.1f;
    arg0->actionFunc = func_80B49C38;
}

void func_80B49C38(EnInvadepoh *this, GlobalContext *globalCtx) {
    SkelAnime *sp24;
    SkelAnime *temp_a0;
    s32 temp_v0_2;
    s8 temp_v0;

    func_80B44570(this);
    func_80B44C24((Actor *) this, globalCtx);
    func_80B43E6C(this, 6, 0x7D0, 0x64);
    temp_v0 = this->pathIndex;
    if ((temp_v0 == 0) || (this->endPoint == (temp_v0 + 1))) {
        if (this->unk378 == 0) {
            temp_v0_2 = func_800FE620(globalCtx);
            if (temp_v0_2 > 0) {
                this->unk378 = func_80B45550(this, globalCtx, 6400.0f, (s32) ((((f32) gGameInfo->data[15] * -16.0f) / (f32) temp_v0_2) - 0.5f));
            }
        }
        this->actor.flags &= -0xA;
    } else {
        this->unk378 = 0;
        this->actor.flags |= 9;
    }
    temp_a0 = &this->skelAnime;
    if (((this->actor.flags & 0x40) == 0x40) && ((sp24 = temp_a0, (func_801378B8(temp_a0, 0.0f) != 0)) || (func_801378B8(temp_a0, 7.0f) != 0))) {
        Audio_PlayActorSound2((Actor *) this, 0x3ABEU);
    }
    if (this->clockTime >= 0.9999f) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void func_80B49DA0(Actor *arg0) {
    Actor *temp_a3;

    temp_a3 = arg0;
    temp_a3->unk_350 = 0x7D0;
    temp_a3->unk_370 = 0;
    temp_a3[2].shape.shadowScale = 0.08f;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_06009E58, -10.0f);
    arg0[2].velocity.x = func_80B49DFC;
}

void func_80B49DFC(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x1F4);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 5, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    if (func_800B867C((Actor *) this, globalCtx) != 0) {
        if (this->actor.textId == 0x332D) {
            gSaveContext.weekEventReg[54] |= 0x10;
            this->actor.textId = 0x332E;
        }
        func_80B49BD0(this);
    }
}

void func_80B49F88(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp38;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        sp38 = (s32) gSaveContext.time;
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06013928, &D_06014088, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EA90, 1, &D_80B4EB00, 1, &D_801D15BC, (s16) 0x64, 0.03f, 0.3f, 0.03f);
        func_80B44540(thisx, globalCtx);
        func_80B44570((EnInvadepoh *) thisx);
        func_80B44C24(thisx, globalCtx);
        func_80B43F0C(thisx);
        func_80B4516C((EnInvadepoh *) thisx);
        if ((gSaveContext.weekEventReg[21] & 0x20) != 0) {
            if ((gSaveContext.weekEventReg[54] & 0x10) != 0) {
                thisx->textId = 0x332E;
            } else {
                thisx->textId = 0x332D;
            }
        } else {
            thisx->textId = 0x332C;
        }
        if ((sp38 >= 0xC000) || (sp38 < 0x1555)) {
            thisx->update = func_80B4A168;
            thisx->draw = NULL;
            return;
        }
        if ((sp38 < 0x4000) && (sp38 >= 0x1555) && (sp38 < 0x1800)) {
            thisx->update = func_80B4A1B8;
            thisx->draw = func_80B4E324;
            func_80B49BD0((EnInvadepoh *) thisx);
            return;
        }
        Actor_MarkForDeath(thisx);
        /* Duplicate return node #14. Try simplifying control flow for better match */
    }
}

void func_80B4A168(Actor *thisx, GlobalContext *globalCtx) {
    u16 temp_v0;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 < 0x4000) && ((s32) temp_v0 >= 0x1555)) {
        thisx->update = func_80B4A1B8;
        thisx->draw = func_80B4E324;
        func_80B49BD0();
    }
}

void func_80B4A1B8(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp2C;
    s32 sp28;
    s16 *sp24;
    s16 *temp_a2;
    s32 temp_v0;

    sp2C = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_800B84D0(thisx, globalCtx);
    sp28 = temp_v0;
    if (temp_v0 != 0) {
        func_80151BB4(globalCtx, 5U);
        func_80B49DA0(thisx);
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if ((sp2C != 0) && (thisx->update != 0)) {
        SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        func_80B45CE0(&thisx[2].yDistToPlayer);
        if ((func_80B49DFC != (bitwise s32) thisx[2].velocity.x) && (sp28 == 0) && (thisx->isTargeted != 0)) {
            func_800B8614(thisx, globalCtx, 350.0f);
        }
        temp_a2 = &thisx[2].home.rot.z;
        sp24 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4A2C0(EnInvadepoh *arg0) {
    SkelAnime *temp_a0;
    void *temp_v0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06009E58, -10.0f);
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_26 = 0;
    temp_v0->unk_28 = 0;
    temp_v0->unk_2A = 0;
    temp_v0->unk_2C = 0x5DC;
    temp_v0->unk_30 = 0.1f;
    arg0->actionTimer = Rand_S16Offset(0xC8, 0xC8);
    arg0->actor.flags |= 9;
    arg0->actionFunc = func_80B4A350;
    arg0->unk304 = arg0->actor.shape.rot.y;
}

void func_80B4A350(EnInvadepoh *this, GlobalContext *globalCtx) {
    ? sp44;
    s16 sp42;
    AlienBehaviorInfo *sp30;
    void *sp2C;
    AlienBehaviorInfo *temp_v1;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v1_2;
    s32 temp_f18;
    s16 phi_v0;
    s16 phi_v0_2;

    sp2C = globalCtx + 0x18000;
    if ((globalCtx->gameplayFrames & 0xFF) == 0) {
        Math_Vec3s_ToVec3f((Vec3f *) &sp44, this->pathPoints);
        sp42 = Math_Vec3f_Yaw((Vec3f *) &this->actor.world, (Vec3f *) &sp44);
        temp_v0 = Rand_S16Offset(-0x1F40, 0x3E80);
        this->behaviorInfo.unk4C = 0;
        this->unk304 = temp_v0 + sp42;
    }
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x28);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->unk304, 6, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = &this->behaviorInfo;
    if (this->actor.xzDistToPlayer < 300.0f) {
        temp_v1_2 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &globalCtx->actorCtx.actorList[2].first->focus) * 0.85f) - this->actor.shape.rot.x;
        if ((s32) temp_v1_2 < -0x9C4) {
            this->behaviorInfo.unk26.x = -0x9C4;
        } else {
            phi_v0 = temp_v1_2;
            if ((s32) temp_v1_2 >= 0x9C5) {
                phi_v0 = 0x9C4;
            }
            this->behaviorInfo.unk26.x = phi_v0;
        }
        temp_f18 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
        if ((s32) (s16) temp_f18 < -0x1F40) {
            this->behaviorInfo.unk26.y = -0x1F40;
        } else {
            phi_v0_2 = (s16) temp_f18;
            if ((s32) (s16) temp_f18 >= 0x1F41) {
                phi_v0_2 = 0x1F40;
            }
            this->behaviorInfo.unk26.y = phi_v0_2;
        }
        if ((sp2C->unk_840 & 0xFF) == 0) {
            sp30 = &this->behaviorInfo;
            this->behaviorInfo.unk26.z = Rand_S16Offset(-0x5DC, 0xBB8);
        }
    } else {
        temp_v1->unk26.x = 0;
        temp_v1->unk26.y = 0;
        temp_v1->unk26.z = 0;
    }
    temp_v0_2 = this->actionTimer;
    if ((s32) temp_v0_2 > 0) {
        this->actionTimer = temp_v0_2 - 1;
        return;
    }
    func_80B4A570(this);
}

void func_80B4A570(EnInvadepoh *this) {
    AlienBehaviorInfo *temp_v0;
    SkelAnime *temp_a0;

    temp_a0 = &this->skelAnime;
    this = this;
    SkelAnime_ChangeAnimTransitionStop(temp_a0, &D_06002A8C, -10.0f);
    temp_v0 = &this->behaviorInfo;
    temp_v0->unk26.x = 0;
    temp_v0->unk26.y = 0;
    temp_v0->unk26.z = 0;
    temp_v0->unk2C = 0x320;
    temp_v0->unk30 = 0.1f;
    this->actionFunc = func_80B4A5E4;
    this->actor.flags |= 9;
}

void func_80B4A5E4(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (this->animPlayFlag != 0) {
        func_80B4A2C0();
    }
}

void func_80B4A614(EnInvadepoh *arg0) {
    SkelAnime *temp_a0;
    void *temp_v0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06014088, 0.0f);
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_26 = 0;
    temp_v0->unk_28 = 0;
    temp_v0->unk_2A = 0;
    temp_v0->unk_2C = 0x320;
    temp_v0->unk_30 = 0.1f;
    arg0->actionFunc = func_80B4A67C;
}

void func_80B4A67C(EnInvadepoh *this, GlobalContext *globalCtx) {
    SkelAnime *sp20;
    SkelAnime *temp_a0;

    Math_StepToF(&this->actor.speedXZ, 5.0f, 1.0f);
    if (func_80B44B84((Actor *) this, globalCtx, this->actor.speedXZ, 50.0f) != 0) {
        func_80B44640(this);
        this->behaviorInfo.unk4C = 0x5DC;
        this->actor.speedXZ *= 0.5f;
    } else {
        Math_StepToS(&this->behaviorInfo.unk4C, 0x190, 0x32);
    }
    func_80B43E6C(this, 6, this->behaviorInfo.unk4C, 0x32);
    if (this->pathIndex == 0) {
        if (this->unk378 == 0) {
            this->unk378 = func_80B45550(this, globalCtx, 6400.0f, -0xF);
        }
        this->actor.flags &= -0xA;
    } else {
        this->unk378 = 0;
        this->actor.flags |= 9;
    }
    temp_a0 = &this->skelAnime;
    if (((this->actor.flags & 0x40) == 0x40) && ((sp20 = temp_a0, (func_801378B8(temp_a0, 0.0f) != 0)) || (func_801378B8(temp_a0, 7.0f) != 0))) {
        Audio_PlayActorSound2((Actor *) this, 0x3ABEU);
    }
    if (this->endPoint == this->pathIndex) {
        func_80B4A2C0(this);
    }
}

void func_80B4A7C0(Actor *arg0) {
    Actor *temp_a3;

    temp_a3 = arg0;
    temp_a3->unk_350 = 0x7D0;
    temp_a3->unk_370 = 0;
    temp_a3[2].shape.shadowScale = 0.08f;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_06009E58, 0.0f);
    arg0[2].velocity.x = func_80B4A81C;
}

void func_80B4A81C(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x1F4);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 5, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    if (func_800B867C((Actor *) this, globalCtx) != 0) {
        if (this->actor.textId == 0x332D) {
            gSaveContext.weekEventReg[54] |= 0x10;
            this->actor.textId = 0x332E;
        }
        if (this->endPoint == this->pathIndex) {
            func_80B4A2C0(this);
            return;
        }
        func_80B4A614(this);
        /* Duplicate return node #16. Try simplifying control flow for better match */
    }
}

void func_80B4A9C8(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp38;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        sp38 = (s32) gSaveContext.time;
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06013928, &D_06014088, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EA90, 1, &D_80B4EB00, 1, &D_801D15BC, (s16) 0x64, 0.03f, 0.3f, 0.03f);
        func_80B44620(thisx, globalCtx);
        if ((sp38 < 0x1800) || (sp38 >= 0x4000)) {
            thisx->unk_309 = 0;
            thisx->update = func_80B4AB8C;
        } else {
            thisx->update = func_80B4ABDC;
            thisx->draw = func_80B4E324;
            thisx->unk_309 = (s8) thisx->unk_308;
            func_80B4A2C0((EnInvadepoh *) thisx);
        }
        EnInvadepoh_SetPathPointToWorldPos(thisx, thisx->unk_309);
        func_80B43F0C(thisx);
        func_800B4AEC(globalCtx, thisx, 50.0f);
        func_80B4516C((EnInvadepoh *) thisx);
        if ((gSaveContext.weekEventReg[21] & 0x20) != 0) {
            if ((gSaveContext.weekEventReg[54] & 0x10) != 0) {
                thisx->textId = 0x332E;
                return;
            }
            thisx->textId = 0x332D;
            return;
        }
        thisx->textId = 0x332C;
        /* Duplicate return node #10. Try simplifying control flow for better match */
    }
}

void func_80B4AB8C(Actor *thisx, GlobalContext *globalCtx) {
    u16 temp_v0;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 < 0x4000) && ((s32) temp_v0 >= 0x1800)) {
        thisx->update = func_80B4ABDC;
        thisx->draw = func_80B4E324;
        func_80B4A614();
    }
}

void func_80B4ABDC(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp2C;
    s32 sp28;
    s16 *sp24;
    s16 *temp_a2;
    s32 temp_v0;

    sp2C = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_800B84D0(thisx, globalCtx);
    sp28 = temp_v0;
    if (temp_v0 != 0) {
        func_80151BB4(globalCtx, 5U);
        func_80B4A7C0(thisx);
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if (sp2C != 0) {
        thisx->unk_29C = SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        func_80B45CE0(&thisx[2].yDistToPlayer);
        if ((func_80B4A81C != (bitwise s32) thisx[2].velocity.x) && (sp28 == 0) && (thisx->isTargeted != 0)) {
            func_800B8614(thisx, globalCtx, 100.0f);
        }
        temp_a2 = &thisx[2].home.rot.z;
        sp24 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4ACDC(Actor *arg0) {
    arg0[2].velocity.x = func_80B4ACF0;
}

void func_80B4ACF0(EnInvadepoh *this, GlobalContext *globalCtx) {
    if ((gSaveContext.weekEventReg[22] & 1) != 0) {
        this->actor.draw = func_80B4E324;
        this->actor.flags |= 9;
        func_80B4AD3C(this);
    }
}

void func_80B4AD3C(EnInvadepoh *this) {
    this->actor.flags |= 0x10000;
    this->actionFunc = func_80B4AD60;
}

void func_80B4AD60(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (func_800B84D0((Actor *) this, globalCtx) != 0) {
        EnInvadepoh_SetTextID((Actor *) this, globalCtx, 0x3331);
        func_80B4ADB8(this);
        return;
    }
    func_800B8614((Actor *) this, globalCtx, 2000.0f);
}

void func_80B4ADB8(EnInvadepoh *this) {
    this->actionFunc = func_80B4ADCC;
}

void func_80B4ADCC(EnInvadepoh *this, GlobalContext *globalCtx) {
    u16 temp_v0;

    this = this;
    if ((func_80152498(&globalCtx->msgCtx) == 5) && (this = this, (func_80147624(globalCtx) != 0))) {
        temp_v0 = this->textId;
        if (temp_v0 == 0x3331) {
            if ((gSaveContext.weekEventReg[22] & 2) != 0) {
                EnInvadepoh_SetTextID((Actor *) this, globalCtx, 0x3334, this);
                func_80151BB4(globalCtx, 0x1DU);
                func_80151BB4(globalCtx, 5U);
                return;
            }
            EnInvadepoh_SetTextID((Actor *) this, globalCtx, 0x3333, this);
            return;
        }
        if (temp_v0 == 0x3333) {
            func_80B4AEC0(this);
            return;
        }
        if (temp_v0 == 0x3334) {
            this = this;
            func_801477B4(globalCtx);
            func_80B4B024(this);
        }
        /* Duplicate return node #10. Try simplifying control flow for better match */
    }
}

void func_80B4AEC0(EnInvadepoh *this) {
    this->actionTimer = 2;
    this->actionFunc = func_80B4AEDC;
}

void func_80B4AEDC(EnInvadepoh *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        if (this->actionTimer == 0) {
            func_801477B4(globalCtx);
        }
    }
    if (Actor_HasParent((Actor *) this, globalCtx) != 0) {
        this->actor.parent = NULL;
        gSaveContext.weekEventReg[22] |= 2;
        func_80B4AF80(this);
        return;
    }
    func_800B8A1C((Actor *) this, globalCtx, 0x60, 2000.0f, 2000.0f);
}

void func_80B4AF80(EnInvadepoh *this) {
    this->actionFunc = func_80B4AF94;
}

void func_80B4AF94(EnInvadepoh *this, GlobalContext *globalCtx) {
    if (func_800B84D0((Actor *) this, globalCtx) != 0) {
        EnInvadepoh_SetTextID((Actor *) this, globalCtx, 0x3334);
        func_80151BB4(globalCtx, 0x1EU);
        func_80151BB4(globalCtx, 0x1DU);
        func_80151BB4(globalCtx, 5U);
        func_80B4ADB8(this);
        return;
    }
    func_800B85E0((Actor *) this, globalCtx, 2000.0f, -1);
}

void func_80B4B024(EnInvadepoh *this) {
    this->actor.flags &= -0xA;
    this->actionFunc = func_80B4B048;
}

void func_80B4B048(EnInvadepoh *this, GlobalContext *globalCtx) {
    MessageContext *sp1C;
    MessageContext *temp_a0;

    if (globalCtx->msgCtx.unk120B1 == 0) {
        temp_a0 = &globalCtx->msgCtx;
        if (globalCtx->msgCtx.unk11F22 == 0) {
            D_80B4E998 = 1;
            return;
        }
        sp1C = temp_a0;
        if ((func_80152498(temp_a0) == 6) || (func_80152498(temp_a0) == 5)) {
            D_80B4E998 = 1;
        }
        /* Duplicate return node #6. Try simplifying control flow for better match */
    }
}

void func_80B4B0C4(Actor *thisx, GlobalContext *globalCtx) {
    Actor *sp38;
    Actor *temp_a1;
    f32 *temp_a0;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        thisx->update = func_80B4B218;
        temp_a1 = &thisx[1];
        sp38 = temp_a1;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) temp_a1, &D_06013928, &D_06014088, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        SkelAnime_ChangeAnimTransitionRepeat((SkelAnime *) sp38, &D_06009E58, 0.0f);
        temp_a0 = &thisx[2].yDistToPlayer;
        sp38 = (Actor *) temp_a0;
        func_80B45C04(temp_a0, &D_80B4EA90, 1, &D_80B4EB00, 3, &D_801D15BC, (s16) 0x7D0, 0.08f, 0.3f, 0.03f);
        sp38->unk_2C = 0x7D0;
        sp38->unk_30 = 0.08f;
        func_800B4AEC(globalCtx, thisx, 50.0f);
        func_80B4516C((EnInvadepoh *) thisx);
        func_80B4ACDC(thisx);
    }
}

void func_80B4B218(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp38;
    Actor *sp34;
    s16 *sp28;
    s16 *temp_a2;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_v0;
    s16 phi_v0_2;

    sp38 = (thisx->flags & 0x40) == 0x40;
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if ((sp38 != 0) && (thisx->update != 0)) {
        SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        sp34 = globalCtx->actorCtx.actorList[2].first;
        Math_StepToS((s16 *) &thisx[2].shape.feetPos[1].z, 0x7D0, 0x28);
        Math_SmoothStepToS(&thisx->shape.rot.y, thisx->yawTowardsPlayer, 6, thisx->unk_370, (s16) 0x28);
        temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &thisx->focus, (Vec3f *) &sp34->focus) * 0.9f) - thisx->shape.rot.x;
        if ((s32) temp_v1 < -0xBB8) {
            thisx[2].yDistToPlayer.unk_26 = -0xBB8;
        } else {
            phi_v0 = temp_v1;
            if ((s32) temp_v1 >= 0xBB9) {
                phi_v0 = 0xBB8;
            }
            thisx[2].yDistToPlayer.unk_26 = phi_v0;
        }
        temp_f10 = (s32) ((f32) (s16) (thisx->yawTowardsPlayer - thisx->shape.rot.y) * 0.7f);
        if ((s32) (s16) temp_f10 < -0x1F40) {
            thisx[2].yDistToPlayer.unk_28 = -0x1F40;
        } else {
            phi_v0_2 = (s16) temp_f10;
            if ((s32) (s16) temp_f10 >= 0x1F41) {
                phi_v0_2 = 0x1F40;
            }
            thisx[2].yDistToPlayer.unk_28 = phi_v0_2;
        }
        func_80B45CE0(&thisx[2].yDistToPlayer);
        temp_a2 = &thisx[2].home.rot.z;
        sp28 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4B3DC(Actor *arg0) {
    SkelAnime *sp18;
    SkelAnime *temp_a0;

    temp_a0 = arg0 + 0x144;
    sp18 = temp_a0;
    if ((func_801378B8(temp_a0, 1.0f) != 0) || (func_801378B8(temp_a0, 7.0f) != 0)) {
        Audio_PlayActorSound2(arg0, 0x28EFU);
    }
}

void func_80B4B430(EnInvadepoh *arg0) {
    SkelAnime_ChangeAnimTransitionRepeat(arg0 + 0x144, &D_060021C8, -6.0f);
    arg0->actionTimer = Rand_S16Offset(0x32, 0x50);
    arg0->actionFunc = func_80B4B484;
}

void func_80B4B484(EnInvadepoh *this, GlobalContext *globalCtx) {
    s16 temp_v0;

    Math_StepToF(&this->actor.speedXZ, 1.1f, 0.5f);
    if (func_80B44C80((Actor *) this, globalCtx) != 0) {
        func_80B44690(this);
    }
    func_80B4B3DC((Actor *) this);
    if ((s32) this->unk3BC >= 0) {
        this->actionTimer = 0;
    }
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    func_80B4B510(this);
}

void func_80B4B510(EnInvadepoh *this) {
    SkelAnime_ChangeAnimTransitionRepeat(&this->skelAnime, &D_06001BD8, -6.0f);
    this->actionTimer = Rand_S16Offset(0x32, 0xC8);
    this->actionFunc = func_80B4B564;
}

void func_80B4B564(EnInvadepoh *this, GlobalContext *globalCtx) {
    ? sp28;
    f32 temp_f0;
    s16 temp_v0;
    s8 temp_v1;

    Math_StepToF(&this->actor.speedXZ, 3.8f, 0.45f);
    temp_v1 = this->unk3BC;
    if ((s32) temp_v1 >= 0) {
        Math_Vec3s_ToVec3f((Vec3f *) &sp28, &this->pathPoints[temp_v1]);
        temp_f0 = Math3D_DistanceSquared((Vec3f *) &this->actor.world, (Vec3f *) &sp28);
        if (temp_f0 < 6400.0f) {
            this->actor.speedXZ *= 0.85f;
        } else if (temp_f0 < 22500.0f) {
            this->actor.speedXZ *= 0.93f;
        } else if (temp_f0 < 62500.0f) {
            this->actor.speedXZ *= 0.96f;
        }
        if ((this->unk3BC == this->pathIndex) || (temp_f0 < 2500.0f)) {
            this->actionTimer = 0;
        }
    }
    func_80B4B3DC((Actor *) this);
    if (func_80B44C80((Actor *) this, globalCtx) != 0) {
        func_80B44690(this);
    }
    temp_v0 = this->actionTimer;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
        return;
    }
    if ((s32) this->unk3BC >= 0) {
        if ((D_80B50348 == 0) && (Rand_ZeroOne() < 0.4f)) {
            Audio_PlayActorSound2((Actor *) this, 0x290BU);
        }
        func_80B4B724(this);
        return;
    }
    func_80B4B430(this);
}

void func_80B4B724(EnInvadepoh *this) {
    SkelAnime_ChangeAnimTransitionStop(&this->skelAnime, &D_06000998, -6.0f);
    this->actionFunc = func_80B4B768;
}

void func_80B4B768(EnInvadepoh *this, GlobalContext *globalCtx) {
    SkelAnime *sp2C;
    SkelAnime *temp_a0;

    Math_StepToF(&this->actor.speedXZ, 0.0f, 1.0f);
    Math_SmoothStepToS(&this->actor.world.rot.y, Actor_YawBetweenActors((Actor *) this, D_80B5040C), 5, 0x1388, (s16) 0x64);
    func_80B44E90((Actor *) this, globalCtx);
    temp_a0 = &this->skelAnime;
    sp2C = temp_a0;
    if ((func_801378B8(temp_a0, 13.0f) != 0) || (func_801378B8(temp_a0, 19.0f) != 0)) {
        Audio_PlayActorSound2((Actor *) this, 0x2910U);
    }
    if (this->animPlayFlag != 0) {
        func_80B4B510(this);
    }
}

void func_80B4B820(EnInvadepoh *this) {
    SkelAnime_ChangeAnimTransitionStop(&this->skelAnime, &D_06001560, -6.0f);
    this->actionFunc = func_80B4B864;
}

void func_80B4B864(EnInvadepoh *this, GlobalContext *globalCtx) {
    Math_StepToF(&this->actor.speedXZ, 0.5f, 1.0f);
    func_80B44E90((Actor *) this, globalCtx);
    if (this->animPlayFlag != 0) {
        func_80B4B510(this);
    }
}

void func_80B4B8BC(Actor *thisx, GlobalContext *globalCtx) {
    s32 temp_v0;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_060080F0, &D_060021C8, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0xD);
        func_80B45C04(&thisx[2].yDistToPlayer, NULL, 0, NULL, 0, &D_801D15BC, (s16) 0xBB8, 0.1f, 0.0f, 0.0f);
        func_80B44664(thisx, globalCtx);
        EnInvadepoh_SetPathPointToWorldPos(thisx, 0);
        func_800B4AEC(globalCtx, thisx, 50.0f);
        func_80B4516C((EnInvadepoh *) thisx);
        Math_Vec3f_Copy((Vec3f *) &thisx[2].yDistToWater, (Vec3f *) &thisx->world);
        temp_v0 = D_80B4E940;
        if (temp_v0 == 2) {
            thisx->update = func_80B4BA84;
            thisx->draw = func_80B4E660;
            thisx->flags |= 1;
            func_80B4B430((EnInvadepoh *) thisx);
            return;
        }
        if (temp_v0 == 1) {
            thisx->update = func_80B4BA30;
            return;
        }
        Actor_MarkForDeath(thisx);
        /* Duplicate return node #6. Try simplifying control flow for better match */
    }
}

void func_80B4BA30(Actor *thisx, GlobalContext *globalCtx) {
    if (D_80B4E940 == 2) {
        thisx->update = func_80B4BA84;
        thisx->draw = func_80B4E660;
        thisx->flags |= 1;
        func_80B4B430();
    }
}

void func_80B4BA84(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp34;
    s32 sp2C;
    s16 *sp20;
    Actor *temp_v0;
    s16 *temp_a2;
    s32 temp_v0_3;
    s32 temp_v1_2;
    s8 temp_v0_2;
    s8 temp_v1;
    s32 phi_v0;

    sp34 = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_80B458D8();
    D_80B5040C = temp_v0;
    if (temp_v0 == 0) {
        temp_v0_2 = thisx->unk_3BC;
        thisx->unk_3BC = -1;
        if ((((s32) temp_v0_2 < 0) ^ 1) != 0) {
            func_80B4B820((EnInvadepoh *) thisx);
        }
    } else {
        sp2C = (s32) thisx->unk_3BC;
        thisx->unk_3BC = func_80B44234(thisx, (Vec3f *) &temp_v0->world);
        temp_v1 = thisx->unk_3BC;
        if (sp2C != temp_v1) {
            temp_v0_3 = temp_v1 - thisx->unk_309;
            phi_v0 = temp_v0_3;
            if (temp_v0_3 < 0) {
                phi_v0 = temp_v0_3 + thisx->unk_308;
            }
            temp_v1_2 = (s32) thisx->unk_308 >> 1;
            if (temp_v1_2 < phi_v0) {
                thisx->unk_30A = -1;
            } else if (phi_v0 < temp_v1_2) {
                thisx->unk_30A = 1;
            }
        }
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    thisx->unk_29C = SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
    if ((sp34 != 0) && (thisx->update != 0)) {
        func_80B45CE0(&thisx[2].yDistToPlayer);
        temp_a2 = &thisx[2].home.rot.z;
        sp20 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4BBE0(EnInvadepoh *arg0) {
    SkelAnime *temp_a0;
    void *temp_v0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06016720, -6.0f);
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_26 = 0;
    temp_v0->unk_28 = 0;
    temp_v0->unk_2A = 0;
    temp_v0->unk_2C = 0x320;
    temp_v0->unk_30 = 0.1f;
    arg0->behaviorInfo.unk4C = 0;
    arg0->actionFunc = func_80B4BC4C;
}

void func_80B4BC4C(EnInvadepoh *this, GlobalContext *globalCtx) {
    EnInvadepoh *sp50;
    s32 sp48;
    s16 sp42;
    s16 sp40;
    s16 *sp34;
    Vec3f *sp30;
    PosRot *sp2C;
    EnInvadepoh *temp_t6;
    PosRot *temp_a1;
    SkelAnime *temp_a0_4;
    Vec3f *temp_a0_3;
    s16 *temp_a0_2;
    s16 temp_a0;
    s16 temp_v1_2;
    s32 temp_f10;
    s32 temp_v1;
    s8 temp_v0;
    s16 phi_a0;
    s16 phi_a0_2;

    temp_t6 = D_80B503F4;
    sp50 = temp_t6;
    if (temp_t6 != 0) {
        temp_v0 = temp_t6->pathIndex;
        if (temp_v0 == 0) {
            this->unk304 = -0x8000;
            this->actor.flags &= -0xA;
            this->xzPosAdjFactor = 40.0f;
        } else if ((s32) temp_v0 < (sp50->endPoint - 1)) {
            this->xzPosAdjFactor = 40.0f;
            Math_ScaledStepToS(&this->unk304, -0x4800, 0xC8);
            this->actor.flags |= 9;
        } else {
            Math_StepToF(&this->xzPosAdjFactor, 5.0f, 3.0f);
            Math_ScaledStepToS(&this->unk304, -0x8000, 0x12C);
            this->actor.flags &= -0xA;
        }
        temp_a0 = this->unk304 + sp50->actor.world.rot.y;
        sp42 = temp_a0;
        this->actor.world.pos.x = (Math_SinS(temp_a0) * this->xzPosAdjFactor) + sp50->actor.world.pos.x;
        this->actor.world.pos.y = sp50->actor.world.pos.y;
        this->actor.world.pos.z = (Math_CosS(temp_a0) * this->xzPosAdjFactor) + sp50->actor.world.pos.z;
        func_800B4AEC(globalCtx, (Actor *) this, 50.0f);
        func_80B4516C(this);
        temp_a0_2 = &this->behaviorInfo.unk4C;
        sp34 = temp_a0_2;
        Math_StepToS(temp_a0_2, 0xBB8, 0x1F5);
        temp_a0_3 = &this->actor.prevPos;
        temp_a1 = &this->actor.world;
        sp2C = temp_a1;
        sp30 = temp_a0_3;
        if (Math3D_DistanceSquared(temp_a0_3, (Vec3f *) temp_a1) > 0.0001f) {
            Math_SmoothStepToS(&this->actor.shape.rot.y, Math_Vec3f_Yaw(temp_a0_3, (Vec3f *) sp2C), 3, this->behaviorInfo.unk4C, (s16) 0x1F4);
        }
        temp_v1 = (globalCtx->gameplayFrames + 0x14) & 0x7F;
        if ((temp_v1 & 0x40) != 0) {
            sp30 = (Vec3f *) &this->actor.shape.rot.y;
            sp48 = temp_v1;
            sp40 = Math_Vec3f_Yaw((Vec3f *) sp2C, (Vec3f *) &sp50->actor.world);
            if (temp_v1 == 0x40) {
                this->behaviorInfo.unk4C = 0;
            }
            Math_StepToS(sp34, 0x7D0, 0x28);
            Math_SmoothStepToS((s16 *) sp30, sp40, 6, this->behaviorInfo.unk4C, (s16) 0x28);
            temp_v1_2 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp50->actor.focus) * 0.85f) - this->actor.shape.rot.x;
            if ((s32) temp_v1_2 < -0xBB8) {
                this->behaviorInfo.unk26.x = -0xBB8;
            } else {
                phi_a0 = temp_v1_2;
                if ((s32) temp_v1_2 >= 0xBB9) {
                    phi_a0 = 0xBB8;
                }
                this->behaviorInfo.unk26.x = phi_a0;
            }
            temp_f10 = (s32) ((f32) (s16) (sp40 - this->actor.shape.rot.y) * 0.7f);
            if ((s32) (s16) temp_f10 < -0x1F40) {
                this->behaviorInfo.unk26.y = -0x1F40;
            } else {
                phi_a0_2 = (s16) temp_f10;
                if ((s32) (s16) temp_f10 >= 0x1F41) {
                    phi_a0_2 = 0x1F40;
                }
                this->behaviorInfo.unk26.y = phi_a0_2;
            }
        }
    }
    temp_a0_4 = &this->skelAnime;
    if (((this->actor.flags & 0x40) == 0x40) && ((sp34 = (s16 *) temp_a0_4, (func_801378B8(temp_a0_4, 0.0f) != 0)) || (func_801378B8(temp_a0_4, 12.0f) != 0))) {
        Audio_PlayActorSound2((Actor *) this, 0x3ABEU);
    }
    if ((s32) gSaveContext.time >= 0xD801) {
        Actor_MarkForDeath((Actor *) this);
        return;
    }
    if ((sp50 != 0) && (func_80B4CB0C == sp50->actionFunc)) {
        func_80B4C1BC(this);
    }
}

void func_80B4BFFC(Actor *arg0) {
    Actor *temp_a3;

    temp_a3 = arg0;
    temp_a3->unk_350 = 0x7D0;
    temp_a3[2].shape.shadowScale = 0.08f;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_0600A174, -6.0f);
    arg0->unk_370 = 0;
    arg0[2].velocity.x = func_80B4C058;
}

void func_80B4C058(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x9C4, 0x1C2);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 5, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    if (func_800B867C((Actor *) this, globalCtx) != 0) {
        func_80B4BBE0(this);
    }
}

void func_80B4C1BC(EnInvadepoh *this) {
    EnInvadepoh *temp_a3;

    temp_a3 = this;
    temp_a3->behaviorInfo.unk2C = 0x7D0;
    temp_a3->behaviorInfo.unk30 = 0.08f;
    this = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(&temp_a3->skelAnime, &D_0600A174, -6.0f);
    this->behaviorInfo.unk4C = 0;
    this->actionFunc = func_80B4C218;
}

void func_80B4C218(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    EnInvadepoh *temp_v0;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0xC8);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 6, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    temp_v0 = D_80B503F4;
    if (temp_v0 == 0) {
        func_80B4BBE0(this, (s16) temp_f10);
        return;
    }
    if ((temp_v0 != 0) && (func_80B4CB0C != temp_v0->actionFunc)) {
        func_80B4BBE0(this, (s16) temp_f10);
    }
}

void func_80B4C3A0(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp38;
    u16 temp_v0;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        temp_v0 = gSaveContext.time;
        thisx->objBankIndex = thisx->unk_2F4;
        sp38 = (s32) temp_v0;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44FEC();
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06015C28, &D_06016720, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x16);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EBDC, 1, &D_80B4EC08, 0, &D_801D15BC, (s16) 0x64, 0.03f, 0.3f, 0.03f);
        thisx->textId = 0x33CD;
        if ((s32) temp_v0 < 0xD5A0) {
            thisx->unk_304 = -0x8000;
            thisx[2].speedXZ = 40.0f;
        } else if ((s32) temp_v0 >= 0xD7D4) {
            thisx->unk_304 = -0x4800;
            thisx[2].speedXZ = 20.0f;
        } else {
            thisx->unk_304 = -0x8000;
            thisx[2].speedXZ = 40.0f;
        }
        if (((s32) temp_v0 >= 0x4000) && ((s32) temp_v0 < 0xD573)) {
            thisx->update = func_80B4C568;
            thisx->draw = NULL;
            return;
        }
        if (((s32) temp_v0 >= 0xD573) && ((s32) temp_v0 < 0xD800)) {
            thisx->update = func_80B4C5C0;
            thisx->draw = func_80B4E7BC;
            func_80B4BBE0((EnInvadepoh *) thisx);
            return;
        }
        Actor_MarkForDeath(thisx);
        /* Duplicate return node #13. Try simplifying control flow for better match */
    }
}

void func_80B4C568(Actor *thisx, GlobalContext *globalCtx) {
    u16 temp_v0;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 >= 0xD573) && ((s32) temp_v0 < 0xD800)) {
        thisx->update = func_80B4C5C0;
        thisx->draw = func_80B4E7BC;
        func_80B4BBE0();
    }
}

void func_80B4C5C0(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp2C;
    s32 sp28;
    s16 *sp24;
    s16 *temp_a2;
    s32 temp_v0;

    sp2C = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_800B84D0(thisx, globalCtx);
    sp28 = temp_v0;
    if (temp_v0 != 0) {
        func_80151BB4(globalCtx, 6U);
        func_80B4BFFC(thisx);
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if ((sp2C != 0) && (thisx->update != 0)) {
        SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        func_80B45CE0(&thisx[2].yDistToPlayer);
        if ((func_80B4C058 != (bitwise s32) thisx[2].velocity.x) && (sp28 == 0) && (thisx->isTargeted != 0)) {
            func_800B8614(thisx, globalCtx, 350.0f);
        }
        temp_a2 = &thisx[2].home.rot.z;
        sp24 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4C6C8(EnInvadepoh *arg0) {
    SkelAnime *temp_a0;
    void *temp_v0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a0, &D_06014088, -10.0f);
    temp_v0 = arg0 + 0x324;
    temp_v0->unk_26 = 0;
    temp_v0->unk_28 = 0;
    temp_v0->unk_2A = 0;
    temp_v0->unk_2C = 0x320;
    temp_v0->unk_30 = 0.1f;
    arg0->actionFunc = func_80B4C730;
}

void func_80B4C730(EnInvadepoh *this, GlobalContext *globalCtx) {
    EnInvadepoh *sp68;
    s32 sp60;
    ? sp4C;
    ? sp40;
    s16 sp3A;
    s32 sp2C;
    SkelAnime *temp_a0;
    s16 temp_v1_4;
    s32 temp_f6;
    s32 temp_v0_2;
    s32 temp_v1_3;
    s8 temp_v0;
    s8 temp_v1;
    s8 temp_v1_2;
    s8 phi_a2;
    s16 phi_a0;
    s16 phi_a0_2;

    sp68 = D_80B503F8;
    func_80B44700(this);
    func_80B44EFC((Actor *) this, globalCtx);
    func_80B43E6C(this, 6, 0x7D0, 0x64);
    temp_v1 = this->pathIndex;
    temp_v0 = this->endPoint;
    phi_a2 = temp_v0 - 1;
    if ((s32) temp_v1 < (s32) temp_v0) {
        phi_a2 = temp_v1;
    }
    sp2C = phi_a2 * 6;
    Math_Vec3s_ToVec3f((Vec3f *) &sp4C, &this->pathPoints[phi_a2]);
    Math_Vec3s_ToVec3f((Vec3f *) &sp40, &(&this->pathPoints[phi_a2])[1]);
    Math_SmoothStepToS(&this->actor.world.rot.y, Math_Vec3f_Yaw((Vec3f *) &sp4C, (Vec3f *) &sp40), 5, 0x7D0, (s16) 0x64);
    temp_v1_2 = this->pathIndex;
    if ((temp_v1_2 == 0) || (this->endPoint == (temp_v1_2 + 1))) {
        if (this->unk378 == 0) {
            temp_v0_2 = func_800FE620(globalCtx);
            if (temp_v0_2 > 0) {
                this->unk378 = func_80B45550(this, globalCtx, 6400.0f, (s32) ((((f32) gGameInfo->data[15] * -23.0f) / (f32) temp_v0_2) - 0.5f));
            }
        }
        this->actor.flags &= -0xA;
    } else {
        this->unk378 = 0;
        this->actor.flags |= 9;
    }
    temp_v1_3 = globalCtx->gameplayFrames & 0x7F;
    if ((temp_v1_3 & 0x40) != 0) {
        sp60 = temp_v1_3;
        sp3A = Math_Vec3f_Yaw((Vec3f *) &this->actor.world, (Vec3f *) &sp68->actor.world);
        if (temp_v1_3 == 0x40) {
            this->behaviorInfo.unk4C = 0;
        }
        Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0x28);
        Math_SmoothStepToS(&this->actor.shape.rot.y, sp3A, 6, this->behaviorInfo.unk4C, (s16) 0x28);
        temp_v1_4 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp68->actor.focus) * 0.85f) - this->actor.shape.rot.x;
        if ((s32) temp_v1_4 < -0xBB8) {
            this->behaviorInfo.unk26.x = -0xBB8;
        } else {
            phi_a0 = temp_v1_4;
            if ((s32) temp_v1_4 >= 0xBB9) {
                phi_a0 = 0xBB8;
            }
            this->behaviorInfo.unk26.x = phi_a0;
        }
        temp_f6 = (s32) ((f32) (s16) (sp3A - this->actor.shape.rot.y) * 0.7f);
        if ((s32) (s16) temp_f6 < -0x1F40) {
            this->behaviorInfo.unk26.y = -0x1F40;
        } else {
            phi_a0_2 = (s16) temp_f6;
            if ((s32) (s16) temp_f6 >= 0x1F41) {
                phi_a0_2 = 0x1F40;
            }
            this->behaviorInfo.unk26.y = phi_a0_2;
        }
    }
    temp_a0 = &this->skelAnime;
    if (((this->actor.flags & 0x40) == 0x40) && ((sp2C = (s32) temp_a0, (func_801378B8(temp_a0, 0.0f) != 0)) || (func_801378B8(temp_a0, 7.0f) != 0))) {
        Audio_PlayActorSound2((Actor *) this, 0x3ABEU);
    }
    if (this->clockTime >= 0.9999f) {
        Actor_MarkForDeath((Actor *) this);
        return;
    }
    if ((sp68 != 0) && (func_80B4C058 == sp68->actionFunc)) {
        func_80B4CC70(this);
    }
}

void func_80B4CAB0(Actor *arg0) {
    Actor *temp_a3;

    temp_a3 = arg0;
    temp_a3->unk_350 = 0xFA0;
    temp_a3[2].shape.shadowScale = 0.08f;
    arg0 = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(temp_a3 + 0x144, &D_06009E58, -10.0f);
    arg0->unk_370 = 0;
    arg0[2].velocity.x = func_80B4CB0C;
}

void func_80B4CB0C(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0xBB8, 0x1F4);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 6, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    if (func_800B867C((Actor *) this, globalCtx) != 0) {
        func_80B4C6C8(this);
    }
}

void func_80B4CC70(EnInvadepoh *this) {
    EnInvadepoh *temp_a3;

    temp_a3 = this;
    temp_a3->behaviorInfo.unk2C = 0x7D0;
    temp_a3->behaviorInfo.unk30 = 0.08f;
    this = temp_a3;
    SkelAnime_ChangeAnimTransitionRepeat(&temp_a3->skelAnime, &D_06009E58, -10.0f);
    this->behaviorInfo.unk4C = 0;
    this->actionFunc = func_80B4CCCC;
}

void func_80B4CCCC(EnInvadepoh *this, GlobalContext *globalCtx) {
    Actor *sp28;
    EnInvadepoh *temp_v0;
    s16 temp_v1;
    s32 temp_f10;
    s16 phi_a0;
    s16 phi_a0_2;

    sp28 = globalCtx->actorCtx.actorList[2].first;
    Math_StepToS(&this->behaviorInfo.unk4C, 0x7D0, 0xC8);
    Math_SmoothStepToS(&this->actor.shape.rot.y, this->actor.yawTowardsPlayer, 6, this->behaviorInfo.unk4C, (s16) 0x28);
    temp_v1 = (s32) ((f32) Math_Vec3f_Pitch((Vec3f *) &this->actor.focus, (Vec3f *) &sp28->focus) * 0.85f) - this->actor.shape.rot.x;
    if ((s32) temp_v1 < -0xBB8) {
        this->behaviorInfo.unk26.x = -0xBB8;
    } else {
        phi_a0 = temp_v1;
        if ((s32) temp_v1 >= 0xBB9) {
            phi_a0 = 0xBB8;
        }
        this->behaviorInfo.unk26.x = phi_a0;
    }
    temp_f10 = (s32) ((f32) (s16) (this->actor.yawTowardsPlayer - this->actor.shape.rot.y) * 0.7f);
    if ((s32) (s16) temp_f10 < -0x1F40) {
        this->behaviorInfo.unk26.y = -0x1F40;
    } else {
        phi_a0_2 = (s16) temp_f10;
        if ((s32) (s16) temp_f10 >= 0x1F41) {
            phi_a0_2 = 0x1F40;
        }
        this->behaviorInfo.unk26.y = phi_a0_2;
    }
    temp_v0 = D_80B503F8;
    if (temp_v0 == 0) {
        func_80B4C6C8(this, (s16) temp_f10);
        return;
    }
    if ((temp_v0 != 0) && (func_80B4C058 != temp_v0->actionFunc)) {
        func_80B4C6C8(this, (s16) temp_f10);
    }
}

void func_80B4CE54(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp38;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        sp38 = (s32) gSaveContext.time;
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B44F58();
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06013928, &D_06014088, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0x17);
        func_80B45C04(&thisx[2].yDistToPlayer, &D_80B4EA90, 1, &D_80B4EB00, 3, &D_801D15BC, (s16) 0x64, 0.03f, 0.3f, 0.03f);
        func_80B446D0(thisx, globalCtx);
        thisx->world.rot.y = thisx->shape.rot.y;
        func_80B44700((EnInvadepoh *) thisx);
        func_80B44EFC(thisx, globalCtx);
        func_80B43F0C(thisx);
        func_80B4516C((EnInvadepoh *) thisx);
        thisx->textId = 0x33CE;
        if ((sp38 >= 0x4000) && (sp38 < 0xD555)) {
            thisx->update = func_80B4CFFC;
            thisx->draw = NULL;
            return;
        }
        if ((sp38 >= 0xD555) && (sp38 < 0xD7E1)) {
            thisx->update = func_80B4D054;
            thisx->draw = func_80B4E324;
            func_80B4C6C8((EnInvadepoh *) thisx);
            return;
        }
        Actor_MarkForDeath(thisx);
        /* Duplicate return node #8. Try simplifying control flow for better match */
    }
}

void func_80B4CFFC(Actor *thisx, GlobalContext *globalCtx) {
    u16 temp_v0;

    temp_v0 = gSaveContext.time;
    if (((s32) temp_v0 >= 0xD555) && ((s32) temp_v0 < 0xD7E1)) {
        thisx->update = func_80B4D054;
        thisx->draw = func_80B4E324;
        func_80B4C6C8();
    }
}

void func_80B4D054(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp2C;
    s32 sp28;
    s16 *sp24;
    s16 *temp_a2;
    s32 temp_v0;

    sp2C = (thisx->flags & 0x40) == 0x40;
    temp_v0 = func_800B84D0(thisx, globalCtx);
    sp28 = temp_v0;
    if (temp_v0 != 0) {
        func_80151BB4(globalCtx, 5U);
        func_80B4CAB0(thisx);
    }
    (bitwise ? (*)(Actor *, GlobalContext *)) thisx[2].velocity.x(thisx, globalCtx);
    if ((sp2C != 0) && (thisx->update != 0)) {
        SkelAnime_FrameUpdateMatrix((SkelAnime *) &thisx[1]);
        func_80B45CE0(&thisx[2].yDistToPlayer);
        if ((func_80B4CB0C != (bitwise s32) thisx[2].velocity.x) && (sp28 == 0) && (thisx->isTargeted != 0)) {
            func_800B8614(thisx, globalCtx, 350.0f);
        }
        temp_a2 = &thisx[2].home.rot.z;
        sp24 = temp_a2;
        Collider_UpdateCylinder(thisx, (ColliderCylinder *) temp_a2);
        CollisionCheck_SetOC(globalCtx, &globalCtx->colChkCtx, (Collider *) temp_a2);
    }
}

void func_80B4D15C(Actor *arg0) {
    s32 sp28;
    void *sp20;
    f32 temp_f6;
    f32 temp_f8;
    s32 temp_v1;
    void *temp_v0;

    temp_v1 = arg0->params & 7;
    sp28 = temp_v1;
    SkelAnime_ChangeAnimDefaultRepeat(arg0 + 0x144, &D_06001674);
    arg0->unk_389 = 0xFF;
    arg0->draw = func_80B4DB14;
    arg0->unk_38B = 1;
    arg0->unk_38C = 0;
    arg0->unk_38D = 0xFF;
    temp_v0 = (temp_v1 * 8) + &D_80B4EE0C;
    arg0->unk_15C = (f32) ((f32) (arg0->params & 7) * arg0[1].home.pos.z * 0.25f);
    arg0->unk_304 = (s16) (temp_v1 * 0x5555);
    arg0[2].minVelocityY = temp_v0->unk_0;
    sp20 = temp_v0;
    temp_f8 = Math_SinS(arg0->unk_304) * 80.0f;
    arg0->world.pos.y = arg0->home.pos.y;
    arg0->world.pos.x = temp_f8 + arg0->home.pos.x;
    temp_f6 = Math_CosS(arg0->unk_304) * 80.0f;
    arg0->shape.rot.y = arg0->unk_304 + 0x4000;
    arg0->world.pos.z = temp_f6 + arg0->home.pos.z;
    arg0->unk_370 = (s16) temp_v0->unk_4;
    arg0[2].velocity.x = func_80B4D290;
    arg0->velocity.y = 0.0f;
    arg0->unk_372 = (s16) temp_v0->unk_6;
}

void func_80B4D290(EnInvadepoh *this, GlobalContext *globalCtx) {
    f32 sp28;
    Actor *temp_v1;
    f32 temp_f10;

    if (D_80B503F0 == 0) {
        Actor_MarkForDeath((Actor *) this);
        return;
    }
    Math_StepToF(&this->actor.velocity.y, 15.0f, this->velocityStep);
    sp28 = Math_SmoothStepToF(&this->actor.world.pos.y, this->actor.home.pos.y + 850.0f, 0.2f, this->actor.velocity.y, 0.01f);
    this->unk304 += 0x2BC;
    this->actor.world.pos.x = (Math_SinS(this->unk304) * 80.0f) + this->actor.home.pos.x;
    temp_f10 = Math_CosS(this->unk304) * 80.0f;
    this->behaviorInfo.unk4C += this->behaviorInfo.unk4E;
    temp_v1 = this->actor.child;
    this->actor.shape.rot.y += this->behaviorInfo.unk4C;
    this->actor.world.pos.z = temp_f10 + this->actor.home.pos.z;
    if (temp_v1 != 0) {
        temp_v1->world.pos.x = this->actor.world.pos.x;
        temp_v1->world.pos.y = this->actor.world.pos.y - 38.0f;
        temp_v1->world.pos.z = this->actor.world.pos.z;
        temp_v1->shape.rot.y = this->actor.shape.rot.y;
    }
    if (sp28 < 5.0f) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void func_80B4D3E4(Actor *arg0) {
    SkelAnime *temp_a0;

    temp_a0 = arg0 + 0x144;
    arg0 = arg0;
    SkelAnime_ChangeAnimDefaultRepeat(temp_a0, &D_06001674);
    arg0->unk_389 = 0xFF;
    arg0->draw = NULL;
    arg0->unk_38B = 1;
    arg0->unk_38C = 0;
    arg0->unk_38D = 0xFF;
    arg0->unk_306 = 0x190;
    arg0->unk_304 = 0;
    arg0->unk_2F0 = 0xC8;
    arg0[2].velocity.x = func_80B4D480;
    arg0->velocity.y = 0.0f;
    arg0->unk_15C = (f32) ((f32) (arg0->params & 7) * arg0[1].home.pos.z * 0.25f);
}

void func_80B4D480(EnInvadepoh *this, GlobalContext *globalCtx) {
    s32 sp2C;
    Actor *temp_v1;
    s16 temp_v0;
    s16 temp_v0_2;
    s32 phi_t0;

    temp_v0 = this->actionTimer;
    phi_t0 = 0;
    if ((s32) temp_v0 > 0) {
        this->actionTimer = temp_v0 - 1;
    }
    if ((s32) this->actionTimer >= 0xA1) {
        this->actor.draw = NULL;
    } else {
        temp_v0_2 = this->actionTimer;
        this->actor.draw = func_80B4DB14;
        if (((s32) temp_v0_2 < 0x69) && ((s32) temp_v0_2 >= 0x64)) {
            this->actor.gravity = -1.0f;
            sp2C = 0;
            Math_SmoothStepToS((s16 *) &this->actor.shape, 0x2000, 8, 0x320, (s16) 0x28);
        } else {
            this->actor.gravity = 0.7f;
            sp2C = 0;
            Math_SmoothStepToS((s16 *) &this->actor.shape, 0, 8, 0x320, (s16) 0x28);
        }
        this->actor.velocity.y += this->actor.gravity;
        this->actor.velocity.y *= 0.92f;
        phi_t0 = sp2C;
        if ((s32) this->actionTimer >= 0x51) {
            this->actor.world.pos.y += this->actor.velocity.y;
        } else {
            phi_t0 = Math_StepToF(&this->actor.world.pos.y, this->actor.home.pos.y + 850.0f, fabsf(this->actor.velocity.y));
        }
        temp_v1 = this->actor.child;
        this->unk306 = (s16) (s32) ((((f32) this->unk304 * -0.06f) + (f32) this->unk306) * 0.98f);
        this->actor.shape.rot.y += this->unk306;
        if (temp_v1 != 0) {
            temp_v1->world.pos.x = this->actor.world.pos.x;
            temp_v1->world.pos.y = this->actor.world.pos.y - 30.0f;
            temp_v1->world.pos.z = this->actor.world.pos.z;
            temp_v1->shape.rot.y = this->actor.shape.rot.y;
        }
    }
    if (((s32) this->actionTimer <= 0) || (phi_t0 != 0)) {
        Actor_MarkForDeath((Actor *) this);
    }
}

void func_80B4D670(Actor *thisx, GlobalContext *globalCtx) {
    s32 sp34;

    if (Object_IsLoaded(&globalCtx->objectCtx, (s32) thisx->unk_2F4) != 0) {
        sp34 = thisx->params & 7;
        thisx->objBankIndex = thisx->unk_2F4;
        Actor_SetObjectSegment(globalCtx, thisx);
        func_80B45080();
        thisx->update = func_80B4D760;
        SkelAnime_InitSV(globalCtx, (SkelAnime *) &thisx[1], &D_06004E50, &D_06001674, (Vec3s *) &thisx[1].focus.pos.z, thisx + 0x212, 0xE);
        if (sp34 < 3) {
            func_80B453F4(thisx, globalCtx, sp34);
            func_80B4D15C(thisx);
            return;
        }
        func_80B45460(thisx, globalCtx, sp34);
        func_80B4D3E4(thisx);
        /* Duplicate return node #4. Try simplifying control flow for better match */
    }
}

void func_80B4D760(Actor *thisx, GlobalContext *globalCtx) {
    Actor *temp_a0;
    Actor *temp_a2;

    temp_a2 = thisx;
    thisx = temp_a2;
    (bitwise ? (*)(Actor *, Actor *)) temp_a2[2].velocity.x(temp_a2, temp_a2);
    temp_a0 = &thisx[1];
    if (thisx->update != 0) {
        thisx = thisx;
        SkelAnime_FrameUpdateMatrix((SkelAnime *) temp_a0);
        func_800B9010(thisx, 0x320AU);
    }
}

void func_80B4D7B8(GraphicsContext **arg0) {
    Gfx *temp_v0_2;
    Gfx *temp_v0_3;
    Gfx *temp_v0_4;
    Gfx *temp_v0_5;
    Gfx *temp_v0_6;
    Gfx *temp_v0_7;
    GraphicsContext *temp_a0;
    GraphicsContext *temp_s0;
    s32 temp_s3;
    s32 temp_v0;
    u32 temp_s5;
    u32 temp_s6;
    ? *phi_s2;
    s32 phi_s3;

    temp_a0 = arg0->unk_0;
    temp_s0 = temp_a0;
    func_8012C2DC(temp_a0);
    phi_s2 = &D_80B50350;
    phi_s3 = 0;
    do {
        if ((s32) phi_s2->unk_1 > 0) {
            temp_v0 = arg0[25104];
            temp_s5 = (temp_v0 + (phi_s3 * 0x10)) & 0x7F;
            temp_s6 = (temp_v0 * -0xF) & 0xFF;
            SysMatrix_InsertTranslation(phi_s2->unk_4, phi_s2->unk_8, phi_s2->unk_C, 0);
            Matrix_Scale(0.1f, 0.1f, 0.1f, 1);
            temp_v0_2 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_2[1];
            temp_v0_2->words.w1 = 0;
            temp_v0_2->words.w0 = 0xE7000000;
            temp_v0_3 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_3[1];
            temp_v0_3->words.w0 = 0xFA008080;
            temp_v0_3->words.w1 = phi_s2->unk_2 | ~0x55FF;
            temp_v0_4 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_4[1];
            temp_v0_4->words.w1 = 0xFF320000;
            temp_v0_4->words.w0 = 0xFB000000;
            temp_v0_5 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_5[1];
            temp_v0_5->words.w0 = 0xDB060020;
            temp_v0_5->words.w1 = Gfx_TwoTexScroll(arg0->unk_0, 0, temp_s5, 0U, 0x20, 0x40, 1, 0U, temp_s6, 0x20, 0x40);
            temp_v0_6 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_6[1];
            temp_v0_6->words.w0 = 0xDA380003;
            temp_v0_6->words.w1 = Matrix_NewMtx(arg0->unk_0);
            temp_v0_7 = temp_s0->polyXlu.p;
            temp_s0->polyXlu.p = &temp_v0_7[1];
            temp_v0_7->words.w1 = (u32) D_0402E510;
            temp_v0_7->words.w0 = 0xDE000000;
        }
        temp_s3 = phi_s3 + 1;
        phi_s2 += 0x10;
        phi_s3 = temp_s3;
    } while (temp_s3 != 0xA);
}

void func_80B4D9B4(Actor *thisx, GlobalContext *globalCtx) {
    func_80B4D7B8((GraphicsContext **) globalCtx);
}

s32 func_80B4D9D8(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3) {
    return 0;
}

void func_80B4D9F4(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4) {
    if ((arg1 == 0xC) && (arg4->unk_38D != 0)) {
        SysMatrix_StatePush();
        SysMatrix_InsertZRotation_s(-0x53ED, 1);
        Matrix_RotateY(-0x3830, 1U);
        Matrix_Scale(1.0f, 1.0f, 1.5f, 1);
        SysMatrix_CopyCurrentState(&D_80B502A0);
        SysMatrix_StatePop();
    } else if ((arg1 == 0xD) && (arg4->unk_38D != 0)) {
        SysMatrix_StatePush();
        SysMatrix_InsertZRotation_s(-0x53ED, 1);
        Matrix_RotateY(-0x47D0, 1U);
        Matrix_Scale(1.0f, 1.0f, 1.5f, 1);
        SysMatrix_CopyCurrentState(&D_80B502E0);
        SysMatrix_StatePop();
    }
    if (arg1 == 0xB) {
        SysMatrix_MultiplyVector3fByState(&D_80B4EE24, arg4 + 0x3C);
    }
}

void func_80B4DB14(Actor *thisx, GlobalContext *globalCtx) {
    GraphicsContext *spCC;
    Gfx *spBC;
    GraphicsContext *spB8;
    f32 sp80;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    GraphicsContext *sp6C;
    Gfx *sp54;
    ? *sp4C;
    Gfx *temp_s0;
    Gfx *temp_s0_2;
    Gfx *temp_s0_3;
    Gfx *temp_s0_4;
    Gfx *temp_s0_5;
    Gfx *temp_v0;
    Gfx *temp_v0_2;
    Gfx *temp_v0_3;
    Gfx *temp_v0_5;
    Gfx *temp_v1;
    Gfx *temp_v1_2;
    Gfx *temp_v1_3;
    Gfx *temp_v1_4;
    Gfx *temp_v1_5;
    Gfx *temp_v1_6;
    Gfx *temp_v1_7;
    Gfx *temp_v1_8;
    GraphicsContext *temp_a0;
    GraphicsContext *temp_a2;
    GraphicsContext *temp_v0_4;
    f32 temp_f14;

    temp_a0 = globalCtx->state.gfxCtx;
    spCC = temp_a0;
    func_8012C2DC(temp_a0);
    SysMatrix_StatePush();
    if (thisx->unk_38B != 0) {
        if (thisx->unk_389 == 0xFF) {
            func_8012C28C(globalCtx->state.gfxCtx);
            AnimatedMat_Draw(globalCtx, (AnimatedMaterial *) D_80B50400);
            Scene_SetRenderModeXlu(globalCtx, 0, 1U);
            temp_v1 = spCC->polyOpa.p;
            spCC->polyOpa.p = &temp_v1[1];
            temp_v1->words.w1 = 0xFF;
            temp_v1->words.w0 = 0xFB000000;
            spCC->polyOpa.p = SkelAnime_DrawSV2(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, func_80B4D9D8, func_80B4D9F4, thisx, spCC->polyOpa.p);
        } else {
            AnimatedMat_Draw(globalCtx, (AnimatedMaterial *) D_80B50400);
            Scene_SetRenderModeXlu(globalCtx, 1, 2U);
            temp_v0 = spCC->polyXlu.p;
            spCC->polyXlu.p = &temp_v0[1];
            temp_v0->words.w0 = 0xFB000000;
            temp_v0->words.w1 = (u32) thisx->unk_389;
            spCC->polyXlu.p = SkelAnime_DrawSV2(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, func_80B4D9D8, func_80B4D9F4, thisx, spCC->polyXlu.p);
        }
        if (thisx->unk_38D != 0) {
            AnimatedMat_Draw(globalCtx, (AnimatedMaterial *) D_80B503FC);
            temp_a2 = globalCtx->state.gfxCtx;
            temp_v1_2 = temp_a2->polyXlu.p;
            temp_v1_2->words.w0 = 0xE7000000;
            temp_v1_2->words.w1 = 0;
            temp_v1_3 = &temp_v1_2[1];
            temp_v1_3->words.w0 = 0xFA0000FF;
            temp_v1_3->words.w1 = 0xF0B4643C;
            temp_v1_4 = &temp_v1_3[1];
            temp_v1_4->words.w0 = 0xFB000000;
            temp_v1_5 = &temp_v1_4[1];
            temp_v1_4->words.w1 = ((u32) ((f32) thisx->unk_38D * 0.5882353f) & 0xFF) | ~0xFF;
            spBC = temp_v1_5;
            spB8 = temp_a2;
            SysMatrix_InsertMatrix(&D_80B502A0, 0);
            temp_v1_5->words.w0 = 0xDA380003;
            temp_v1_6 = &temp_v1_5[1];
            spBC = temp_v1_6;
            temp_v1_5->words.w1 = Matrix_NewMtx(globalCtx->state.gfxCtx);
            temp_v1_6->words.w0 = 0xDE000000;
            temp_v1_6->words.w1 = (u32) &D_06000080;
            temp_v1_7 = &temp_v1_6[1];
            spBC = temp_v1_7;
            sp4C = &D_06000080;
            SysMatrix_InsertMatrix(&D_80B502E0, 0);
            temp_v1_7->words.w0 = 0xDA380003;
            temp_v1_8 = &temp_v1_7[1];
            spBC = temp_v1_8;
            sp4C = &D_06000080;
            temp_v1_7->words.w1 = Matrix_NewMtx(globalCtx->state.gfxCtx);
            temp_v1_8->words.w0 = 0xDE000000;
            temp_v1_8->words.w1 = (u32) &D_06000080;
            spB8->polyXlu.p = &temp_v1_8[1];
        }
    }
    if (thisx->unk_38C != 0) {
        SysMatrix_SetStateRotationAndTranslation(thisx->world.pos.x, thisx->world.pos.y + 68.0f, thisx->world.pos.z, (Vec3s *) &thisx->shape);
        Matrix_Scale(thisx[2].prevPos.x, thisx[2].prevPos.y, thisx[2].prevPos.z, 1);
        temp_v0_2 = spCC->polyXlu.p;
        spCC->polyXlu.p = &temp_v0_2[1];
        temp_v0_2->words.w0 = 0xDA380003;
        temp_v0_2->words.w1 = Matrix_NewMtx(globalCtx->state.gfxCtx);
        temp_v0_3 = spCC->polyXlu.p;
        spCC->polyXlu.p = &temp_v0_3[1];
        temp_v0_3->words.w0 = 0xDE000000;
        temp_v0_3->words.w1 = (u32) &D_06000720;
    }
    if (thisx->unk_38B != 0) {
        temp_v0_4 = globalCtx->state.gfxCtx;
        sp6C = temp_v0_4;
        temp_v0_5 = func_8012C868(temp_v0_4->polyXlu.p);
        temp_v0_5->words.w1 = 0x80;
        temp_v0_5->words.w0 = 0xE3001803;
        temp_s0 = &temp_v0_5[1];
        temp_s0->words.w0 = 0xFCFF97FF;
        temp_s0->words.w1 = 0xFF2DFEFF;
        temp_s0_2 = &temp_s0[1];
        SysMatrix_InsertMatrix(&globalCtx->mf_187FC, 0);
        SysMatrix_GetStateTranslationAndScaledZ(60.0f, (Vec3f *) &sp80);
        sp74 = thisx->world.pos.x + sp80;
        temp_f14 = thisx->world.pos.y + sp84 + 68.0f;
        sp78 = temp_f14;
        sp7C = thisx->world.pos.z + sp88;
        SysMatrix_InsertTranslation(sp74, temp_f14, sp7C, 0);
        Matrix_Scale(0.25f, 0.25f, 0.25f, 1);
        temp_s0_3 = &temp_s0_2[1];
        temp_s0_2->words.w0 = 0xDE000000;
        temp_s0_2->words.w1 = (u32) D_04029CB0;
        temp_s0_3->words.w1 = ((s32) ((f32) thisx->unk_389 * 0.39215687f) & 0xFF) | 0xF0B46400;
        temp_s0_3->words.w0 = 0xFA000000;
        temp_s0_4 = &temp_s0_3[1];
        temp_s0_4->words.w0 = 0xDA380003;
        sp54 = temp_s0_4;
        temp_s0_5 = &temp_s0_4[1];
        temp_s0_4->words.w1 = Matrix_NewMtx(globalCtx->state.gfxCtx);
        temp_s0_5->words.w1 = (u32) D_04029CF0;
        temp_s0_5->words.w0 = 0xDE000000;
        sp6C->polyXlu.p = &temp_s0_5[1];
        if (((s32) thisx->unk_389 >= 0x81) && (func_80B456A8(globalCtx, (Vec3f *) &sp74) != 0)) {
            func_800F9824(globalCtx, &globalCtx->envCtx, &globalCtx->view, globalCtx->state.gfxCtx, (bitwise Vec3f) sp74.unk_0, (&sp74)[1], (&sp74)[2], (s8) 10.0f, (s8) 9.0f, 0, 0);
        }
    }
    SysMatrix_StatePop();
}

s32 func_80B4E120(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, s16 *arg4, Actor *arg5) {
    if (arg1 == 5) {
        *arg4 -= arg5->shape.rot.x;
    }
    return 0;
}

void func_80B4E158(Actor *thisx, GlobalContext *globalCtx) {
    func_8012C5B0(globalCtx->state.gfxCtx);
    SkelAnime_DrawSV(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, (s32 (*)(GlobalContext *, s32, Gfx **, Vec3f *, Vec3s *, Actor *)) func_80B4E120, NULL, thisx);
}

void func_80B4E1B0(Actor *thisx, GlobalContext *globalCtx) {
    func_8012C5B0(globalCtx->state.gfxCtx);
    SkelAnime_DrawSV(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, NULL, NULL, thisx);
}

s32 func_80B4E200(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5) {
    if (arg1 == 0xE) {
        arg4->x += arg5[2].shape.rot.y;
        arg4->y += arg5[2].shape.rot.z;
        arg4->z += arg5[2].shape.rot.x;
    } else if (arg1 == 0xD) {
        arg4->x += (s32) (arg5->unk_358 * (f32) arg5[2].shape.rot.y);
        arg4->z += arg5->unk_364;
    }
    return 0;
}

void func_80B4E2AC(void **arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4) {
    void *temp_a0;
    void *temp_v1;

    if (arg1 == 0x13) {
        temp_a0 = *arg0;
        temp_v1 = temp_a0->unk_2B0;
        temp_a0->unk_2B0 = (void *) (temp_v1 + 8);
        temp_v1->unk_4 = &D_060003B0;
        temp_v1->unk_0 = 0xDE000000;
        return;
    }
    if (arg1 == 0xE) {
        SysMatrix_MultiplyVector3fByState(&D_80B4EE30, arg4 + 0x3C);
    }
}

void func_80B4E324(Actor *thisx, GlobalContext *globalCtx) {
    GraphicsContext *sp30;
    Gfx *temp_v1;
    Gfx *temp_v1_2;
    GraphicsContext *temp_a0;

    temp_a0 = globalCtx->state.gfxCtx;
    sp30 = temp_a0;
    func_8012C28C(temp_a0);
    temp_v1 = sp30->polyOpa.p;
    sp30->polyOpa.p = &temp_v1[1];
    temp_v1->words.w0 = 0xDB060024;
    temp_v1->words.w1 = (u32) D_80B4E958[(s8) thisx[2].colChkInfo.acHitEffect];
    temp_v1_2 = sp30->polyOpa.p;
    sp30->polyOpa.p = &temp_v1_2[1];
    temp_v1_2->words.w0 = 0xDB060020;
    temp_v1_2->words.w1 = (u32) D_80B4E944[thisx->unk_333];
    SkelAnime_DrawSV(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, func_80B4E200, (void (*)(GlobalContext *, s32, Gfx **, Vec3s *, Actor *)) func_80B4E2AC, thisx);
}

void func_80B4E3F0(Actor *thisx, GlobalContext *globalCtx) {
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    GraphicsContext *sp58;
    Gfx *sp50;
    MtxF *sp40;
    Gfx *temp_v0;
    Gfx *temp_v0_2;
    Gfx *temp_v0_3;
    Gfx *temp_v0_4;
    GraphicsContext *temp_a0_3;
    MtxF *temp_a0;
    f32 *temp_a0_2;

    SysMatrix_StatePush();
    temp_a0 = &globalCtx->mf_187FC;
    sp40 = temp_a0;
    SysMatrix_InsertMatrix(temp_a0, 0);
    SysMatrix_GetStateTranslationAndScaledZ(200.0f, (Vec3f *) &sp5C);
    SysMatrix_StatePop();
    temp_a0_2 = &sp5C;
    sp5C += thisx->world.pos.x;
    sp60 += thisx->world.pos.y;
    sp64 += thisx->world.pos.z;
    EnInvadepoh_SetSysMatrix(temp_a0_2);
    SysMatrix_NormalizeXYZ(temp_a0);
    SysMatrix_InsertZRotation_s(thisx->unk_304, 1);
    temp_a0_3 = globalCtx->state.gfxCtx;
    sp58 = temp_a0_3;
    func_8012C2DC(temp_a0_3);
    temp_v0 = sp58->polyXlu.p;
    sp58->polyXlu.p = &temp_v0[1];
    temp_v0->words.w0 = 0xDA380003;
    sp58 = sp58;
    sp50 = temp_v0;
    sp50->words.w1 = Matrix_NewMtx(globalCtx->state.gfxCtx);
    temp_v0_2 = sp58->polyXlu.p;
    sp58->polyXlu.p = &temp_v0_2[1];
    temp_v0_2->words.w0 = 0xFA00FF80;
    temp_v0_2->words.w1 = 0xFFFF00B4;
    temp_v0_3 = sp58->polyXlu.p;
    sp58->polyXlu.p = &temp_v0_3[1];
    temp_v0_3->words.w1 = 0xFF320000;
    temp_v0_3->words.w0 = 0xFB000000;
    temp_v0_4 = sp58->polyXlu.p;
    sp58->polyXlu.p = &temp_v0_4[1];
    temp_v0_4->words.w0 = 0xDE000000;
    temp_v0_4->words.w1 = (u32) D_04023210;
    if (func_80B456A8(globalCtx, (Vec3f *) &sp5C) != 0) {
        func_800F9824(globalCtx, &globalCtx->envCtx, &globalCtx->view, globalCtx->state.gfxCtx, (bitwise Vec3f) sp5C.unk_0, (&sp5C)[1], (&sp5C)[2], (s8) 20.0f, (s8) 9.0f, 0, 0);
    }
}

s32 func_80B4E5B0(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5) {
    if ((arg1 == 5) || (arg1 == 6) || (arg1 == 7)) {
        arg4->x += arg5[2].shape.rot.x;
        arg4->y += arg5[2].shape.rot.y;
        arg4->z += arg5[2].shape.rot.z;
    }
    return 0;
}

void func_80B4E61C(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4) {
    if (arg1 == 5) {
        SysMatrix_GetStateTranslationAndScaledY(20.0f, arg4 + 0x3C);
    }
}

void func_80B4E660(Actor *thisx, GlobalContext *globalCtx) {
    GraphicsContext *sp28;
    Gfx *temp_v1;
    GraphicsContext *temp_a0;

    temp_a0 = globalCtx->state.gfxCtx;
    sp28 = temp_a0;
    func_8012C28C(temp_a0);
    temp_v1 = sp28->polyOpa.p;
    sp28->polyOpa.p = &temp_v1[1];
    temp_v1->words.w1 = -0x3800;
    temp_v1->words.w0 = 0xFB000000;
    SkelAnime_DrawSV(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, func_80B4E5B0, func_80B4E61C, thisx);
}

s32 func_80B4E6E4(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3f *arg3, Vec3s *arg4, Actor *arg5) {
    if (arg1 == 9) {
        arg4->x += arg5[2].shape.rot.y;
        arg4->y += arg5[2].shape.rot.z;
        arg4->z += arg5[2].shape.rot.x;
    } else if (arg1 == 2) {
        arg4->x += (s32) (arg5->unk_358 * (f32) arg5[2].shape.rot.y);
    }
    return 0;
}

void func_80B4E784(GlobalContext *arg0, s32 arg1, Gfx **arg2, Vec3s *arg3, Actor *arg4) {
    if (arg1 == 9) {
        SysMatrix_GetStateTranslation(arg4 + 0x3C);
    }
}

void func_80B4E7BC(Actor *thisx, GlobalContext *globalCtx) {
    GraphicsContext *sp30;
    Gfx *temp_v1;
    Gfx *temp_v1_2;
    GraphicsContext *temp_a0;

    temp_a0 = globalCtx->state.gfxCtx;
    sp30 = temp_a0;
    func_8012C28C(temp_a0);
    temp_v1 = sp30->polyOpa.p;
    sp30->polyOpa.p = &temp_v1[1];
    temp_v1->words.w0 = 0xDB060024;
    temp_v1->words.w1 = (u32) D_80B4E984[(s8) thisx[2].colChkInfo.acHitEffect];
    temp_v1_2 = sp30->polyOpa.p;
    sp30->polyOpa.p = &temp_v1_2[1];
    temp_v1_2->words.w0 = 0xDB060020;
    temp_v1_2->words.w1 = (u32) D_80B4E96C[thisx->unk_333];
    SkelAnime_DrawSV(globalCtx, (void **) thisx[1].flags, thisx->unk_164, (s32) thisx[1].category, func_80B4E6E4, func_80B4E784, thisx);
}
